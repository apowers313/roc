{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Main","text":""},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>__init__</li> <li>action</li> <li>component</li> <li>config</li> <li>environment</li> <li>event</li> <li>graphdb</li> <li>gymnasium</li> <li>logger</li> <li>perception</li> <li>script</li> </ul>"},{"location":"reference/__init__/","title":"__init__","text":"<p>Reinforcement Learning of Concepts</p>"},{"location":"reference/__init__/#__init__.Component","title":"<code>Component</code>","text":"<p>             Bases: <code>ABC</code></p> <p>An abstract component class for building pieces of ROC that will talk to each other.</p> Source code in <code>roc/component.py</code> <pre><code>class Component(ABC):\n\"\"\"An abstract component class for building pieces of ROC that will talk to each other.\"\"\"\n\n    def __init__(self, name: str, type: str):\n\"\"\"Component constructor.\n\n        Args:\n            name (str): Name of the component. Mostly used for eventing.\n            type (str): Type of the component. Will be set by the concrete class. Mostly used for \\\n                eventing.\n        \"\"\"\n        self._name = name\n        self._type = type\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"Getter for the name of the component\n\n        Returns:\n            str: the name of the component\n\n        Example:\n            &gt;&gt;&gt; c = Component(\"foo\", \"bar\")\n            &gt;&gt;&gt; print(c.name)\n            foo\n        \"\"\"\n        return self._name\n\n    @property\n    def type(self) -&gt; str:\n\"\"\"Getter for the type of the component\n\n        Returns:\n            str: the type of the component\n\n        Example:\n            &gt;&gt;&gt; c = Component(\"foo\", \"bar\")\n            &gt;&gt;&gt; print(c.type)\n            bar\n        \"\"\"\n        return self._type\n</code></pre>"},{"location":"reference/__init__/#__init__.Component.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Getter for the name of the component</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the name of the component</p> Example <p>c = Component(\"foo\", \"bar\") print(c.name) foo</p>"},{"location":"reference/__init__/#__init__.Component.type","title":"<code>type: str</code>  <code>property</code>","text":"<p>Getter for the type of the component</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the type of the component</p> Example <p>c = Component(\"foo\", \"bar\") print(c.type) bar</p>"},{"location":"reference/__init__/#__init__.Component.__init__","title":"<code>__init__(name, type)</code>","text":"<p>Component constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the component. Mostly used for eventing.</p> required <code>type</code> <code>str</code> <p>Type of the component. Will be set by the concrete class. Mostly used for                 eventing.</p> required Source code in <code>roc/component.py</code> <pre><code>def __init__(self, name: str, type: str):\n\"\"\"Component constructor.\n\n    Args:\n        name (str): Name of the component. Mostly used for eventing.\n        type (str): Type of the component. Will be set by the concrete class. Mostly used for \\\n            eventing.\n    \"\"\"\n    self._name = name\n    self._type = type\n</code></pre>"},{"location":"reference/action/","title":"action","text":""},{"location":"reference/component/","title":"component","text":""},{"location":"reference/component/#component.Component","title":"<code>Component</code>","text":"<p>             Bases: <code>ABC</code></p> <p>An abstract component class for building pieces of ROC that will talk to each other.</p> Source code in <code>roc/component.py</code> <pre><code>class Component(ABC):\n\"\"\"An abstract component class for building pieces of ROC that will talk to each other.\"\"\"\n\n    def __init__(self, name: str, type: str):\n\"\"\"Component constructor.\n\n        Args:\n            name (str): Name of the component. Mostly used for eventing.\n            type (str): Type of the component. Will be set by the concrete class. Mostly used for \\\n                eventing.\n        \"\"\"\n        self._name = name\n        self._type = type\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"Getter for the name of the component\n\n        Returns:\n            str: the name of the component\n\n        Example:\n            &gt;&gt;&gt; c = Component(\"foo\", \"bar\")\n            &gt;&gt;&gt; print(c.name)\n            foo\n        \"\"\"\n        return self._name\n\n    @property\n    def type(self) -&gt; str:\n\"\"\"Getter for the type of the component\n\n        Returns:\n            str: the type of the component\n\n        Example:\n            &gt;&gt;&gt; c = Component(\"foo\", \"bar\")\n            &gt;&gt;&gt; print(c.type)\n            bar\n        \"\"\"\n        return self._type\n</code></pre>"},{"location":"reference/component/#component.Component.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Getter for the name of the component</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the name of the component</p> Example <p>c = Component(\"foo\", \"bar\") print(c.name) foo</p>"},{"location":"reference/component/#component.Component.type","title":"<code>type: str</code>  <code>property</code>","text":"<p>Getter for the type of the component</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the type of the component</p> Example <p>c = Component(\"foo\", \"bar\") print(c.type) bar</p>"},{"location":"reference/component/#component.Component.__init__","title":"<code>__init__(name, type)</code>","text":"<p>Component constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the component. Mostly used for eventing.</p> required <code>type</code> <code>str</code> <p>Type of the component. Will be set by the concrete class. Mostly used for                 eventing.</p> required Source code in <code>roc/component.py</code> <pre><code>def __init__(self, name: str, type: str):\n\"\"\"Component constructor.\n\n    Args:\n        name (str): Name of the component. Mostly used for eventing.\n        type (str): Type of the component. Will be set by the concrete class. Mostly used for \\\n            eventing.\n    \"\"\"\n    self._name = name\n    self._type = type\n</code></pre>"},{"location":"reference/config/","title":"config","text":""},{"location":"reference/config/#config.load_config","title":"<code>load_config(*, force=False)</code>","text":"<p>Initializes the settings by reading the configuration files and environment variables</p> Source code in <code>roc/config.py</code> <pre><code>def load_config(*, force: bool = False) -&gt; None:\n\"\"\"Initializes the settings by reading the configuration files and environment variables\"\"\"\n    global initialized\n    if initialized and not force:\n        return\n\n    global _settings\n    _settings = Dynaconf(\n        envvar_prefix=\"ROC\",\n        settings_files=[\"settings.toml\", \".secrets.toml\"],\n        validators=settings_vars,\n    )\n\n    initialized = True\n    config_modules()\n</code></pre>"},{"location":"reference/environment/","title":"environment","text":""},{"location":"reference/event/","title":"event","text":""},{"location":"reference/event/#event.BusConnection","title":"<code>BusConnection</code>","text":"<p>             Bases: <code>Generic[EventData]</code></p> <p>A connection between an EventBus and a Component, used to send Events</p> <p>Parameters:</p> Name Type Description Default <code>Generic</code> <code>EventData</code> <p>The data type that will be sent over this connection</p> required Source code in <code>roc/event.py</code> <pre><code>class BusConnection(Generic[EventData]):\n\"\"\"A connection between an EventBus and a Component, used to send Events\n\n    Args:\n        Generic (EventData): The data type that will be sent over this connection\n    \"\"\"\n\n    def __init__(self, bus: EventBus[EventData], component: Component):\n        self.attached_bus = bus\n        self.attached_component = component\n        self.subject: rx.Subject[Event[EventData]] = self.attached_bus.subject\n\n    def send(self, data: EventData) -&gt; None:\n\"\"\"Send data over the EventBus. Internally, the data is converted to an Event\n        with the relevant data (such as the source Component).\n\n        Args:\n            data (EventData): The data type of the data to be sent\n        \"\"\"\n        e = Event[EventData](data, self.attached_component, self.attached_bus)\n        logger.trace(f\"&gt;&gt;&gt; Sending {e}\")\n        self.attached_bus.subject.on_next(e)\n</code></pre>"},{"location":"reference/event/#event.BusConnection.send","title":"<code>send(data)</code>","text":"<p>Send data over the EventBus. Internally, the data is converted to an Event with the relevant data (such as the source Component).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>EventData</code> <p>The data type of the data to be sent</p> required Source code in <code>roc/event.py</code> <pre><code>def send(self, data: EventData) -&gt; None:\n\"\"\"Send data over the EventBus. Internally, the data is converted to an Event\n    with the relevant data (such as the source Component).\n\n    Args:\n        data (EventData): The data type of the data to be sent\n    \"\"\"\n    e = Event[EventData](data, self.attached_component, self.attached_bus)\n    logger.trace(f\"&gt;&gt;&gt; Sending {e}\")\n    self.attached_bus.subject.on_next(e)\n</code></pre>"},{"location":"reference/event/#event.Event","title":"<code>Event</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[EventData]</code></p> <p>An abstract event class for sending messages between Components over an EventBus</p> <p>Parameters:</p> Name Type Description Default <code>ABC</code> <code>ABC</code> <p>Abstract base class</p> required <code>Generic</code> <code>EventData</code> <p>The data to be carried by the event</p> required Source code in <code>roc/event.py</code> <pre><code>class Event(ABC, Generic[EventData]):\n\"\"\"An abstract event class for sending messages between Components over an EventBus\n\n    Args:\n        ABC (ABC): Abstract base class\n        Generic (EventData): The data to be carried by the event\n    \"\"\"\n\n    def __init__(self, data: EventData, src: Component, bus: EventBus[EventData]):\n\"\"\"The initializer for the Event\n\n        Args:\n            data (EventData): The data for this event\n            src (Component): The Component sending the event\n            bus (EventBus): The EventBus that the event is being sent over\n        \"\"\"\n        self.data = data\n        self.src = src\n        self.bus = bus\n\n    def __repr__(self) -&gt; str:\n        data_str = pretty_repr(\n            self.data,\n            # max_depth=4, # Maximum depth of nested data structure\n            max_length=5,  # Maximum length of containers before abbreviating\n            max_string=60,  # Maximum length of string before truncating\n            expand_all=False,  # Expand all containers regardless of available width\n            max_width=120,\n        )\n        if \"\\n\" in data_str:\n            data_str = \"\\n\" + data_str\n        return f\"[EVENT: {self.src.name} &gt;&gt;&gt; {self.bus.name}]: {data_str}\"\n</code></pre>"},{"location":"reference/event/#event.Event.__init__","title":"<code>__init__(data, src, bus)</code>","text":"<p>The initializer for the Event</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>EventData</code> <p>The data for this event</p> required <code>src</code> <code>Component</code> <p>The Component sending the event</p> required <code>bus</code> <code>EventBus</code> <p>The EventBus that the event is being sent over</p> required Source code in <code>roc/event.py</code> <pre><code>def __init__(self, data: EventData, src: Component, bus: EventBus[EventData]):\n\"\"\"The initializer for the Event\n\n    Args:\n        data (EventData): The data for this event\n        src (Component): The Component sending the event\n        bus (EventBus): The EventBus that the event is being sent over\n    \"\"\"\n    self.data = data\n    self.src = src\n    self.bus = bus\n</code></pre>"},{"location":"reference/event/#event.EventBus","title":"<code>EventBus</code>","text":"<p>             Bases: <code>Generic[EventData]</code></p> <p>A communication channel for sending events between Components</p> <p>Parameters:</p> Name Type Description Default <code>Generic</code> <code>EventData</code> <p>The data type that is allowed to be sent over the bus</p> required Source code in <code>roc/event.py</code> <pre><code>class EventBus(Generic[EventData]):\n\"\"\"A communication channel for sending events between Components\n\n    Args:\n        Generic (EventData): The data type that is allowed to be sent over the bus\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        if name in eventbus_names:\n            raise Exception(f\"Duplicate EventBus name: {name}\")\n        self.name = name\n        eventbus_names.add(name)\n        self.subject = rx.Subject[Event[EventData]]()\n\n    def connect(self, component: Component) -&gt; BusConnection[EventData]:\n\"\"\"Creates a connection between an EventBus and a Component for sending Events\n\n        Args:\n            component (Component): The Component to connect to the bus\n\n        Returns:\n            BusConnection[EventData]: A new connection that can be used to send data\n        \"\"\"\n        return BusConnection[EventData](self, component)\n\n    @staticmethod\n    def clear_names() -&gt; None:\n\"\"\"Clears all EventBusses that have been registered, mostly used for testing.\"\"\"\n        eventbus_names.clear()\n</code></pre>"},{"location":"reference/event/#event.EventBus.clear_names","title":"<code>clear_names()</code>  <code>staticmethod</code>","text":"<p>Clears all EventBusses that have been registered, mostly used for testing.</p> Source code in <code>roc/event.py</code> <pre><code>@staticmethod\ndef clear_names() -&gt; None:\n\"\"\"Clears all EventBusses that have been registered, mostly used for testing.\"\"\"\n    eventbus_names.clear()\n</code></pre>"},{"location":"reference/event/#event.EventBus.connect","title":"<code>connect(component)</code>","text":"<p>Creates a connection between an EventBus and a Component for sending Events</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>Component</code> <p>The Component to connect to the bus</p> required <p>Returns:</p> Type Description <code>BusConnection[EventData]</code> <p>BusConnection[EventData]: A new connection that can be used to send data</p> Source code in <code>roc/event.py</code> <pre><code>def connect(self, component: Component) -&gt; BusConnection[EventData]:\n\"\"\"Creates a connection between an EventBus and a Component for sending Events\n\n    Args:\n        component (Component): The Component to connect to the bus\n\n    Returns:\n        BusConnection[EventData]: A new connection that can be used to send data\n    \"\"\"\n    return BusConnection[EventData](self, component)\n</code></pre>"},{"location":"reference/graphdb/","title":"graphdb","text":""},{"location":"reference/graphdb/#graphdb.Edge","title":"<code>Edge</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An edge (a.k.a. Relationship or Connection) between two Nodes. An edge obect automatically implements all phases of CRUD in the underlying graph database. This is a directional relationship with a \"source\" and \"destination\". The source and destination properties are dynamically loaded through property getters when they are called, and may trigger a graph database query if they don't already exist in the edge cache.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class Edge(BaseModel, extra=\"allow\"):\n\"\"\"\n    An edge (a.k.a. Relationship or Connection) between two Nodes. An edge obect automatically\n    implements all phases of CRUD in the underlying graph database. This is a directional\n    relationship with a \"source\" and \"destination\". The source and destination properties\n    are dynamically loaded through property getters when they are called, and may trigger\n    a graph database query if they don't already exist in the edge cache.\n    \"\"\"\n\n    id: EdgeId = Field(exclude=True)\n    type: str = Field(literal=True, exclude=True)\n    src_id: NodeId = Field(literal=True, exclude=True)\n    dst_id: NodeId = Field(literal=True, exclude=True)\n\n    @field_validator(\"id\", mode=\"before\")\n    def default_id(cls, id: EdgeId | None) -&gt; EdgeId:\n        if isinstance(id, int):\n            return id\n\n        return get_next_new_edge_id()\n\n    @property\n    def src(self) -&gt; Node:\n        return Node.get(self.src_id)\n\n    @property\n    def dst(self) -&gt; Node:\n        return Node.get(self.dst_id)\n\n    @property\n    def new(self) -&gt; bool:\n        return self._new\n\n    def __init__(\n        self,\n        src_id: NodeId,\n        dst_id: NodeId,\n        type: str,\n        *,\n        id: EdgeId | None = None,\n        data: dict[Any, Any] | None = None,\n    ):\n        data = data or {}\n        super().__init__(\n            src_id=src_id,\n            dst_id=dst_id,\n            type=type,\n            id=id,\n            **data,\n        )\n\n        self._new = False\n        self._no_save = False\n        self._deleted = False\n\n        if self.id &lt; 0:\n            self._new = True\n            Edge.get_cache()[self.id] = self\n\n    def __del__(self) -&gt; None:\n        Edge.save(self)\n\n    # @cached(cache=\n    # LRUCache(get_setting(\"edge_cache_size\", int)), key=lambda cls, id: id, info=True)\n\n    @classmethod\n    def get_cache(self) -&gt; EdgeCache:\n        global edge_cache\n        if edge_cache is None:\n            edge_cache = EdgeCache(maxsize=get_setting(\"edge_cache_size\", int))\n\n        return edge_cache\n\n    @classmethod\n    def get(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Looks up an Edge based on it's ID. If the Edge is cached, the cached edge is returned;\n        otherwise the Edge is queried from the graph database based the ID provided and a new\n        Edge is returned and cached.\n\n        Args:\n            id (EdgeId): the unique identifier for the Edge\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: returns the Edge requested by the id\n        \"\"\"\n        cache = Edge.get_cache()\n        e = cache.get(id)\n        if not e:\n            e = cls.load(id, db=db)\n            cache[id] = e\n\n        return cast(Self, e)\n\n    @classmethod\n    def load(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Loads an Edge from the graph database without attempting to check if the Edge\n        already exists in the cache. Typically this is only called by Edge.get()\n\n        Args:\n            id (EdgeId): the unique identifier of the Edge to fetch\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            EdgeNotFound: if the specified ID does not exist in the cache or the database\n\n        Returns:\n            Self: returns the Edge requested by the id\n        \"\"\"\n        db = db or GraphDB.singleton()\n        edge_list = list(db.raw_fetch(f\"MATCH (n)-[e]-(m) WHERE id(e) = {id} RETURN e LIMIT 1\"))\n        if not len(edge_list) == 1:\n            raise EdgeNotFound(f\"Couldn't find edge ID: {id}\")\n\n        e = edge_list[0][\"e\"]\n        props = None\n        if hasattr(e, \"properties\"):\n            props = e.properties\n        return cls(\n            e.start_id,\n            e.end_id,\n            id=id,\n            data=props,\n            type=e.type,\n        )\n\n    @classmethod\n    def save(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Saves the edge to the database. Calls Edge.create if the edge is new, or Edge.update if\n        edge already exists in the database.\n\n        Args:\n            e (Self): The edge to save\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: The same edge that was passed in, for convenience. The Edge may be updated with a\n            new identifier if it was newly created in the database.\n        \"\"\"\n        if e._new:\n            return cls.create(e, db=db)\n        else:\n            return cls.update(e, db=db)\n\n    @classmethod\n    def create(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Creates a new edge in the database. Typically only called by Edge.save\n\n        Args:\n            e (Self): The edge to create\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            EdgeCreateFailed: Failed to write the edge to the database, for eample\n                if the ID is wrong.\n\n        Returns:\n            Self: the edge that was created, with an updated identifier and other chagned attributes\n        \"\"\"\n        if e._no_save:\n            return e\n\n        db = db or GraphDB.singleton()\n        old_id = e.id\n\n        if e.src._new:\n            Node.save(e.src)\n\n        if e.dst._new:\n            Node.save(e.dst)\n\n        params = {\"props\": e.model_dump()}\n\n        ret = list(\n            db.raw_fetch(\n                f\"\"\"\n                MATCH (src), (dst)\n                WHERE id(src) = {e.src_id} AND id(dst) = {e.dst_id}                 CREATE (src)-[e:{e.type} $props]-&gt;(dst)\n                RETURN id(e) as e_id\n                \"\"\",\n                params=params,\n            )\n        )\n\n        if len(ret) != 1:\n            raise EdgeCreateFailed(\"failed to create new edge\")\n\n        e.id = ret[0][\"e_id\"]\n        e._new = False\n        # update the cache; if being called during __del__ then the cache entry may not exist\n        try:\n            cache = Edge.get_cache()\n            del cache[old_id]\n            cache[e.id] = e\n        except KeyError:\n            pass\n        # update references to edge id\n        e.src.src_edges.replace(old_id, e.id)\n        e.dst.dst_edges.replace(old_id, e.id)\n\n        return e\n\n    @classmethod\n    def update(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Updates the edge in the database. Typically only called by Edge.save\n\n        Args:\n            e (Self): The edge to update\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: The same edge that was passed in, for convenience\n        \"\"\"\n        if e._no_save:\n            return e\n\n        db = db or GraphDB.singleton()\n\n        params = {\"props\": e.model_dump()}\n\n        db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} SET e = $props\", params=params)\n\n        return e\n\n    @staticmethod\n    def delete(e: Edge, *, db: GraphDB | None = None) -&gt; None:\n\"\"\"Deletes the specified edge from the database. If the edge has not already been persisted\n        to the database, this marks the edge as deleted and returns.\n\n        Args:\n            e (Edge): The edge to delete\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n        \"\"\"\n        e._deleted = True\n        e._no_save = True\n        db = db or GraphDB.singleton()\n\n        # remove e from src and dst nodes\n        e.src.src_edges.discard(e)\n        e.dst.dst_edges.discard(e)\n\n        # remove from cache\n        edge_cache = Edge.get_cache()\n        if e.id in edge_cache:\n            del edge_cache[e.id]\n\n        # delete from db\n        if not e._new:\n            db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} DELETE e\")\n\n    @staticmethod\n    def to_id(e: Edge | EdgeId) -&gt; EdgeId:\n        if isinstance(e, Edge):\n            return e.id\n        else:\n            return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.create","title":"<code>create(e, *, db=None)</code>  <code>classmethod</code>","text":"<p>Creates a new edge in the database. Typically only called by Edge.save</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Self</code> <p>The edge to create</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>EdgeCreateFailed</code> <p>Failed to write the edge to the database, for eample if the ID is wrong.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the edge that was created, with an updated identifier and other chagned attributes</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef create(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Creates a new edge in the database. Typically only called by Edge.save\n\n    Args:\n        e (Self): The edge to create\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        EdgeCreateFailed: Failed to write the edge to the database, for eample\n            if the ID is wrong.\n\n    Returns:\n        Self: the edge that was created, with an updated identifier and other chagned attributes\n    \"\"\"\n    if e._no_save:\n        return e\n\n    db = db or GraphDB.singleton()\n    old_id = e.id\n\n    if e.src._new:\n        Node.save(e.src)\n\n    if e.dst._new:\n        Node.save(e.dst)\n\n    params = {\"props\": e.model_dump()}\n\n    ret = list(\n        db.raw_fetch(\n            f\"\"\"\n            MATCH (src), (dst)\n            WHERE id(src) = {e.src_id} AND id(dst) = {e.dst_id}             CREATE (src)-[e:{e.type} $props]-&gt;(dst)\n            RETURN id(e) as e_id\n            \"\"\",\n            params=params,\n        )\n    )\n\n    if len(ret) != 1:\n        raise EdgeCreateFailed(\"failed to create new edge\")\n\n    e.id = ret[0][\"e_id\"]\n    e._new = False\n    # update the cache; if being called during __del__ then the cache entry may not exist\n    try:\n        cache = Edge.get_cache()\n        del cache[old_id]\n        cache[e.id] = e\n    except KeyError:\n        pass\n    # update references to edge id\n    e.src.src_edges.replace(old_id, e.id)\n    e.dst.dst_edges.replace(old_id, e.id)\n\n    return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.delete","title":"<code>delete(e, *, db=None)</code>  <code>staticmethod</code>","text":"<p>Deletes the specified edge from the database. If the edge has not already been persisted to the database, this marks the edge as deleted and returns.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Edge</code> <p>The edge to delete</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef delete(e: Edge, *, db: GraphDB | None = None) -&gt; None:\n\"\"\"Deletes the specified edge from the database. If the edge has not already been persisted\n    to the database, this marks the edge as deleted and returns.\n\n    Args:\n        e (Edge): The edge to delete\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n    \"\"\"\n    e._deleted = True\n    e._no_save = True\n    db = db or GraphDB.singleton()\n\n    # remove e from src and dst nodes\n    e.src.src_edges.discard(e)\n    e.dst.dst_edges.discard(e)\n\n    # remove from cache\n    edge_cache = Edge.get_cache()\n    if e.id in edge_cache:\n        del edge_cache[e.id]\n\n    # delete from db\n    if not e._new:\n        db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} DELETE e\")\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.get","title":"<code>get(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Looks up an Edge based on it's ID. If the Edge is cached, the cached edge is returned; otherwise the Edge is queried from the graph database based the ID provided and a new Edge is returned and cached.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>EdgeId</code> <p>the unique identifier for the Edge</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>returns the Edge requested by the id</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Looks up an Edge based on it's ID. If the Edge is cached, the cached edge is returned;\n    otherwise the Edge is queried from the graph database based the ID provided and a new\n    Edge is returned and cached.\n\n    Args:\n        id (EdgeId): the unique identifier for the Edge\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: returns the Edge requested by the id\n    \"\"\"\n    cache = Edge.get_cache()\n    e = cache.get(id)\n    if not e:\n        e = cls.load(id, db=db)\n        cache[id] = e\n\n    return cast(Self, e)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.load","title":"<code>load(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Loads an Edge from the graph database without attempting to check if the Edge already exists in the cache. Typically this is only called by Edge.get()</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>EdgeId</code> <p>the unique identifier of the Edge to fetch</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>EdgeNotFound</code> <p>if the specified ID does not exist in the cache or the database</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>returns the Edge requested by the id</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef load(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Loads an Edge from the graph database without attempting to check if the Edge\n    already exists in the cache. Typically this is only called by Edge.get()\n\n    Args:\n        id (EdgeId): the unique identifier of the Edge to fetch\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        EdgeNotFound: if the specified ID does not exist in the cache or the database\n\n    Returns:\n        Self: returns the Edge requested by the id\n    \"\"\"\n    db = db or GraphDB.singleton()\n    edge_list = list(db.raw_fetch(f\"MATCH (n)-[e]-(m) WHERE id(e) = {id} RETURN e LIMIT 1\"))\n    if not len(edge_list) == 1:\n        raise EdgeNotFound(f\"Couldn't find edge ID: {id}\")\n\n    e = edge_list[0][\"e\"]\n    props = None\n    if hasattr(e, \"properties\"):\n        props = e.properties\n    return cls(\n        e.start_id,\n        e.end_id,\n        id=id,\n        data=props,\n        type=e.type,\n    )\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.save","title":"<code>save(e, *, db=None)</code>  <code>classmethod</code>","text":"<p>Saves the edge to the database. Calls Edge.create if the edge is new, or Edge.update if edge already exists in the database.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Self</code> <p>The edge to save</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The same edge that was passed in, for convenience. The Edge may be updated with a</p> <code>Self</code> <p>new identifier if it was newly created in the database.</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef save(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Saves the edge to the database. Calls Edge.create if the edge is new, or Edge.update if\n    edge already exists in the database.\n\n    Args:\n        e (Self): The edge to save\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: The same edge that was passed in, for convenience. The Edge may be updated with a\n        new identifier if it was newly created in the database.\n    \"\"\"\n    if e._new:\n        return cls.create(e, db=db)\n    else:\n        return cls.update(e, db=db)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.update","title":"<code>update(e, *, db=None)</code>  <code>classmethod</code>","text":"<p>Updates the edge in the database. Typically only called by Edge.save</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Self</code> <p>The edge to update</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The same edge that was passed in, for convenience</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef update(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Updates the edge in the database. Typically only called by Edge.save\n\n    Args:\n        e (Self): The edge to update\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: The same edge that was passed in, for convenience\n    \"\"\"\n    if e._no_save:\n        return e\n\n    db = db or GraphDB.singleton()\n\n    params = {\"props\": e.model_dump()}\n\n    db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} SET e = $props\", params=params)\n\n    return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator","title":"<code>EdgeFetchIterator</code>","text":"<p>The implementation of an iterator for an EdgeList. Only intended to be used internally by EdgeList.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeFetchIterator:\n\"\"\"\n    The implementation of an iterator for an EdgeList. Only intended to be used internally by\n    EdgeList.\n    \"\"\"\n\n    def __init__(self, edge_list: list[EdgeId]):\n        self.__edge_list = edge_list\n        self.cur = 0\n\n    def __iter__(self) -&gt; EdgeFetchIterator:\n        return self\n\n    def __next__(self) -&gt; Edge:\n        if self.cur &gt;= len(self.__edge_list):\n            raise StopIteration\n\n        id = self.__edge_list[self.cur]\n        self.cur = self.cur + 1\n        return Edge.get(id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList","title":"<code>EdgeList</code>","text":"<p>             Bases: <code>MutableSet[Edge | EdgeId]</code>, <code>Mapping[int, Edge]</code></p> <p>A list of Edges that is used by Node for keeping track of the connections it has. Implements interfaces for both a MutableSet (i.e. set()) and a Mapping (i.e. read-only list())</p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeList(MutableSet[Edge | EdgeId], Mapping[int, Edge]):\n\"\"\"\n    A list of Edges that is used by Node for keeping track of the connections it has.\n    Implements interfaces for both a MutableSet (i.e. set()) and a Mapping (i.e. read-only list())\n    \"\"\"\n\n    def __init__(self, ids: list[EdgeId] | set[EdgeId]):\n        self.__edges: list[EdgeId] = list(ids)\n\n    def __iter__(self) -&gt; EdgeFetchIterator:\n        return EdgeFetchIterator(self.__edges)\n\n    def __getitem__(self, key: int) -&gt; Edge:\n        return Edge.get(self.__edges[key])\n\n    def __len__(self) -&gt; int:\n        return len(self.__edges)\n\n    def __contains__(self, e: Any) -&gt; bool:\n        if isinstance(e, Edge) or isinstance(e, int):\n            e_id = Edge.to_id(e)  # type: ignore\n        else:\n            return False\n\n        return e_id in self.__edges\n\n    def add(self, e: Edge | EdgeId) -&gt; None:\n        e_id = Edge.to_id(e)\n\n        if e_id in self.__edges:\n            return\n\n        self.__edges.append(e_id)\n\n    def discard(self, e: Edge | EdgeId) -&gt; None:\n        e_id = Edge.to_id(e)\n\n        self.__edges.remove(e_id)\n\n    def replace(self, old: Edge | EdgeId, new: Edge | EdgeId) -&gt; None:\n        old_id = Edge.to_id(old)\n        new_id = Edge.to_id(new)\n        for i in range(len(self.__edges)):\n            if self.__edges[i] == old_id:\n                self.__edges[i] = new_id\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB","title":"<code>GraphDB</code>","text":"<p>A graph database singleton. Settings for the graph database come from the config module.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class GraphDB:\n\"\"\"\n    A graph database singleton. Settings for the graph database come from the config module.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.host = get_setting(\"db_host\", str)\n        self.port = get_setting(\"db_port\", int)\n        self.encrypted = get_setting(\"db_conn_encrypted\", bool)\n        self.username = get_setting(\"db_username\", str)\n        self.password = get_setting(\"db_password\", str)\n        self.lazy = get_setting(\"db_lazy\", bool)\n        self.client_name = \"roc-graphdb-client\"\n        self.db_conn = self.connect()\n\n    def raw_fetch(\n        self, query: str, *, params: dict[str, Any] | None = None\n    ) -&gt; Iterator[dict[str, Any]]:\n        params = params or {}\n        logger.trace(f\"raw_fetch: '{query}' *** with params: *** '{params}\")\n\n        cursor = self.db_conn.cursor()\n        cursor.execute(query, params)\n        while True:\n            row = cursor.fetchone()\n            if row is None:\n                break\n            yield {\n                dsc.name: _convert_memgraph_value(row[index])\n                for index, dsc in enumerate(cursor.description)\n            }\n\n    def raw_execute(self, query: str, *, params: dict[str, Any] | None = None) -&gt; None:\n        params = params or {}\n        logger.trace(f\"raw_execute: '{query}' *** with params: *** '{params}'\")\n        cursor = self.db_conn.cursor()\n        cursor.execute(query, params)\n        cursor.fetchall()\n\n    def connected(self) -&gt; bool:\n        return self.db_conn is not None and self.db_conn.status == mgclient.CONN_STATUS_READY\n\n    def connect(self) -&gt; mgclient.Connection:\n        sslmode = mgclient.MG_SSLMODE_REQUIRE if self.encrypted else mgclient.MG_SSLMODE_DISABLE\n        connection = mgclient.connect(\n            host=self.host,\n            port=self.port,\n            username=self.username,\n            password=self.password,\n            sslmode=sslmode,\n            lazy=self.lazy,\n            client_name=self.client_name,\n        )\n        connection.autocommit = True\n        return connection\n\n    @classmethod\n    def singleton(cls) -&gt; GraphDB:\n        global graph_db_singleton\n        if not graph_db_singleton:\n            graph_db_singleton = GraphDB()\n\n        return graph_db_singleton\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node","title":"<code>Node</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An graph database node that automatically handles CRUD for the underlying graph database objects</p> Source code in <code>roc/graphdb.py</code> <pre><code>class Node(BaseModel, extra=\"allow\"):\n\"\"\"\n    An graph database node that automatically handles CRUD for the underlying graph database objects\n    \"\"\"\n\n    id: NodeId = Field(exclude=True)\n    labels: set[str] = Field(exclude=True)\n\n    @field_validator(\"id\", mode=\"before\")\n    def default_id(cls, id: NodeId | None) -&gt; NodeId:\n        if isinstance(id, int):\n            return id\n\n        return get_next_new_node_id()\n\n    @field_validator(\"labels\", mode=\"before\")\n    def default_labels(cls, labels: list[str] | set[str] | None) -&gt; set[str]:\n        if not labels:\n            return set()\n\n        if isinstance(labels, list):\n            return set(labels)\n\n        return labels\n\n    @property\n    def src_edges(self) -&gt; EdgeList:\n        return self._src_edges\n\n    @property\n    def dst_edges(self) -&gt; EdgeList:\n        return self._dst_edges\n\n    @property\n    def new(self) -&gt; bool:\n        return self._new\n\n    def __init__(\n        self,\n        *,\n        id: NodeId | None = None,\n        data: dict[Any, Any] | None = None,\n        labels: set[str] | list[str] | None = None,\n        src_edges: EdgeList | None = None,\n        dst_edges: EdgeList | None = None,\n        db: GraphDB | None = None,\n    ):\n        data = data or {}\n\n        super().__init__(\n            id=id,\n            labels=labels,\n            **data,\n        )\n\n        self._new = False\n        self._no_save = False\n        self._deleted = False\n        self._db = db or GraphDB.singleton()\n\n        if self.id &lt; 0:\n            self._new = True  # TODO: derived?\n            Node.get_cache()[self.id] = self\n\n        self._orig_labels = self.labels.copy()\n        self._src_edges = src_edges or EdgeList([])\n        self._dst_edges = dst_edges or EdgeList([])\n        # TODO: ignore fields on save\n        # self._ignored_fields = [\"new\", \"no_save\", \"deleted\"]\n\n    def __del__(self) -&gt; None:\n        try:\n            self.__class__.save(self, db=self._db)\n        except Exception as e:\n            err_msg = f\"error saving during del: {e}\"\n            logger.warning(err_msg)\n            warnings.warn(err_msg, ErrorSavingDuringDelWarning)\n\n    @classmethod\n    def load(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Loads a node from the database. Use `Node.get` or other methods instead.\n\n        Args:\n            id (NodeId): The identifier of the node to fetch\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            NodeNotFound: The node specified by the identifier does not exist in the database\n\n        Returns:\n            Self: The node from the database\n        \"\"\"\n\n        db = db or GraphDB.singleton()\n        res = list(\n            db.raw_fetch(\n                f\"\"\"\n                MATCH (n)-[e]-(m) WHERE id(n) = {id}\n                RETURN n, e, id(e) as e_id, id(startNode(e)) as e_start, id(endNode(e)) as e_end\n                \"\"\",\n            )\n        )\n\n        # print(\"RES\", res)\n\n        if not len(res) &gt;= 1:\n            raise NodeNotFound(f\"Couldn't find node ID: {id}\")\n\n        n = res[0][\"n\"]\n        edges = list(\n            map(lambda r: {\"id\": r[\"e_id\"], \"start\": r[\"e_start\"], \"end\": r[\"e_end\"]}, res)\n        )\n        src_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"start\"] == id, edges)))\n        dst_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"end\"] == id, edges)))\n        return cls(\n            id=id,\n            src_edges=EdgeList(src_edges),\n            dst_edges=EdgeList(dst_edges),\n            labels=n.labels,\n            data=n.properties,\n        )\n\n    @classmethod\n    def get_cache(cls) -&gt; NodeCache:\n        global node_cache\n        if node_cache is None:\n            node_cache = NodeCache(get_setting(\"node_cache_size\", int))\n\n        return node_cache\n\n    @classmethod\n    def get(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Returns a cached node with the specified id. If no node is cached, it is retrieved from\n        the database.\n\n\n        Args:\n            id (NodeId): The unique identifier of the node to fetch\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: the cached or newly retrieved node\n        \"\"\"\n        cache = Node.get_cache()\n        n = cache.get(id)\n        if not n:\n            n = cls.load(id, db=db)\n            cache[id] = n\n\n        return cast(Self, n)\n\n    @classmethod\n    def save(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Save a node to persistent storage\n\n        Writes the specified node to the GraphDB for persistent storage. If the node does not\n        already exist in storage, it is created via the `create` method. If the node does exist, it\n        is updated via the `update` method.\n\n        If the _no_save flag is True on the node, the save request will be silently ignored.\n\n        Args:\n            n (Self): The Node to be saved\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: As a convenience, the node that was stored is returned. This may be useful\n            since the the id of the node may change if it was created in the database.\n        \"\"\"\n        if n._new:\n            return cls.create(n, db=db)\n        else:\n            return cls.update(n, db=db)\n\n    @classmethod\n    def update(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Update an existing node in the GraphDB.\n\n        Calling `save` is preferred to using this method so that the caller doesn't need to know the\n        state of the node.\n\n        Args:\n            n (Self): The node to be updated\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: The node that was passed in, for convenience\n        \"\"\"\n        if n._no_save:\n            return n\n\n        db = db or GraphDB.singleton()\n\n        orig_labels = n._orig_labels\n        curr_labels = set(n.labels)\n        new_labels = curr_labels - orig_labels\n        rm_labels = orig_labels - curr_labels\n        set_label_str = Node.mklabels(new_labels)\n        if set_label_str:\n            set_query = f\"SET n{set_label_str}, n = $props\"\n        else:\n            set_query = \"SET n = $props\"\n        rm_label_str = Node.mklabels(rm_labels)\n        if rm_label_str:\n            rm_query = f\"REMOVE n{rm_label_str}\"\n        else:\n            rm_query = \"\"\n\n        params = {\"props\": n.model_dump()}\n\n        db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} {set_query} {rm_query}\", params=params)\n\n        return n\n\n    @classmethod\n    def create(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Creates the specified node in the GraphDB.\n\n        Calling `save` is preferred to using this method so that the caller doesn't need to know the\n        state of the node.\n\n        Args:\n            n (Self): the node to be created\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            NodeCreationFailed: if creating the node failed in the database\n\n        Returns:\n            Self: the node that was passed in, albeit with a new `id` and potenitally other new\n            fields\n        \"\"\"\n        if n._no_save:\n            return n\n\n        db = db or GraphDB.singleton()\n        old_id = n.id\n\n        label_str = Node.mklabels(n.labels)\n        params = {\"props\": n.model_dump()}\n\n        res = list(db.raw_fetch(f\"CREATE (n{label_str} $props) RETURN id(n) as id\", params=params))\n\n        if not len(res) &gt;= 1:\n            raise NodeCreationFailed(f\"Couldn't find node ID: {id}\")\n\n        new_id = res[0][\"id\"]\n        n.id = new_id\n        n._new = False\n        # update the cache; if being called during c then the cache entry may not exist\n        try:\n            cache = Node.get_cache()\n            del cache[old_id]\n            cache[new_id] = n\n        except KeyError:\n            pass\n\n        for e in n.src_edges:\n            assert e.src_id == old_id\n            e.src_id = new_id\n\n        for e in n.dst_edges:\n            assert e.dst_id == old_id\n            e.dst_id = new_id\n\n        return n\n\n    @classmethod\n    def connect(\n        cls,\n        src: NodeId | Self,\n        dst: NodeId | Self,\n        type: str,\n        *,\n        db: GraphDB | None = None,\n    ) -&gt; Edge:\n\"\"\"Connects two nodes (creates an Edge between two nodes)\n\n        Args:\n            src (NodeId | Node): _description_\n            dst (NodeId | Node): _description_\n            type (str): _description_\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Edge: _description_\n        \"\"\"\n        if isinstance(src, Node):\n            src_id = src.id\n        else:\n            src_id = src\n\n        if isinstance(dst, Node):\n            dst_id = dst.id\n        else:\n            dst_id = dst\n\n        e = Edge(src_id, dst_id, type)\n        src_node = cls.get(src_id, db=db)\n        dst_node = cls.get(dst_id, db=db)\n        src_node.src_edges.add(e)\n        dst_node.dst_edges.add(e)\n        return e\n\n    @staticmethod\n    def delete(n: Node, *, db: GraphDB | None = None) -&gt; None:\n        db = db or GraphDB.singleton()\n\n        # remove edges\n        for e in n.src_edges:\n            Edge.delete(e)\n\n        for e in n.dst_edges:\n            Edge.delete(e)\n\n        # remove from cache\n        node_cache = Node.get_cache()\n        if n.id in node_cache:\n            del node_cache[n.id]\n\n        if not n._new:\n            db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} DELETE n\")\n\n        n._deleted = True\n        n._no_save = True\n\n    @staticmethod\n    def mklabels(labels: set[str]) -&gt; str:\n        \"Converts a list of strings into proper Cypher syntax for a graph database query\"\n        labels_list = [i for i in labels]\n        labels_list.sort()\n        label_str = \":\".join(labels_list)\n        if len(label_str) &gt; 0:\n            label_str = \":\" + label_str\n        return label_str\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.connect","title":"<code>connect(src, dst, type, *, db=None)</code>  <code>classmethod</code>","text":"<p>Connects two nodes (creates an Edge between two nodes)</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>NodeId | Node</code> <p>description</p> required <code>dst</code> <code>NodeId | Node</code> <p>description</p> required <code>type</code> <code>str</code> <p>description</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Edge</code> <code>Edge</code> <p>description</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef connect(\n    cls,\n    src: NodeId | Self,\n    dst: NodeId | Self,\n    type: str,\n    *,\n    db: GraphDB | None = None,\n) -&gt; Edge:\n\"\"\"Connects two nodes (creates an Edge between two nodes)\n\n    Args:\n        src (NodeId | Node): _description_\n        dst (NodeId | Node): _description_\n        type (str): _description_\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Edge: _description_\n    \"\"\"\n    if isinstance(src, Node):\n        src_id = src.id\n    else:\n        src_id = src\n\n    if isinstance(dst, Node):\n        dst_id = dst.id\n    else:\n        dst_id = dst\n\n    e = Edge(src_id, dst_id, type)\n    src_node = cls.get(src_id, db=db)\n    dst_node = cls.get(dst_id, db=db)\n    src_node.src_edges.add(e)\n    dst_node.dst_edges.add(e)\n    return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.create","title":"<code>create(n, *, db=None)</code>  <code>classmethod</code>","text":"<p>Creates the specified node in the GraphDB.</p> <p>Calling <code>save</code> is preferred to using this method so that the caller doesn't need to know the state of the node.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Self</code> <p>the node to be created</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>NodeCreationFailed</code> <p>if creating the node failed in the database</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the node that was passed in, albeit with a new <code>id</code> and potenitally other new</p> <code>Self</code> <p>fields</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef create(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Creates the specified node in the GraphDB.\n\n    Calling `save` is preferred to using this method so that the caller doesn't need to know the\n    state of the node.\n\n    Args:\n        n (Self): the node to be created\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        NodeCreationFailed: if creating the node failed in the database\n\n    Returns:\n        Self: the node that was passed in, albeit with a new `id` and potenitally other new\n        fields\n    \"\"\"\n    if n._no_save:\n        return n\n\n    db = db or GraphDB.singleton()\n    old_id = n.id\n\n    label_str = Node.mklabels(n.labels)\n    params = {\"props\": n.model_dump()}\n\n    res = list(db.raw_fetch(f\"CREATE (n{label_str} $props) RETURN id(n) as id\", params=params))\n\n    if not len(res) &gt;= 1:\n        raise NodeCreationFailed(f\"Couldn't find node ID: {id}\")\n\n    new_id = res[0][\"id\"]\n    n.id = new_id\n    n._new = False\n    # update the cache; if being called during c then the cache entry may not exist\n    try:\n        cache = Node.get_cache()\n        del cache[old_id]\n        cache[new_id] = n\n    except KeyError:\n        pass\n\n    for e in n.src_edges:\n        assert e.src_id == old_id\n        e.src_id = new_id\n\n    for e in n.dst_edges:\n        assert e.dst_id == old_id\n        e.dst_id = new_id\n\n    return n\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.get","title":"<code>get(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Returns a cached node with the specified id. If no node is cached, it is retrieved from the database.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>NodeId</code> <p>The unique identifier of the node to fetch</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the cached or newly retrieved node</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Returns a cached node with the specified id. If no node is cached, it is retrieved from\n    the database.\n\n\n    Args:\n        id (NodeId): The unique identifier of the node to fetch\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: the cached or newly retrieved node\n    \"\"\"\n    cache = Node.get_cache()\n    n = cache.get(id)\n    if not n:\n        n = cls.load(id, db=db)\n        cache[id] = n\n\n    return cast(Self, n)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.load","title":"<code>load(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Loads a node from the database. Use <code>Node.get</code> or other methods instead.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>NodeId</code> <p>The identifier of the node to fetch</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>NodeNotFound</code> <p>The node specified by the identifier does not exist in the database</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The node from the database</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef load(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Loads a node from the database. Use `Node.get` or other methods instead.\n\n    Args:\n        id (NodeId): The identifier of the node to fetch\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        NodeNotFound: The node specified by the identifier does not exist in the database\n\n    Returns:\n        Self: The node from the database\n    \"\"\"\n\n    db = db or GraphDB.singleton()\n    res = list(\n        db.raw_fetch(\n            f\"\"\"\n            MATCH (n)-[e]-(m) WHERE id(n) = {id}\n            RETURN n, e, id(e) as e_id, id(startNode(e)) as e_start, id(endNode(e)) as e_end\n            \"\"\",\n        )\n    )\n\n    # print(\"RES\", res)\n\n    if not len(res) &gt;= 1:\n        raise NodeNotFound(f\"Couldn't find node ID: {id}\")\n\n    n = res[0][\"n\"]\n    edges = list(\n        map(lambda r: {\"id\": r[\"e_id\"], \"start\": r[\"e_start\"], \"end\": r[\"e_end\"]}, res)\n    )\n    src_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"start\"] == id, edges)))\n    dst_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"end\"] == id, edges)))\n    return cls(\n        id=id,\n        src_edges=EdgeList(src_edges),\n        dst_edges=EdgeList(dst_edges),\n        labels=n.labels,\n        data=n.properties,\n    )\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.mklabels","title":"<code>mklabels(labels)</code>  <code>staticmethod</code>","text":"<p>Converts a list of strings into proper Cypher syntax for a graph database query</p> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef mklabels(labels: set[str]) -&gt; str:\n    \"Converts a list of strings into proper Cypher syntax for a graph database query\"\n    labels_list = [i for i in labels]\n    labels_list.sort()\n    label_str = \":\".join(labels_list)\n    if len(label_str) &gt; 0:\n        label_str = \":\" + label_str\n    return label_str\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.save","title":"<code>save(n, *, db=None)</code>  <code>classmethod</code>","text":"<p>Save a node to persistent storage</p> <p>Writes the specified node to the GraphDB for persistent storage. If the node does not already exist in storage, it is created via the <code>create</code> method. If the node does exist, it is updated via the <code>update</code> method.</p> <p>If the _no_save flag is True on the node, the save request will be silently ignored.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Self</code> <p>The Node to be saved</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>As a convenience, the node that was stored is returned. This may be useful</p> <code>Self</code> <p>since the the id of the node may change if it was created in the database.</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef save(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Save a node to persistent storage\n\n    Writes the specified node to the GraphDB for persistent storage. If the node does not\n    already exist in storage, it is created via the `create` method. If the node does exist, it\n    is updated via the `update` method.\n\n    If the _no_save flag is True on the node, the save request will be silently ignored.\n\n    Args:\n        n (Self): The Node to be saved\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: As a convenience, the node that was stored is returned. This may be useful\n        since the the id of the node may change if it was created in the database.\n    \"\"\"\n    if n._new:\n        return cls.create(n, db=db)\n    else:\n        return cls.update(n, db=db)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.update","title":"<code>update(n, *, db=None)</code>  <code>classmethod</code>","text":"<p>Update an existing node in the GraphDB.</p> <p>Calling <code>save</code> is preferred to using this method so that the caller doesn't need to know the state of the node.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Self</code> <p>The node to be updated</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The node that was passed in, for convenience</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef update(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n\"\"\"Update an existing node in the GraphDB.\n\n    Calling `save` is preferred to using this method so that the caller doesn't need to know the\n    state of the node.\n\n    Args:\n        n (Self): The node to be updated\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: The node that was passed in, for convenience\n    \"\"\"\n    if n._no_save:\n        return n\n\n    db = db or GraphDB.singleton()\n\n    orig_labels = n._orig_labels\n    curr_labels = set(n.labels)\n    new_labels = curr_labels - orig_labels\n    rm_labels = orig_labels - curr_labels\n    set_label_str = Node.mklabels(new_labels)\n    if set_label_str:\n        set_query = f\"SET n{set_label_str}, n = $props\"\n    else:\n        set_query = \"SET n = $props\"\n    rm_label_str = Node.mklabels(rm_labels)\n    if rm_label_str:\n        rm_query = f\"REMOVE n{rm_label_str}\"\n    else:\n        rm_query = \"\"\n\n    params = {\"props\": n.model_dump()}\n\n    db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} {set_query} {rm_query}\", params=params)\n\n    return n\n</code></pre>"},{"location":"reference/gymnasium/","title":"gymnasium","text":""},{"location":"reference/logger/","title":"logger","text":""},{"location":"reference/perception/","title":"perception","text":""},{"location":"reference/script/","title":"script","text":""}]}