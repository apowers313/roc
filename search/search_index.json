{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Main","text":""},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>__init__</li> <li>component</li> <li>config</li> <li>event</li> <li>graphdb</li> <li>perception</li> <li>script</li> </ul>"},{"location":"reference/__init__/","title":"__init__","text":""},{"location":"reference/component/","title":"component","text":""},{"location":"reference/component/#component.Component","title":"<code>Component</code>","text":"<p>             Bases: <code>ABC</code></p> <p>An abstract component class for building pieces of ROC that will talk to each other.</p> Source code in <code>roc/component.py</code> <pre><code>class Component(ABC):\n\"\"\"An abstract component class for building pieces of ROC that will talk to each other.\"\"\"\n\n    def __init__(self, name: str, type: str):\n\"\"\"Component constructor.\n\n        Args:\n            name (str): Name of the component. Mostly used for eventing.\n            type (str): Type of the component. Will be set by the concrete class. Mostly used for \\\n                eventing.\n        \"\"\"\n        self._name = name\n        self._type = type\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"Getter for the name of the component\n\n        Returns:\n            str: the name of the component\n\n        Example:\n            &gt;&gt;&gt; c = Component(\"foo\", \"bar\")\n            &gt;&gt;&gt; print(c.name)\n            foo\n        \"\"\"\n        return self._name\n\n    @property\n    def type(self) -&gt; str:\n\"\"\"Getter for the type of the component\n\n        Returns:\n            str: the type of the component\n\n        Example:\n            &gt;&gt;&gt; c = Component(\"foo\", \"bar\")\n            &gt;&gt;&gt; print(c.type)\n            bar\n        \"\"\"\n        return self._type\n</code></pre>"},{"location":"reference/component/#component.Component.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Getter for the name of the component</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the name of the component</p> Example <p>c = Component(\"foo\", \"bar\") print(c.name) foo</p>"},{"location":"reference/component/#component.Component.type","title":"<code>type: str</code>  <code>property</code>","text":"<p>Getter for the type of the component</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the type of the component</p> Example <p>c = Component(\"foo\", \"bar\") print(c.type) bar</p>"},{"location":"reference/component/#component.Component.__init__","title":"<code>__init__(name, type)</code>","text":"<p>Component constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the component. Mostly used for eventing.</p> required <code>type</code> <code>str</code> <p>Type of the component. Will be set by the concrete class. Mostly used for                 eventing.</p> required Source code in <code>roc/component.py</code> <pre><code>def __init__(self, name: str, type: str):\n\"\"\"Component constructor.\n\n    Args:\n        name (str): Name of the component. Mostly used for eventing.\n        type (str): Type of the component. Will be set by the concrete class. Mostly used for \\\n            eventing.\n    \"\"\"\n    self._name = name\n    self._type = type\n</code></pre>"},{"location":"reference/config/","title":"config","text":""},{"location":"reference/event/","title":"event","text":""},{"location":"reference/graphdb/","title":"graphdb","text":""},{"location":"reference/graphdb/#graphdb.CacheControl","title":"<code>CacheControl</code>","text":"<p>             Bases: <code>Generic[CacheType, CacheId]</code></p> <p>For controlling the Node and Edge caches, such as clearing them, getting their current or max size, adding items to the cache (outside the automatic methods for adding cached items), etc.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class CacheControl(Generic[CacheType, CacheId]):\n\"\"\"\n    For controlling the Node and Edge caches, such as clearing them, getting their current or max\n    size, adding items to the cache (outside the automatic methods for adding cached items), etc.\n    \"\"\"\n\n    node_cache_control = NodeCacheControlAttr()\n    edge_cache_control = EdgeCacheControlAttr()\n\n    def __init__(self, cache_fn: Any):\n        self.cache: Cache[CacheId, CacheType] = cache_fn.cache\n        self.key: Callable[[Any, Any], tuple[Any]] = cache_fn.cache_key\n        self.lock: Lock | None = cache_fn.cache_lock\n        self.clear: Callable[[], None] = cache_fn.cache_clear\n        self.info: Callable[[], CacheInfo] = cache_fn.cache_info\n</code></pre>"},{"location":"reference/graphdb/#graphdb.CacheInfo","title":"<code>CacheInfo</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Information about the cache: hits, misses, max size, and current size.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class CacheInfo(NamedTuple):\n\"\"\"\n    Information about the cache: hits, misses, max size, and current size.\n    \"\"\"\n\n    hits: int\n    misses: int\n    maxsize: int | None\n    currsize: int\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge","title":"<code>Edge</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An edge (a.k.a. Relationship or Connection) between two Nodes. An edge obect automatically implements all phases of CRUD in the underlying graph database. This is a directional relationship with a \"source\" and \"destination\". The source and destination properties are dynamically loaded through property getters when they are called, and may trigger a graph database query if they don't already exist in the edge cache.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class Edge(BaseModel, extra=\"allow\"):\n\"\"\"\n    An edge (a.k.a. Relationship or Connection) between two Nodes. An edge obect automatically\n    implements all phases of CRUD in the underlying graph database. This is a directional\n    relationship with a \"source\" and \"destination\". The source and destination properties\n    are dynamically loaded through property getters when they are called, and may trigger\n    a graph database query if they don't already exist in the edge cache.\n    \"\"\"\n\n    id: EdgeId = Field(exclude=True)\n    type: str = Field(literal=True, exclude=True)\n    src_id: NodeId = Field(literal=True, exclude=True)\n    dst_id: NodeId = Field(literal=True, exclude=True)\n\n    @field_validator(\"id\", mode=\"before\")\n    def default_id(cls, id: EdgeId | None) -&gt; EdgeId:\n        if isinstance(id, int):\n            return id\n\n        return get_next_new_edge_id()\n\n    @property\n    def src(self) -&gt; Node:\n        return Node.get(self.src_id)\n\n    @property\n    def dst(self) -&gt; Node:\n        return Node.get(self.dst_id)\n\n    @property\n    def new(self) -&gt; bool:\n        return self._new\n\n    def __init__(\n        self,\n        src_id: NodeId,\n        dst_id: NodeId,\n        type: str,\n        *,\n        id: EdgeId | None = None,\n        data: dict[Any, Any] | None = None,\n    ):\n        data = data or {}\n        super().__init__(\n            src_id=src_id,\n            dst_id=dst_id,\n            type=type,\n            id=id,\n            **data,\n        )\n\n        self._new = False\n        self._no_save = False\n        self._deleted = False\n\n        if self.id &lt; 0:\n            self._new = True\n            CacheControl.edge_cache_control.cache[self.id] = self\n\n    def __del__(self) -&gt; None:\n        Edge.save(self)\n\n    @classmethod\n    @cached(cache=LRUCache(settings.edge_cache_size), key=lambda cls, id: id, info=True)\n    def get(cls, id: EdgeId) -&gt; Self:\n\"\"\"Looks up an Edge based on it's ID. If the Edge is cached, the cached edge is returned;\n        otherwise the Edge is queried from the graph database based the ID provided and a new\n        Edge is returned and cached.\n\n        Args:\n            id (EdgeId): the unique identifier for the Edge\n\n        Returns:\n            Self: returns the Edge requested by the id\n        \"\"\"\n        return cls.load(id)\n\n    @classmethod\n    def load(cls, id: EdgeId) -&gt; Self:\n\"\"\"Loads an Edge from the graph database without attempting to check if the Edge\n        already exists in the cache. Typically this is only called by Edge.get()\n\n        Args:\n            id (EdgeId): the unique identifier of the Edge to fetch\n\n        Raises:\n            EdgeNotFound: if the specified ID does not exist in the cache or the database\n\n        Returns:\n            Self: returns the Edge requested by the id\n        \"\"\"\n        db = GraphDB()\n        edge_list = list(db.raw_fetch(f\"MATCH (n)-[e]-(m) WHERE id(e) = {id} RETURN e LIMIT 1\"))\n        if not len(edge_list) == 1:\n            raise EdgeNotFound(f\"Couldn't find edge ID: {id}\")\n\n        e = edge_list[0][\"e\"]\n        props = None\n        if hasattr(e, \"properties\"):\n            props = e.properties\n        return cls(\n            e.start_id,\n            e.end_id,\n            id=id,\n            data=props,\n            type=e.type,\n        )\n\n    @classmethod\n    def save(cls, e: Self) -&gt; Self:\n\"\"\"Saves the edge to the database. Calls Edge.create if the edge is new, or Edge.update if\n        edge already exists in the database.\n\n        Args:\n            e (Self): The edge to save\n\n        Returns:\n            Self: The same edge that was passed in, for convenience. The Edge may be updated with a\n            new identifier if it was newly created in the database.\n        \"\"\"\n        if e._new:\n            return cls.create(e)\n        else:\n            return cls.update(e)\n\n    @classmethod\n    def create(cls, e: Self) -&gt; Self:\n\"\"\"Creates a new edge in the database. Typically only called by Edge.save\n\n        Args:\n            e (Self): The edge to create\n\n        Raises:\n            EdgeCreateFailed: Failed to write the edge to the database, for eample\n                if the ID is wrong.\n\n        Returns:\n            Self: the edge that was created, with an updated identifier and other chagned attributes\n        \"\"\"\n        if e._no_save:\n            return e\n\n        db = GraphDB()\n        old_id = e.id\n\n        if e.src._new:\n            Node.save(e.src)\n\n        if e.dst._new:\n            Node.save(e.dst)\n\n        params = {\"props\": e.model_dump()}\n\n        ret = list(\n            db.raw_fetch(\n                f\"\"\"\n                MATCH (src), (dst)\n                WHERE id(src) = {e.src_id} AND id(dst) = {e.dst_id}                 CREATE (src)-[e:{e.type} $props]-&gt;(dst)\n                RETURN id(e) as e_id\n                \"\"\",\n                params=params,\n            )\n        )\n\n        if len(ret) != 1:\n            raise EdgeCreateFailed(\"failed to create new edge\")\n\n        e.id = ret[0][\"e_id\"]\n        e._new = False\n        # update the cache; if being called during __del__ then the cache entry may not exist\n        try:\n            cache = CacheControl.edge_cache_control.cache\n            del cache[old_id]\n            cache[e.id] = e\n        except KeyError:\n            pass\n        # update references to edge id\n        e.src.src_edges.replace(old_id, e.id)\n        e.dst.dst_edges.replace(old_id, e.id)\n\n        return e\n\n    @classmethod\n    def update(cls, e: Self) -&gt; Self:\n\"\"\"Updates the edge in the database. Typically only called by Edge.save\n\n        Args:\n            e (Self): The edge to update\n\n        Returns:\n            Self: The same edge that was passed in, for convenience\n        \"\"\"\n        if e._no_save:\n            return e\n\n        db = GraphDB()\n\n        params = {\"props\": e.model_dump()}\n\n        db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} SET e = $props\", params=params)\n\n        return e\n\n    @staticmethod\n    def delete(e: Edge) -&gt; None:\n\"\"\"Deletes the specified edge from the database. If the edge has not already been persisted\n        to the database, this marks the edge as deleted and returns.\n\n        Args:\n            e (Edge): The edge to delete\n        \"\"\"\n        e._deleted = True\n        e._no_save = True\n\n        # remove e from src and dst nodes\n        e.src.src_edges.discard(e)\n        e.dst.dst_edges.discard(e)\n\n        # remove from cache\n        edge_cache = CacheControl.edge_cache_control.cache\n        if e.id in edge_cache:\n            del edge_cache[e.id]\n\n        # delete from db\n        if not e._new:\n            db = GraphDB()\n            db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} DELETE e\")\n\n    @staticmethod\n    def to_id(e: Edge | EdgeId) -&gt; EdgeId:\n        if isinstance(e, Edge):\n            return e.id\n        else:\n            return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.create","title":"<code>create(e)</code>  <code>classmethod</code>","text":"<p>Creates a new edge in the database. Typically only called by Edge.save</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Self</code> <p>The edge to create</p> required <p>Raises:</p> Type Description <code>EdgeCreateFailed</code> <p>Failed to write the edge to the database, for eample if the ID is wrong.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the edge that was created, with an updated identifier and other chagned attributes</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef create(cls, e: Self) -&gt; Self:\n\"\"\"Creates a new edge in the database. Typically only called by Edge.save\n\n    Args:\n        e (Self): The edge to create\n\n    Raises:\n        EdgeCreateFailed: Failed to write the edge to the database, for eample\n            if the ID is wrong.\n\n    Returns:\n        Self: the edge that was created, with an updated identifier and other chagned attributes\n    \"\"\"\n    if e._no_save:\n        return e\n\n    db = GraphDB()\n    old_id = e.id\n\n    if e.src._new:\n        Node.save(e.src)\n\n    if e.dst._new:\n        Node.save(e.dst)\n\n    params = {\"props\": e.model_dump()}\n\n    ret = list(\n        db.raw_fetch(\n            f\"\"\"\n            MATCH (src), (dst)\n            WHERE id(src) = {e.src_id} AND id(dst) = {e.dst_id}             CREATE (src)-[e:{e.type} $props]-&gt;(dst)\n            RETURN id(e) as e_id\n            \"\"\",\n            params=params,\n        )\n    )\n\n    if len(ret) != 1:\n        raise EdgeCreateFailed(\"failed to create new edge\")\n\n    e.id = ret[0][\"e_id\"]\n    e._new = False\n    # update the cache; if being called during __del__ then the cache entry may not exist\n    try:\n        cache = CacheControl.edge_cache_control.cache\n        del cache[old_id]\n        cache[e.id] = e\n    except KeyError:\n        pass\n    # update references to edge id\n    e.src.src_edges.replace(old_id, e.id)\n    e.dst.dst_edges.replace(old_id, e.id)\n\n    return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.delete","title":"<code>delete(e)</code>  <code>staticmethod</code>","text":"<p>Deletes the specified edge from the database. If the edge has not already been persisted to the database, this marks the edge as deleted and returns.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Edge</code> <p>The edge to delete</p> required Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef delete(e: Edge) -&gt; None:\n\"\"\"Deletes the specified edge from the database. If the edge has not already been persisted\n    to the database, this marks the edge as deleted and returns.\n\n    Args:\n        e (Edge): The edge to delete\n    \"\"\"\n    e._deleted = True\n    e._no_save = True\n\n    # remove e from src and dst nodes\n    e.src.src_edges.discard(e)\n    e.dst.dst_edges.discard(e)\n\n    # remove from cache\n    edge_cache = CacheControl.edge_cache_control.cache\n    if e.id in edge_cache:\n        del edge_cache[e.id]\n\n    # delete from db\n    if not e._new:\n        db = GraphDB()\n        db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} DELETE e\")\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.get","title":"<code>get(id)</code>  <code>classmethod</code>","text":"<p>Looks up an Edge based on it's ID. If the Edge is cached, the cached edge is returned; otherwise the Edge is queried from the graph database based the ID provided and a new Edge is returned and cached.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>EdgeId</code> <p>the unique identifier for the Edge</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>returns the Edge requested by the id</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\n@cached(cache=LRUCache(settings.edge_cache_size), key=lambda cls, id: id, info=True)\ndef get(cls, id: EdgeId) -&gt; Self:\n\"\"\"Looks up an Edge based on it's ID. If the Edge is cached, the cached edge is returned;\n    otherwise the Edge is queried from the graph database based the ID provided and a new\n    Edge is returned and cached.\n\n    Args:\n        id (EdgeId): the unique identifier for the Edge\n\n    Returns:\n        Self: returns the Edge requested by the id\n    \"\"\"\n    return cls.load(id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.load","title":"<code>load(id)</code>  <code>classmethod</code>","text":"<p>Loads an Edge from the graph database without attempting to check if the Edge already exists in the cache. Typically this is only called by Edge.get()</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>EdgeId</code> <p>the unique identifier of the Edge to fetch</p> required <p>Raises:</p> Type Description <code>EdgeNotFound</code> <p>if the specified ID does not exist in the cache or the database</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>returns the Edge requested by the id</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef load(cls, id: EdgeId) -&gt; Self:\n\"\"\"Loads an Edge from the graph database without attempting to check if the Edge\n    already exists in the cache. Typically this is only called by Edge.get()\n\n    Args:\n        id (EdgeId): the unique identifier of the Edge to fetch\n\n    Raises:\n        EdgeNotFound: if the specified ID does not exist in the cache or the database\n\n    Returns:\n        Self: returns the Edge requested by the id\n    \"\"\"\n    db = GraphDB()\n    edge_list = list(db.raw_fetch(f\"MATCH (n)-[e]-(m) WHERE id(e) = {id} RETURN e LIMIT 1\"))\n    if not len(edge_list) == 1:\n        raise EdgeNotFound(f\"Couldn't find edge ID: {id}\")\n\n    e = edge_list[0][\"e\"]\n    props = None\n    if hasattr(e, \"properties\"):\n        props = e.properties\n    return cls(\n        e.start_id,\n        e.end_id,\n        id=id,\n        data=props,\n        type=e.type,\n    )\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.save","title":"<code>save(e)</code>  <code>classmethod</code>","text":"<p>Saves the edge to the database. Calls Edge.create if the edge is new, or Edge.update if edge already exists in the database.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Self</code> <p>The edge to save</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The same edge that was passed in, for convenience. The Edge may be updated with a</p> <code>Self</code> <p>new identifier if it was newly created in the database.</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef save(cls, e: Self) -&gt; Self:\n\"\"\"Saves the edge to the database. Calls Edge.create if the edge is new, or Edge.update if\n    edge already exists in the database.\n\n    Args:\n        e (Self): The edge to save\n\n    Returns:\n        Self: The same edge that was passed in, for convenience. The Edge may be updated with a\n        new identifier if it was newly created in the database.\n    \"\"\"\n    if e._new:\n        return cls.create(e)\n    else:\n        return cls.update(e)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.update","title":"<code>update(e)</code>  <code>classmethod</code>","text":"<p>Updates the edge in the database. Typically only called by Edge.save</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Self</code> <p>The edge to update</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The same edge that was passed in, for convenience</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef update(cls, e: Self) -&gt; Self:\n\"\"\"Updates the edge in the database. Typically only called by Edge.save\n\n    Args:\n        e (Self): The edge to update\n\n    Returns:\n        Self: The same edge that was passed in, for convenience\n    \"\"\"\n    if e._no_save:\n        return e\n\n    db = GraphDB()\n\n    params = {\"props\": e.model_dump()}\n\n    db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} SET e = $props\", params=params)\n\n    return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator","title":"<code>EdgeFetchIterator</code>","text":"<p>The implementation of an iterator for an EdgeList. Only intended to be used internally by EdgeList.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeFetchIterator:\n\"\"\"\n    The implementation of an iterator for an EdgeList. Only intended to be used internally by\n    EdgeList.\n    \"\"\"\n\n    def __init__(self, edge_list: list[EdgeId]):\n        self.__edge_list = edge_list\n        self.cur = 0\n\n    def __iter__(self) -&gt; EdgeFetchIterator:\n        return self\n\n    def __next__(self) -&gt; Edge:\n        if self.cur &gt;= len(self.__edge_list):\n            raise StopIteration\n\n        id = self.__edge_list[self.cur]\n        self.cur = self.cur + 1\n        return Edge.get(id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList","title":"<code>EdgeList</code>","text":"<p>             Bases: <code>MutableSet[Edge | EdgeId]</code>, <code>Mapping[int, Edge]</code></p> <p>A list of Edges that is used by Node for keeping track of the connections it has. Implements interfaces for both a MutableSet (i.e. set()) and a Mapping (i.e. read-only list())</p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeList(MutableSet[Edge | EdgeId], Mapping[int, Edge]):\n\"\"\"\n    A list of Edges that is used by Node for keeping track of the connections it has.\n    Implements interfaces for both a MutableSet (i.e. set()) and a Mapping (i.e. read-only list())\n    \"\"\"\n\n    def __init__(self, ids: list[EdgeId] | set[EdgeId]):\n        self.__edges: list[EdgeId] = list(ids)\n\n    def __iter__(self) -&gt; EdgeFetchIterator:\n        return EdgeFetchIterator(self.__edges)\n\n    def __getitem__(self, key: int) -&gt; Edge:\n        return Edge.get(self.__edges[key])\n\n    def __len__(self) -&gt; int:\n        return len(self.__edges)\n\n    def __contains__(self, e: Any) -&gt; bool:\n        if isinstance(e, Edge) or isinstance(e, int):\n            e_id = Edge.to_id(e)  # type: ignore\n        else:\n            return False\n\n        return e_id in self.__edges\n\n    def add(self, e: Edge | EdgeId) -&gt; None:\n        e_id = Edge.to_id(e)\n\n        if e_id in self.__edges:\n            return\n\n        self.__edges.append(e_id)\n\n    def discard(self, e: Edge | EdgeId) -&gt; None:\n        e_id = Edge.to_id(e)\n\n        self.__edges.remove(e_id)\n\n    def replace(self, old: Edge | EdgeId, new: Edge | EdgeId) -&gt; None:\n        old_id = Edge.to_id(old)\n        new_id = Edge.to_id(new)\n        for i in range(len(self.__edges)):\n            if self.__edges[i] == old_id:\n                self.__edges[i] = new_id\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB","title":"<code>GraphDB</code>","text":"<p>A graph database singleton. Settings for the graph database come from the config module.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class GraphDB:\n\"\"\"\n    A graph database singleton. Settings for the graph database come from the config module.\n    \"\"\"\n\n    def __new__(cls) -&gt; GraphDB:\n        if not hasattr(cls, \"instance\"):\n            cls.instance = super().__new__(cls)\n            cls.instance.__isinitialized = False  # type: ignore\n        return cls.instance\n\n    def __init__(self) -&gt; None:\n        if self.__isinitialized:  # type: ignore\n            return\n\n        self.__isinitialized = True\n        self.host = settings.db_host\n        self.port = settings.db_port\n        self.encrypted = settings.db_conn_encrypted\n        self.username = settings.db_username or \"\"\n        self.password = settings.db_password or \"\"\n        self.lazy = settings.db_lazy\n        self.client_name = \"roc-graphdb-client\"\n        self.db_conn = self.connect()\n        # self.record_callback: RecordFn | None = None\n\n    def raw_fetch(\n        self, query: str, *, params: dict[str, Any] | None = None\n    ) -&gt; Iterator[dict[str, Any]]:\n        params = params or {}\n        print(f\"raw_fetch: '{query}' *** with params: *** '{params}\")\n\n        cursor = self.db_conn.cursor()\n        cursor.execute(query, params)\n        while True:\n            row = cursor.fetchone()\n            if row is None:\n                break\n            yield {\n                dsc.name: _convert_memgraph_value(row[index])\n                for index, dsc in enumerate(cursor.description)\n            }\n\n    def raw_execute(self, query: str, *, params: dict[str, Any] | None = None) -&gt; None:\n        params = params or {}\n        print(f\"raw_execute: '{query}' *** with params: *** '{params}'\")\n        cursor = self.db_conn.cursor()\n        cursor.execute(query, params)\n        cursor.fetchall()\n\n    def connected(self) -&gt; bool:\n        return self.db_conn is not None and self.db_conn.status == mgclient.CONN_STATUS_READY\n\n    def connect(self) -&gt; mgclient.Connection:\n        sslmode = mgclient.MG_SSLMODE_REQUIRE if self.encrypted else mgclient.MG_SSLMODE_DISABLE\n        connection = mgclient.connect(\n            host=self.host,\n            port=self.port,\n            username=self.username,\n            password=self.password,\n            sslmode=sslmode,\n            lazy=self.lazy,\n            client_name=self.client_name,\n        )\n        connection.autocommit = True\n        return connection\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node","title":"<code>Node</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An graph database node that automatically handles CRUD for the underlying graph database objects</p> Source code in <code>roc/graphdb.py</code> <pre><code>class Node(BaseModel, extra=\"allow\"):\n\"\"\"\n    An graph database node that automatically handles CRUD for the underlying graph database objects\n    \"\"\"\n\n    id: NodeId = Field(exclude=True)\n    labels: set[str] = Field(exclude=True)\n\n    @field_validator(\"id\", mode=\"before\")\n    def default_id(cls, id: NodeId | None) -&gt; NodeId:\n        if isinstance(id, int):\n            return id\n\n        return get_next_new_node_id()\n\n    @field_validator(\"labels\", mode=\"before\")\n    def default_labels(cls, labels: list[str] | set[str] | None) -&gt; set[str]:\n        if not labels:\n            return set()\n\n        if isinstance(labels, list):\n            return set(labels)\n\n        return labels\n\n    @property\n    def src_edges(self) -&gt; EdgeList:\n        return self._src_edges\n\n    @property\n    def dst_edges(self) -&gt; EdgeList:\n        return self._dst_edges\n\n    @property\n    def new(self) -&gt; bool:\n        return self._new\n\n    def __init__(\n        self,\n        *,\n        id: NodeId | None = None,\n        data: dict[Any, Any] | None = None,\n        labels: set[str] | list[str] | None = None,\n        src_edges: EdgeList | None = None,\n        dst_edges: EdgeList | None = None,\n    ):\n        data = data or {}\n\n        super().__init__(\n            id=id,\n            labels=labels,\n            **data,\n        )\n\n        self._new = False\n        self._no_save = False\n        self._deleted = False\n\n        if self.id &lt; 0:\n            self._new = True  # TODO: derived?\n            CacheControl.node_cache_control.cache[self.id] = self\n\n        self._orig_labels = self.labels.copy()\n        self._src_edges = src_edges or EdgeList([])\n        self._dst_edges = dst_edges or EdgeList([])\n        # TODO: ignore fields on save\n        # self._ignored_fields = [\"new\", \"no_save\", \"deleted\"]\n\n    def __del__(self) -&gt; None:\n        try:\n            self.__class__.save(self)\n        except Exception as e:\n            print(\"error saving during del:\", e)\n\n    @classmethod\n    def load(cls, id: NodeId) -&gt; Self:\n\"\"\"Loads a node from the database. Use `Node.get` or other methods instead.\n\n        Args:\n            id (NodeId): The identifier of the node to fetch\n\n        Raises:\n            NodeNotFound: The node specified by the identifier does not exist in the database\n\n        Returns:\n            Self: The node from the database\n        \"\"\"\n\n        db = GraphDB()\n        res = list(\n            db.raw_fetch(\n                f\"\"\"\n                MATCH (n)-[e]-(m) WHERE id(n) = {id}\n                RETURN n, e, id(e) as e_id, id(startNode(e)) as e_start, id(endNode(e)) as e_end\n                \"\"\",\n            )\n        )\n\n        # print(\"RES\", res)\n\n        if not len(res) &gt;= 1:\n            raise NodeNotFound(f\"Couldn't find node ID: {id}\")\n\n        n = res[0][\"n\"]\n        edges = list(\n            map(lambda r: {\"id\": r[\"e_id\"], \"start\": r[\"e_start\"], \"end\": r[\"e_end\"]}, res)\n        )\n        src_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"start\"] == id, edges)))\n        dst_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"end\"] == id, edges)))\n        return cls(\n            id=id,\n            src_edges=EdgeList(src_edges),\n            dst_edges=EdgeList(dst_edges),\n            labels=n.labels,\n            data=n.properties,\n        )\n\n    @classmethod\n    @cached(cache=LRUCache(settings.node_cache_size), key=lambda cls, id: id, info=True)\n    def get(cls, id: NodeId) -&gt; Self:\n\"\"\"Returns a cached node with the specified id. If no node is cached, it is retrieved from\n        the database.\n\n\n        Args:\n            id (NodeId): The unique identifier of the node to fetch\n\n        Returns:\n            Self: the cached or newly retrieved node\n        \"\"\"\n        return cls.load(id)\n\n    @classmethod\n    def save(cls, n: Self) -&gt; Self:\n\"\"\"Save a node to persistent storage\n\n        Writes the specified node to the GraphDB for persistent storage. If the node does not\n        already exist in storage, it is created via the `create` method. If the node does exist, it\n        is updated via the `update` method.\n\n        If the _no_save flag is True on the node, the save request will be silently ignored.\n\n        Args:\n            n (Self): The Node to be saved\n\n        Returns:\n            Self: As a convenience, the node that was stored is returned. This may be useful\n            since the the id of the node may change if it was created in the database.\n        \"\"\"\n        if n._new:\n            return cls.create(n)\n        else:\n            return cls.update(n)\n\n    @classmethod\n    def update(cls, n: Self) -&gt; Self:\n\"\"\"Update an existing node in the GraphDB.\n\n        Calling `save` is preferred to using this method so that the caller doesn't need to know the\n        state of the node.\n\n        Args:\n            n (Self): The node to be updated\n\n        Returns:\n            Self: The node that was passed in, for convenience\n        \"\"\"\n        if n._no_save:\n            return n\n\n        db = GraphDB()\n\n        orig_labels = n._orig_labels\n        curr_labels = set(n.labels)\n        new_labels = curr_labels - orig_labels\n        rm_labels = orig_labels - curr_labels\n        set_label_str = Node.mklabels(new_labels)\n        if set_label_str:\n            set_query = f\"SET n{set_label_str}, n = $props\"\n        else:\n            set_query = \"SET n = $props\"\n        rm_label_str = Node.mklabels(rm_labels)\n        if rm_label_str:\n            rm_query = f\"REMOVE n{rm_label_str}\"\n        else:\n            rm_query = \"\"\n\n        params = {\"props\": n.model_dump()}\n\n        db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} {set_query} {rm_query}\", params=params)\n\n        return n\n\n    @classmethod\n    def create(cls, n: Self) -&gt; Self:\n\"\"\"Creates the specified node in the GraphDB.\n\n        Calling `save` is preferred to using this method so that the caller doesn't need to know the\n        state of the node.\n\n        Args:\n            n (Self): the node to be created\n\n        Raises:\n            NodeCreationFailed: if creating the node failed in the database\n\n        Returns:\n            Self: the node that was passed in, albeit with a new `id` and potenitally other new\n            fields\n        \"\"\"\n        if n._no_save:\n            return n\n\n        db = GraphDB()\n        old_id = n.id\n\n        label_str = Node.mklabels(n.labels)\n        params = {\"props\": n.model_dump()}\n\n        res = list(db.raw_fetch(f\"CREATE (n{label_str} $props) RETURN id(n) as id\", params=params))\n\n        if not len(res) &gt;= 1:\n            raise NodeCreationFailed(f\"Couldn't find node ID: {id}\")\n\n        new_id = res[0][\"id\"]\n        n.id = new_id\n        n._new = False\n        # update the cache; if being called during __del__ then the cache entry may not exist\n        try:\n            cache = CacheControl.node_cache_control.cache\n            del cache[old_id]\n            cache[new_id] = n\n        except KeyError:\n            pass\n\n        for e in n.src_edges:\n            assert e.src_id == old_id\n            e.src_id = new_id\n\n        for e in n.dst_edges:\n            assert e.dst_id == old_id\n            e.dst_id = new_id\n\n        return n\n\n    @classmethod\n    def connect(cls, src: NodeId | Self, dst: NodeId | Self, type: str) -&gt; Edge:\n\"\"\"Connects two nodes (creates an Edge between two nodes)\n\n        Args:\n            src (NodeId | Node): _description_\n            dst (NodeId | Node): _description_\n            type (str): _description_\n\n        Returns:\n            Edge: _description_\n        \"\"\"\n        if isinstance(src, Node):\n            src_id = src.id\n        else:\n            src_id = src\n\n        if isinstance(dst, Node):\n            dst_id = dst.id\n        else:\n            dst_id = dst\n\n        e = Edge(src_id, dst_id, type)\n        src_node = cls.get(src_id)\n        dst_node = cls.get(dst_id)\n        src_node.src_edges.add(e)\n        dst_node.dst_edges.add(e)\n        return e\n\n    @staticmethod\n    def delete(n: Node) -&gt; None:\n        # remove edges\n        for e in n.src_edges:\n            Edge.delete(e)\n\n        for e in n.dst_edges:\n            Edge.delete(e)\n\n        # remove from cache\n        node_cache = CacheControl.node_cache_control.cache\n        if n.id in node_cache:\n            del node_cache[n.id]\n\n        if not n._new:\n            db = GraphDB()\n            db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} DELETE n\")\n\n        n._deleted = True\n        n._no_save = True\n\n    @staticmethod\n    def mklabels(labels: set[str]) -&gt; str:\n        \"Converts a list of strings into proper Cypher syntax for a graph database query\"\n        labels_list = [i for i in labels]\n        labels_list.sort()\n        label_str = \":\".join(labels_list)\n        if len(label_str) &gt; 0:\n            label_str = \":\" + label_str\n        return label_str\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.connect","title":"<code>connect(src, dst, type)</code>  <code>classmethod</code>","text":"<p>Connects two nodes (creates an Edge between two nodes)</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>NodeId | Node</code> <p>description</p> required <code>dst</code> <code>NodeId | Node</code> <p>description</p> required <code>type</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Edge</code> <code>Edge</code> <p>description</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef connect(cls, src: NodeId | Self, dst: NodeId | Self, type: str) -&gt; Edge:\n\"\"\"Connects two nodes (creates an Edge between two nodes)\n\n    Args:\n        src (NodeId | Node): _description_\n        dst (NodeId | Node): _description_\n        type (str): _description_\n\n    Returns:\n        Edge: _description_\n    \"\"\"\n    if isinstance(src, Node):\n        src_id = src.id\n    else:\n        src_id = src\n\n    if isinstance(dst, Node):\n        dst_id = dst.id\n    else:\n        dst_id = dst\n\n    e = Edge(src_id, dst_id, type)\n    src_node = cls.get(src_id)\n    dst_node = cls.get(dst_id)\n    src_node.src_edges.add(e)\n    dst_node.dst_edges.add(e)\n    return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.create","title":"<code>create(n)</code>  <code>classmethod</code>","text":"<p>Creates the specified node in the GraphDB.</p> <p>Calling <code>save</code> is preferred to using this method so that the caller doesn't need to know the state of the node.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Self</code> <p>the node to be created</p> required <p>Raises:</p> Type Description <code>NodeCreationFailed</code> <p>if creating the node failed in the database</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the node that was passed in, albeit with a new <code>id</code> and potenitally other new</p> <code>Self</code> <p>fields</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef create(cls, n: Self) -&gt; Self:\n\"\"\"Creates the specified node in the GraphDB.\n\n    Calling `save` is preferred to using this method so that the caller doesn't need to know the\n    state of the node.\n\n    Args:\n        n (Self): the node to be created\n\n    Raises:\n        NodeCreationFailed: if creating the node failed in the database\n\n    Returns:\n        Self: the node that was passed in, albeit with a new `id` and potenitally other new\n        fields\n    \"\"\"\n    if n._no_save:\n        return n\n\n    db = GraphDB()\n    old_id = n.id\n\n    label_str = Node.mklabels(n.labels)\n    params = {\"props\": n.model_dump()}\n\n    res = list(db.raw_fetch(f\"CREATE (n{label_str} $props) RETURN id(n) as id\", params=params))\n\n    if not len(res) &gt;= 1:\n        raise NodeCreationFailed(f\"Couldn't find node ID: {id}\")\n\n    new_id = res[0][\"id\"]\n    n.id = new_id\n    n._new = False\n    # update the cache; if being called during __del__ then the cache entry may not exist\n    try:\n        cache = CacheControl.node_cache_control.cache\n        del cache[old_id]\n        cache[new_id] = n\n    except KeyError:\n        pass\n\n    for e in n.src_edges:\n        assert e.src_id == old_id\n        e.src_id = new_id\n\n    for e in n.dst_edges:\n        assert e.dst_id == old_id\n        e.dst_id = new_id\n\n    return n\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.get","title":"<code>get(id)</code>  <code>classmethod</code>","text":"<p>Returns a cached node with the specified id. If no node is cached, it is retrieved from the database.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>NodeId</code> <p>The unique identifier of the node to fetch</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the cached or newly retrieved node</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\n@cached(cache=LRUCache(settings.node_cache_size), key=lambda cls, id: id, info=True)\ndef get(cls, id: NodeId) -&gt; Self:\n\"\"\"Returns a cached node with the specified id. If no node is cached, it is retrieved from\n    the database.\n\n\n    Args:\n        id (NodeId): The unique identifier of the node to fetch\n\n    Returns:\n        Self: the cached or newly retrieved node\n    \"\"\"\n    return cls.load(id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.load","title":"<code>load(id)</code>  <code>classmethod</code>","text":"<p>Loads a node from the database. Use <code>Node.get</code> or other methods instead.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>NodeId</code> <p>The identifier of the node to fetch</p> required <p>Raises:</p> Type Description <code>NodeNotFound</code> <p>The node specified by the identifier does not exist in the database</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The node from the database</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef load(cls, id: NodeId) -&gt; Self:\n\"\"\"Loads a node from the database. Use `Node.get` or other methods instead.\n\n    Args:\n        id (NodeId): The identifier of the node to fetch\n\n    Raises:\n        NodeNotFound: The node specified by the identifier does not exist in the database\n\n    Returns:\n        Self: The node from the database\n    \"\"\"\n\n    db = GraphDB()\n    res = list(\n        db.raw_fetch(\n            f\"\"\"\n            MATCH (n)-[e]-(m) WHERE id(n) = {id}\n            RETURN n, e, id(e) as e_id, id(startNode(e)) as e_start, id(endNode(e)) as e_end\n            \"\"\",\n        )\n    )\n\n    # print(\"RES\", res)\n\n    if not len(res) &gt;= 1:\n        raise NodeNotFound(f\"Couldn't find node ID: {id}\")\n\n    n = res[0][\"n\"]\n    edges = list(\n        map(lambda r: {\"id\": r[\"e_id\"], \"start\": r[\"e_start\"], \"end\": r[\"e_end\"]}, res)\n    )\n    src_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"start\"] == id, edges)))\n    dst_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"end\"] == id, edges)))\n    return cls(\n        id=id,\n        src_edges=EdgeList(src_edges),\n        dst_edges=EdgeList(dst_edges),\n        labels=n.labels,\n        data=n.properties,\n    )\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.mklabels","title":"<code>mklabels(labels)</code>  <code>staticmethod</code>","text":"<p>Converts a list of strings into proper Cypher syntax for a graph database query</p> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef mklabels(labels: set[str]) -&gt; str:\n    \"Converts a list of strings into proper Cypher syntax for a graph database query\"\n    labels_list = [i for i in labels]\n    labels_list.sort()\n    label_str = \":\".join(labels_list)\n    if len(label_str) &gt; 0:\n        label_str = \":\" + label_str\n    return label_str\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.save","title":"<code>save(n)</code>  <code>classmethod</code>","text":"<p>Save a node to persistent storage</p> <p>Writes the specified node to the GraphDB for persistent storage. If the node does not already exist in storage, it is created via the <code>create</code> method. If the node does exist, it is updated via the <code>update</code> method.</p> <p>If the _no_save flag is True on the node, the save request will be silently ignored.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Self</code> <p>The Node to be saved</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>As a convenience, the node that was stored is returned. This may be useful</p> <code>Self</code> <p>since the the id of the node may change if it was created in the database.</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef save(cls, n: Self) -&gt; Self:\n\"\"\"Save a node to persistent storage\n\n    Writes the specified node to the GraphDB for persistent storage. If the node does not\n    already exist in storage, it is created via the `create` method. If the node does exist, it\n    is updated via the `update` method.\n\n    If the _no_save flag is True on the node, the save request will be silently ignored.\n\n    Args:\n        n (Self): The Node to be saved\n\n    Returns:\n        Self: As a convenience, the node that was stored is returned. This may be useful\n        since the the id of the node may change if it was created in the database.\n    \"\"\"\n    if n._new:\n        return cls.create(n)\n    else:\n        return cls.update(n)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.update","title":"<code>update(n)</code>  <code>classmethod</code>","text":"<p>Update an existing node in the GraphDB.</p> <p>Calling <code>save</code> is preferred to using this method so that the caller doesn't need to know the state of the node.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Self</code> <p>The node to be updated</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The node that was passed in, for convenience</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef update(cls, n: Self) -&gt; Self:\n\"\"\"Update an existing node in the GraphDB.\n\n    Calling `save` is preferred to using this method so that the caller doesn't need to know the\n    state of the node.\n\n    Args:\n        n (Self): The node to be updated\n\n    Returns:\n        Self: The node that was passed in, for convenience\n    \"\"\"\n    if n._no_save:\n        return n\n\n    db = GraphDB()\n\n    orig_labels = n._orig_labels\n    curr_labels = set(n.labels)\n    new_labels = curr_labels - orig_labels\n    rm_labels = orig_labels - curr_labels\n    set_label_str = Node.mklabels(new_labels)\n    if set_label_str:\n        set_query = f\"SET n{set_label_str}, n = $props\"\n    else:\n        set_query = \"SET n = $props\"\n    rm_label_str = Node.mklabels(rm_labels)\n    if rm_label_str:\n        rm_query = f\"REMOVE n{rm_label_str}\"\n    else:\n        rm_query = \"\"\n\n    params = {\"props\": n.model_dump()}\n\n    db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} {set_query} {rm_query}\", params=params)\n\n    return n\n</code></pre>"},{"location":"reference/perception/","title":"perception","text":""},{"location":"reference/script/","title":"script","text":""}]}