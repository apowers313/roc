{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Main","text":"<p>Reinforcement Learning of Concepts</p>"},{"location":"#roc.ActionData","title":"<code>ActionData = ActionRequest | TakeAction</code>  <code>module-attribute</code>","text":""},{"location":"#roc.PerceptionData","title":"<code>PerceptionData = VisionData | Settled | Feature[Any]</code>  <code>module-attribute</code>","text":""},{"location":"#roc.__all__","title":"<code>__all__ = ['Component', 'GymComponent', 'Perception', 'PerceptionData', 'ActionData', 'Action', 'ExpMod']</code>  <code>module-attribute</code>","text":""},{"location":"#roc.ng","title":"<code>ng: NethackGym | None = None</code>  <code>module-attribute</code>","text":""},{"location":"#roc.Action","title":"<code>Action</code>","text":"<p>               Bases: <code>Component</code></p> <p>Component for determining which action to take.</p> Source code in <code>roc/action.py</code> <pre><code>@register_component(\"action\", \"action\", auto=True)\nclass Action(Component):\n    \"\"\"Component for determining which action to take.\"\"\"\n\n    bus = EventBus[ActionData](\"action\", cache_depth=10)\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.action_bus_conn = self.connect_bus(self.bus)\n        self.action_bus_conn.listen(self.action_request)\n\n    def event_filter(self, e: ActionEvent) -&gt; bool:\n        return isinstance(e.data, ActionRequest)\n\n    def action_request(self, e: ActionEvent) -&gt; None:\n        action = DefaultActionExpMod.get(default=\"pass\").get_action()\n        actevt = TakeAction(action)\n        self.action_bus_conn.send(actevt)\n</code></pre>"},{"location":"#roc.Action.action_bus_conn","title":"<code>action_bus_conn = self.connect_bus(self.bus)</code>  <code>instance-attribute</code>","text":""},{"location":"#roc.Action.bus","title":"<code>bus = EventBus[ActionData]('action', cache_depth=10)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#roc.Action.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/action.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.action_bus_conn = self.connect_bus(self.bus)\n    self.action_bus_conn.listen(self.action_request)\n</code></pre>"},{"location":"#roc.Action.action_request","title":"<code>action_request(e)</code>","text":"Source code in <code>roc/action.py</code> <pre><code>def action_request(self, e: ActionEvent) -&gt; None:\n    action = DefaultActionExpMod.get(default=\"pass\").get_action()\n    actevt = TakeAction(action)\n    self.action_bus_conn.send(actevt)\n</code></pre>"},{"location":"#roc.Action.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/action.py</code> <pre><code>def event_filter(self, e: ActionEvent) -&gt; bool:\n    return isinstance(e.data, ActionRequest)\n</code></pre>"},{"location":"#roc.Component","title":"<code>Component</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract component class for building pieces of ROC that will talk to each other.</p> Source code in <code>roc/component.py</code> <pre><code>class Component(ABC):\n    \"\"\"An abstract component class for building pieces of ROC that will talk to each other.\"\"\"\n\n    name: str = \"&lt;name unassigned&gt;\"\n    type: str = \"&lt;type unassigned&gt;\"\n\n    def __init__(self) -&gt; None:\n        global component_set\n        component_set.add(self)\n        self.bus_conns: dict[str, BusConnection[Any]] = {}\n        logger.trace(f\"++ incrementing component count: {self.name}:{self.type} {self}\")\n        # traceback.print_stack()\n\n    def __del__(self) -&gt; None:\n        global component_set\n        component_set.add(self)\n        logger.trace(f\"-- decrementing component count: {self.name}:{self.type} {self}\")\n\n    def connect_bus(self, bus: EventBus[T]) -&gt; BusConnection[T]:\n        \"\"\"Create a new bus connection for the component, storing the result for\n        later shutdown.\n\n        Args:\n            bus (EventBus[T]): The event bus to attach to\n\n        Raises:\n            ValueError: if the bus has already been connected to by this component\n\n        Returns:\n            BusConnection[T]: The bus connection for listening or sending events\n        \"\"\"\n        if bus.name in self.bus_conns:\n            raise ValueError(\n                f\"Component '{self.name}' attempting duplicate connection to bus '{bus.name}'\"\n            )\n\n        conn = bus.connect(self)\n        self.bus_conns[bus.name] = conn\n        return conn\n\n    def event_filter(self, e: Event[Any]) -&gt; bool:\n        \"\"\"A filter for any incoming events. By default it filters out events\n        sent by itself, but it is especially useful for creating new filters in\n        sub-classes.\n\n        Args:\n            e (Event[Any]): The event to be evaluated\n\n        Returns:\n            bool: True if the event should be sent, False if it should be dropped\n        \"\"\"\n        return e.src_id != self.id\n\n    def shutdown(self) -&gt; None:\n        \"\"\"De-initializes the component, removing any bus connections and any\n        other clean-up that needs to be performed\n        \"\"\"\n        logger.debug(f\"Component {self.name}:{self.type} shutting down.\")\n\n        for conn in self.bus_conns:\n            for obs in self.bus_conns[conn].attached_bus.subject.observers:\n                obs.on_completed()\n            self.bus_conns[conn].close()\n\n    @property\n    def id(self) -&gt; ComponentId:\n        return ComponentId(self.type, self.name)\n\n    @staticmethod\n    def init() -&gt; None:\n        \"\"\"Loads all components registered as `auto` and perception components\n        in the `perception_components` config field.\n        \"\"\"\n        settings = Config.get()\n        component_list = default_components\n        logger.debug(\"perception components from settings\", settings.perception_components)\n        component_list = component_list.union(settings.perception_components, default_components)\n        logger.debug(f\"Component.init: default components: {component_list}\")\n\n        # TODO: shutdown previously loaded components\n\n        for reg_str in component_list:\n            logger.trace(f\"Loading component: {reg_str} ...\")\n            (name, type) = reg_str.split(\":\")\n            loaded_components[reg_str] = Component.get(name, type)\n\n    @classmethod\n    def get(cls, name: str, type: str, *args: Any, **kwargs: Any) -&gt; Self:\n        \"\"\"Retreives a component with the specified name from the registry and\n        creates a new version of it with the specified args. Used by\n        `Config.init` and for testing.\n\n        Args:\n            name (str): The name of the component to get, as specified during\n                its registration\n            type (str): The type of the component to get, as specified during\n                its registration\n            args (Any): Fixed position arguments to pass to the Component\n                constructor\n            kwargs (Any): Keyword args to pass to the Component constructor\n\n        Returns:\n            Self: the component that was created, casted as the calling class.\n            (e.g. `Perception.get(...)` will return a Perception component and\n            `Action.get(...)` will return an Action component)\n        \"\"\"\n        reg_str = _component_registry_key(name, type)\n        return cast(Self, component_registry[reg_str](*args, **kwargs))\n\n    @staticmethod\n    def get_component_count() -&gt; int:\n        \"\"\"Returns the number of currently created Components. The number goes\n        up on __init__ and down on __del__. Primarily used for testing to ensure\n        Components are being shutdown appropriately.\n\n        Returns:\n            int: The number of currently active Component instances\n        \"\"\"\n        # global component_count\n        # return component_count\n        global component_set\n        return len(component_set)\n\n    @staticmethod\n    def get_loaded_components() -&gt; list[str]:\n        \"\"\"Returns the names and types of all initiated components.\n\n        Returns:\n            list[str]: A list of the names and types of components, as strings.\n        \"\"\"\n        global loaded_components\n        return [s for s in loaded_components.keys()]\n\n    @staticmethod\n    def deregister(name: str, type: str) -&gt; None:\n        \"\"\"Removes a component from the Component registry. Primarlly used for testing.\n\n        Args:\n            name (str): The name of the Component to deregister\n            type (str): The type of the Component to deregister\n        \"\"\"\n        reg_str = _component_registry_key(name, type)\n        del component_registry[reg_str]\n\n    @staticmethod\n    def reset() -&gt; None:\n        \"\"\"Shuts down all components\"\"\"\n        # shutdown all components\n        global loaded_components\n        for name in loaded_components:\n            logger.trace(f\"Shutting down component: {name}.\")\n            c = loaded_components[name]\n            c.shutdown()\n\n        loaded_components.clear()\n\n        global component_set\n        for c in component_set:\n            c.shutdown()\n</code></pre>"},{"location":"#roc.Component.bus_conns","title":"<code>bus_conns: dict[str, BusConnection[Any]] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"#roc.Component.id","title":"<code>id: ComponentId</code>  <code>property</code>","text":""},{"location":"#roc.Component.name","title":"<code>name: str = '&lt;name unassigned&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#roc.Component.type","title":"<code>type: str = '&lt;type unassigned&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#roc.Component.__del__","title":"<code>__del__()</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __del__(self) -&gt; None:\n    global component_set\n    component_set.add(self)\n    logger.trace(f\"-- decrementing component count: {self.name}:{self.type} {self}\")\n</code></pre>"},{"location":"#roc.Component.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __init__(self) -&gt; None:\n    global component_set\n    component_set.add(self)\n    self.bus_conns: dict[str, BusConnection[Any]] = {}\n    logger.trace(f\"++ incrementing component count: {self.name}:{self.type} {self}\")\n</code></pre>"},{"location":"#roc.Component.connect_bus","title":"<code>connect_bus(bus)</code>","text":"<p>Create a new bus connection for the component, storing the result for later shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>EventBus[T]</code> <p>The event bus to attach to</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the bus has already been connected to by this component</p> <p>Returns:</p> Type Description <code>BusConnection[T]</code> <p>BusConnection[T]: The bus connection for listening or sending events</p> Source code in <code>roc/component.py</code> <pre><code>def connect_bus(self, bus: EventBus[T]) -&gt; BusConnection[T]:\n    \"\"\"Create a new bus connection for the component, storing the result for\n    later shutdown.\n\n    Args:\n        bus (EventBus[T]): The event bus to attach to\n\n    Raises:\n        ValueError: if the bus has already been connected to by this component\n\n    Returns:\n        BusConnection[T]: The bus connection for listening or sending events\n    \"\"\"\n    if bus.name in self.bus_conns:\n        raise ValueError(\n            f\"Component '{self.name}' attempting duplicate connection to bus '{bus.name}'\"\n        )\n\n    conn = bus.connect(self)\n    self.bus_conns[bus.name] = conn\n    return conn\n</code></pre>"},{"location":"#roc.Component.deregister","title":"<code>deregister(name, type)</code>  <code>staticmethod</code>","text":"<p>Removes a component from the Component registry. Primarlly used for testing.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the Component to deregister</p> required <code>type</code> <code>str</code> <p>The type of the Component to deregister</p> required Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef deregister(name: str, type: str) -&gt; None:\n    \"\"\"Removes a component from the Component registry. Primarlly used for testing.\n\n    Args:\n        name (str): The name of the Component to deregister\n        type (str): The type of the Component to deregister\n    \"\"\"\n    reg_str = _component_registry_key(name, type)\n    del component_registry[reg_str]\n</code></pre>"},{"location":"#roc.Component.event_filter","title":"<code>event_filter(e)</code>","text":"<p>A filter for any incoming events. By default it filters out events sent by itself, but it is especially useful for creating new filters in sub-classes.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Event[Any]</code> <p>The event to be evaluated</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the event should be sent, False if it should be dropped</p> Source code in <code>roc/component.py</code> <pre><code>def event_filter(self, e: Event[Any]) -&gt; bool:\n    \"\"\"A filter for any incoming events. By default it filters out events\n    sent by itself, but it is especially useful for creating new filters in\n    sub-classes.\n\n    Args:\n        e (Event[Any]): The event to be evaluated\n\n    Returns:\n        bool: True if the event should be sent, False if it should be dropped\n    \"\"\"\n    return e.src_id != self.id\n</code></pre>"},{"location":"#roc.Component.get","title":"<code>get(name, type, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Retreives a component with the specified name from the registry and creates a new version of it with the specified args. Used by <code>Config.init</code> and for testing.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the component to get, as specified during its registration</p> required <code>type</code> <code>str</code> <p>The type of the component to get, as specified during its registration</p> required <code>args</code> <code>Any</code> <p>Fixed position arguments to pass to the Component constructor</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>Keyword args to pass to the Component constructor</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the component that was created, casted as the calling class.</p> <code>Self</code> <p>(e.g. <code>Perception.get(...)</code> will return a Perception component and</p> <code>Self</code> <p><code>Action.get(...)</code> will return an Action component)</p> Source code in <code>roc/component.py</code> <pre><code>@classmethod\ndef get(cls, name: str, type: str, *args: Any, **kwargs: Any) -&gt; Self:\n    \"\"\"Retreives a component with the specified name from the registry and\n    creates a new version of it with the specified args. Used by\n    `Config.init` and for testing.\n\n    Args:\n        name (str): The name of the component to get, as specified during\n            its registration\n        type (str): The type of the component to get, as specified during\n            its registration\n        args (Any): Fixed position arguments to pass to the Component\n            constructor\n        kwargs (Any): Keyword args to pass to the Component constructor\n\n    Returns:\n        Self: the component that was created, casted as the calling class.\n        (e.g. `Perception.get(...)` will return a Perception component and\n        `Action.get(...)` will return an Action component)\n    \"\"\"\n    reg_str = _component_registry_key(name, type)\n    return cast(Self, component_registry[reg_str](*args, **kwargs))\n</code></pre>"},{"location":"#roc.Component.get_component_count","title":"<code>get_component_count()</code>  <code>staticmethod</code>","text":"<p>Returns the number of currently created Components. The number goes up on init and down on del. Primarily used for testing to ensure Components are being shutdown appropriately.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of currently active Component instances</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef get_component_count() -&gt; int:\n    \"\"\"Returns the number of currently created Components. The number goes\n    up on __init__ and down on __del__. Primarily used for testing to ensure\n    Components are being shutdown appropriately.\n\n    Returns:\n        int: The number of currently active Component instances\n    \"\"\"\n    # global component_count\n    # return component_count\n    global component_set\n    return len(component_set)\n</code></pre>"},{"location":"#roc.Component.get_loaded_components","title":"<code>get_loaded_components()</code>  <code>staticmethod</code>","text":"<p>Returns the names and types of all initiated components.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of the names and types of components, as strings.</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef get_loaded_components() -&gt; list[str]:\n    \"\"\"Returns the names and types of all initiated components.\n\n    Returns:\n        list[str]: A list of the names and types of components, as strings.\n    \"\"\"\n    global loaded_components\n    return [s for s in loaded_components.keys()]\n</code></pre>"},{"location":"#roc.Component.init","title":"<code>init()</code>  <code>staticmethod</code>","text":"<p>Loads all components registered as <code>auto</code> and perception components in the <code>perception_components</code> config field.</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef init() -&gt; None:\n    \"\"\"Loads all components registered as `auto` and perception components\n    in the `perception_components` config field.\n    \"\"\"\n    settings = Config.get()\n    component_list = default_components\n    logger.debug(\"perception components from settings\", settings.perception_components)\n    component_list = component_list.union(settings.perception_components, default_components)\n    logger.debug(f\"Component.init: default components: {component_list}\")\n\n    # TODO: shutdown previously loaded components\n\n    for reg_str in component_list:\n        logger.trace(f\"Loading component: {reg_str} ...\")\n        (name, type) = reg_str.split(\":\")\n        loaded_components[reg_str] = Component.get(name, type)\n</code></pre>"},{"location":"#roc.Component.reset","title":"<code>reset()</code>  <code>staticmethod</code>","text":"<p>Shuts down all components</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef reset() -&gt; None:\n    \"\"\"Shuts down all components\"\"\"\n    # shutdown all components\n    global loaded_components\n    for name in loaded_components:\n        logger.trace(f\"Shutting down component: {name}.\")\n        c = loaded_components[name]\n        c.shutdown()\n\n    loaded_components.clear()\n\n    global component_set\n    for c in component_set:\n        c.shutdown()\n</code></pre>"},{"location":"#roc.Component.shutdown","title":"<code>shutdown()</code>","text":"<p>De-initializes the component, removing any bus connections and any other clean-up that needs to be performed</p> Source code in <code>roc/component.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"De-initializes the component, removing any bus connections and any\n    other clean-up that needs to be performed\n    \"\"\"\n    logger.debug(f\"Component {self.name}:{self.type} shutting down.\")\n\n    for conn in self.bus_conns:\n        for obs in self.bus_conns[conn].attached_bus.subject.observers:\n            obs.on_completed()\n        self.bus_conns[conn].close()\n</code></pre>"},{"location":"#roc.ExpMod","title":"<code>ExpMod</code>","text":"Source code in <code>roc/expmod.py</code> <pre><code>class ExpMod:\n    modtype: str\n\n    def __init_subclass__(cls) -&gt; None:\n        if not hasattr(cls, \"modtype\"):\n            raise NotImplementedError(f\"{cls} must implement class attribute 'modtype'\")\n\n    @staticmethod\n    def register(name: str) -&gt; Callable[[type[ExpMod]], type[ExpMod]]:\n        def register_decorator(cls: type[ExpMod]) -&gt; type[ExpMod]:\n            if name in expmod_registry[cls.modtype]:\n                raise Exception(\n                    f\"ExpMod.register attempting to register duplicate name '{name}' for module '{cls.modtype}'\"\n                )\n            expmod_registry[cls.modtype][name] = cls()\n\n            return cls\n\n        return register_decorator\n\n    @classmethod\n    def get(cls, default: str | None = None) -&gt; Self:\n        modtype = cls.modtype\n        name: str | None = (\n            expmod_modtype_current[modtype]\n            if expmod_modtype_current[modtype] is not None\n            else default\n        )\n        if name is None:\n            raise Exception(f\"ExpMod couldn't get module for type: '{modtype}'\")\n\n        return cast(Self, expmod_registry[modtype][name])\n\n    @classmethod\n    def set(cls, name: str, modtype: str | None = None) -&gt; None:\n        if modtype is None:\n            modtype = cls.modtype\n\n        if modtype not in expmod_registry:\n            raise Exception(f\"ExpMod.set can't find module for type: '{modtype}'\")\n\n        if name not in expmod_registry[modtype]:\n            raise Exception(\n                f\"ExpMod.set can't find module for name: '{name}' in module '{modtype}'\"\n            )\n\n        expmod_modtype_current[modtype] = name\n\n    @staticmethod\n    def import_file(filename: str, basepath: str = \"\") -&gt; ModuleType:\n        module_name = f\"roc:expmod:{filename}\"\n        filepath = Path(basepath) / filename\n\n        spec = importlib.util.spec_from_file_location(module_name, filepath)\n        assert spec is not None\n        assert spec.loader is not None\n\n        module = importlib.util.module_from_spec(spec)\n        sys.modules[module_name] = module\n        spec.loader.exec_module(module)\n\n        return module\n\n    @staticmethod\n    def init() -&gt; None:\n        settings = Config.get()\n\n        mods = settings.expmods.copy()\n        basepaths = settings.expmod_dirs.copy()\n        basepaths.insert(0, \"\")\n\n        # load module files\n        missing_mods: list[str] = []\n        for base in basepaths:\n            for mod in mods:\n                file = mod if mod.endswith(\".py\") else mod + \".py\"\n                try:\n                    expmod_loaded[mod] = ExpMod.import_file(file, base)\n                except FileNotFoundError:\n                    missing_mods.append(mod)\n            mods = missing_mods.copy()\n            missing_mods.clear()\n\n        if len(mods) &gt; 0:\n            raise FileNotFoundError(f\"could not load experiment modules: {mods}\")\n\n        # set modules\n        use_mods = [m.split(\":\") for m in settings.expmods_use]\n        mod_name_count = Counter([m[0] for m in use_mods])\n        duplicate_names = {k: v for k, v in mod_name_count.items() if v &gt; 1}\n        if len(duplicate_names) &gt; 0:\n            dupes = \", \".join(duplicate_names.keys())\n            raise Exception(f\"ExpMod.init found multiple attempts to set the same modules: {dupes}\")\n\n        for mod_tn in use_mods:\n            t, n = mod_tn\n            ExpMod.set(name=n, modtype=t)\n</code></pre>"},{"location":"#roc.ExpMod.modtype","title":"<code>modtype: str</code>  <code>instance-attribute</code>","text":""},{"location":"#roc.ExpMod.__init_subclass__","title":"<code>__init_subclass__()</code>","text":"Source code in <code>roc/expmod.py</code> <pre><code>def __init_subclass__(cls) -&gt; None:\n    if not hasattr(cls, \"modtype\"):\n        raise NotImplementedError(f\"{cls} must implement class attribute 'modtype'\")\n</code></pre>"},{"location":"#roc.ExpMod.get","title":"<code>get(default=None)</code>  <code>classmethod</code>","text":"Source code in <code>roc/expmod.py</code> <pre><code>@classmethod\ndef get(cls, default: str | None = None) -&gt; Self:\n    modtype = cls.modtype\n    name: str | None = (\n        expmod_modtype_current[modtype]\n        if expmod_modtype_current[modtype] is not None\n        else default\n    )\n    if name is None:\n        raise Exception(f\"ExpMod couldn't get module for type: '{modtype}'\")\n\n    return cast(Self, expmod_registry[modtype][name])\n</code></pre>"},{"location":"#roc.ExpMod.import_file","title":"<code>import_file(filename, basepath='')</code>  <code>staticmethod</code>","text":"Source code in <code>roc/expmod.py</code> <pre><code>@staticmethod\ndef import_file(filename: str, basepath: str = \"\") -&gt; ModuleType:\n    module_name = f\"roc:expmod:{filename}\"\n    filepath = Path(basepath) / filename\n\n    spec = importlib.util.spec_from_file_location(module_name, filepath)\n    assert spec is not None\n    assert spec.loader is not None\n\n    module = importlib.util.module_from_spec(spec)\n    sys.modules[module_name] = module\n    spec.loader.exec_module(module)\n\n    return module\n</code></pre>"},{"location":"#roc.ExpMod.init","title":"<code>init()</code>  <code>staticmethod</code>","text":"Source code in <code>roc/expmod.py</code> <pre><code>@staticmethod\ndef init() -&gt; None:\n    settings = Config.get()\n\n    mods = settings.expmods.copy()\n    basepaths = settings.expmod_dirs.copy()\n    basepaths.insert(0, \"\")\n\n    # load module files\n    missing_mods: list[str] = []\n    for base in basepaths:\n        for mod in mods:\n            file = mod if mod.endswith(\".py\") else mod + \".py\"\n            try:\n                expmod_loaded[mod] = ExpMod.import_file(file, base)\n            except FileNotFoundError:\n                missing_mods.append(mod)\n        mods = missing_mods.copy()\n        missing_mods.clear()\n\n    if len(mods) &gt; 0:\n        raise FileNotFoundError(f\"could not load experiment modules: {mods}\")\n\n    # set modules\n    use_mods = [m.split(\":\") for m in settings.expmods_use]\n    mod_name_count = Counter([m[0] for m in use_mods])\n    duplicate_names = {k: v for k, v in mod_name_count.items() if v &gt; 1}\n    if len(duplicate_names) &gt; 0:\n        dupes = \", \".join(duplicate_names.keys())\n        raise Exception(f\"ExpMod.init found multiple attempts to set the same modules: {dupes}\")\n\n    for mod_tn in use_mods:\n        t, n = mod_tn\n        ExpMod.set(name=n, modtype=t)\n</code></pre>"},{"location":"#roc.ExpMod.register","title":"<code>register(name)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/expmod.py</code> <pre><code>@staticmethod\ndef register(name: str) -&gt; Callable[[type[ExpMod]], type[ExpMod]]:\n    def register_decorator(cls: type[ExpMod]) -&gt; type[ExpMod]:\n        if name in expmod_registry[cls.modtype]:\n            raise Exception(\n                f\"ExpMod.register attempting to register duplicate name '{name}' for module '{cls.modtype}'\"\n            )\n        expmod_registry[cls.modtype][name] = cls()\n\n        return cls\n\n    return register_decorator\n</code></pre>"},{"location":"#roc.ExpMod.set","title":"<code>set(name, modtype=None)</code>  <code>classmethod</code>","text":"Source code in <code>roc/expmod.py</code> <pre><code>@classmethod\ndef set(cls, name: str, modtype: str | None = None) -&gt; None:\n    if modtype is None:\n        modtype = cls.modtype\n\n    if modtype not in expmod_registry:\n        raise Exception(f\"ExpMod.set can't find module for type: '{modtype}'\")\n\n    if name not in expmod_registry[modtype]:\n        raise Exception(\n            f\"ExpMod.set can't find module for name: '{name}' in module '{modtype}'\"\n        )\n\n    expmod_modtype_current[modtype] = name\n</code></pre>"},{"location":"#roc.Perception","title":"<code>Perception</code>","text":"<p>               Bases: <code>Component</code>, <code>ABC</code></p> <p>The abstract class for Perception components. Handles perception bus connections and corresponding clean-up.</p> Source code in <code>roc/perception.py</code> <pre><code>class Perception(Component, ABC):\n    \"\"\"The abstract class for Perception components. Handles perception bus\n    connections and corresponding clean-up.\n    \"\"\"\n\n    bus = EventBus[PerceptionData](\"perception\")\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.pb_conn = self.connect_bus(Perception.bus)\n        self.pb_conn.listen(self.do_perception)\n\n    @abstractmethod\n    def do_perception(self, e: PerceptionEvent) -&gt; None: ...\n\n    @classmethod\n    def init(cls) -&gt; None:\n        global perception_bus\n        cls.bus = EventBus[PerceptionData](\"perception\")\n</code></pre>"},{"location":"#roc.Perception.bus","title":"<code>bus = EventBus[PerceptionData]('perception')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#roc.Perception.pb_conn","title":"<code>pb_conn = self.connect_bus(Perception.bus)</code>  <code>instance-attribute</code>","text":""},{"location":"#roc.Perception.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.pb_conn = self.connect_bus(Perception.bus)\n    self.pb_conn.listen(self.do_perception)\n</code></pre>"},{"location":"#roc.Perception.do_perception","title":"<code>do_perception(e)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@abstractmethod\ndef do_perception(self, e: PerceptionEvent) -&gt; None: ...\n</code></pre>"},{"location":"#roc.Perception.init","title":"<code>init()</code>  <code>classmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@classmethod\ndef init(cls) -&gt; None:\n    global perception_bus\n    cls.bus = EventBus[PerceptionData](\"perception\")\n</code></pre>"},{"location":"#roc.init","title":"<code>init(config=None)</code>","text":"<p>Initializes the agent before starting the agent.</p> Source code in <code>roc/__init__.py</code> <pre><code>def init(config: dict[str, Any] | None = None) -&gt; None:\n    \"\"\"Initializes the agent before starting the agent.\"\"\"\n    Config.init(config)\n    roc_logger.init()\n    global ng\n    ng = NethackGym()\n    Component.init()\n    ExpMod.init()\n    RocJupyterMagics.init()\n    init_state()\n</code></pre>"},{"location":"#roc.start","title":"<code>start()</code>","text":"<p>Starts the agent.</p> Source code in <code>roc/__init__.py</code> <pre><code>def start() -&gt; None:\n    \"\"\"Starts the agent.\"\"\"\n    global ng\n    if ng is None:\n        raise Exception(\"Call .init() before .start()\")\n\n    if is_jupyter():\n        # if running in Jupyter, start in a thread so that we can still inspect\n        # or debug from the iPython shell\n        roc_logger.logger.debug(\"Starting ROC: running in thread\")\n        t = Thread(target=ng.start)\n        t.start()\n    else:\n        roc_logger.logger.debug(\"Starting ROC: NOT running in thread\")\n        ng.start()\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>action</li> <li>attention</li> <li>breakpoint</li> <li>component</li> <li>config</li> <li>event</li> <li>expmod</li> <li>feature_extractors<ul> <li>color</li> <li>delta</li> <li>distance</li> <li>flood</li> <li>line</li> <li>motion</li> <li>shape</li> <li>single</li> </ul> </li> <li>graphdb</li> <li>gymnasium</li> <li>intrinsic</li> <li>jupyter<ul> <li>brk</li> <li>cont</li> <li>roc</li> <li>save</li> <li>state</li> <li>step</li> <li>utils</li> </ul> </li> <li>location</li> <li>logger</li> <li>object</li> <li>perception</li> <li>script</li> </ul>"},{"location":"reference/action/","title":"action","text":"<p>The action module decides what action the agent should perform.</p>"},{"location":"reference/action/#action.ActionData","title":"<code>ActionData = ActionRequest | TakeAction</code>  <code>module-attribute</code>","text":""},{"location":"reference/action/#action.ActionEvent","title":"<code>ActionEvent = Event[ActionData]</code>  <code>module-attribute</code>","text":""},{"location":"reference/action/#action.Action","title":"<code>Action</code>","text":"<p>               Bases: <code>Component</code></p> <p>Component for determining which action to take.</p> Source code in <code>roc/action.py</code> <pre><code>@register_component(\"action\", \"action\", auto=True)\nclass Action(Component):\n    \"\"\"Component for determining which action to take.\"\"\"\n\n    bus = EventBus[ActionData](\"action\", cache_depth=10)\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.action_bus_conn = self.connect_bus(self.bus)\n        self.action_bus_conn.listen(self.action_request)\n\n    def event_filter(self, e: ActionEvent) -&gt; bool:\n        return isinstance(e.data, ActionRequest)\n\n    def action_request(self, e: ActionEvent) -&gt; None:\n        action = DefaultActionExpMod.get(default=\"pass\").get_action()\n        actevt = TakeAction(action)\n        self.action_bus_conn.send(actevt)\n</code></pre>"},{"location":"reference/action/#action.Action.action_bus_conn","title":"<code>action_bus_conn = self.connect_bus(self.bus)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.Action.bus","title":"<code>bus = EventBus[ActionData]('action', cache_depth=10)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.Action.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/action.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.action_bus_conn = self.connect_bus(self.bus)\n    self.action_bus_conn.listen(self.action_request)\n</code></pre>"},{"location":"reference/action/#action.Action.action_request","title":"<code>action_request(e)</code>","text":"Source code in <code>roc/action.py</code> <pre><code>def action_request(self, e: ActionEvent) -&gt; None:\n    action = DefaultActionExpMod.get(default=\"pass\").get_action()\n    actevt = TakeAction(action)\n    self.action_bus_conn.send(actevt)\n</code></pre>"},{"location":"reference/action/#action.Action.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/action.py</code> <pre><code>def event_filter(self, e: ActionEvent) -&gt; bool:\n    return isinstance(e.data, ActionRequest)\n</code></pre>"},{"location":"reference/action/#action.ActionRequest","title":"<code>ActionRequest</code>  <code>dataclass</code>","text":"<p>Communicates that the Gym is waiting for the agent to take an action.</p> Source code in <code>roc/action.py</code> <pre><code>@dataclass\nclass ActionRequest:\n    \"\"\"Communicates that the Gym is waiting for the agent to take an action.\"\"\"\n</code></pre>"},{"location":"reference/action/#action.ActionRequest.__init__","title":"<code>__init__()</code>","text":""},{"location":"reference/action/#action.DefaultActionPass","title":"<code>DefaultActionPass</code>","text":"<p>               Bases: <code>DefaultActionExpMod</code></p> Source code in <code>roc/action.py</code> <pre><code>@DefaultActionExpMod.register(\"pass\")\nclass DefaultActionPass(DefaultActionExpMod):\n    def get_action(self) -&gt; int:\n        \"\"\"Default action for Nethack that passes (the `.` character in the game)\"\"\"\n        return 19\n</code></pre>"},{"location":"reference/action/#action.DefaultActionPass.get_action","title":"<code>get_action()</code>","text":"<p>Default action for Nethack that passes (the <code>.</code> character in the game)</p> Source code in <code>roc/action.py</code> <pre><code>def get_action(self) -&gt; int:\n    \"\"\"Default action for Nethack that passes (the `.` character in the game)\"\"\"\n    return 19\n</code></pre>"},{"location":"reference/action/#action.TakeAction","title":"<code>TakeAction</code>  <code>dataclass</code>","text":"<p>Communicates back to the Gym which cation to take.</p> Source code in <code>roc/action.py</code> <pre><code>@dataclass\nclass TakeAction:\n    \"\"\"Communicates back to the Gym which cation to take.\"\"\"\n\n    action: Any\n</code></pre>"},{"location":"reference/action/#action.TakeAction.action","title":"<code>action: Any</code>  <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.TakeAction.__init__","title":"<code>__init__(action)</code>","text":""},{"location":"reference/attention/","title":"attention","text":"<p>Aggregates all Perception events and determines which locations / objects should received focus</p>"},{"location":"reference/attention/#attention.AttentionData","title":"<code>AttentionData = VisionAttentionData</code>  <code>module-attribute</code>","text":""},{"location":"reference/attention/#attention.AttentionEvent","title":"<code>AttentionEvent = Event[AttentionData]</code>  <code>module-attribute</code>","text":""},{"location":"reference/attention/#attention.Attention","title":"<code>Attention</code>","text":"<p>               Bases: <code>Component</code>, <code>ABC</code></p> Source code in <code>roc/attention.py</code> <pre><code>class Attention(Component, ABC):\n    bus = EventBus[AttentionData](\"attention\")\n</code></pre>"},{"location":"reference/attention/#attention.Attention.bus","title":"<code>bus = EventBus[AttentionData]('attention')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.CrossModalAttention","title":"<code>CrossModalAttention</code>","text":"<p>               Bases: <code>Attention</code></p> Source code in <code>roc/attention.py</code> <pre><code>class CrossModalAttention(Attention):\n    # TODO: listen for attention events\n    # TODO: select and emit a single event\n    pass\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap","title":"<code>SaliencyMap</code>","text":"<p>               Bases: <code>Grid[list[Feature[Any]]]</code></p> Source code in <code>roc/attention.py</code> <pre><code>class SaliencyMap(Grid[list[Feature[Any]]]):\n    grid: IntGrid | None\n\n    def __new__(cls, grid: IntGrid | None = None) -&gt; Self:\n        settings = Config.get()\n        my_shape = grid.shape if grid is not None else settings.observation_shape\n        assert my_shape is not None\n        obj = np.ndarray(my_shape, dtype=object).view(cls)\n        for row, col in np.ndindex(my_shape):\n            obj[row, col] = list()\n        obj.grid = grid\n\n        return obj\n\n    def __str__(self) -&gt; str:\n        assert self.grid is not None\n        dg = DebugGrid(self.grid)\n        max_str = self.get_max_strength()\n\n        # prevent divide by zero\n        if max_str == 0:\n            max_str = 1\n\n        for p in self.grid.points():\n            rel_strength = self.get_strength(p.x, p.y) / max_str\n            color = DebugGrid.blue_to_red_hue(rel_strength)\n            dg.set_style(p.x, p.y, back_brightness=1, back_hue=color)\n        return str(dg)\n\n    def __array_finalize__(self, obj: npt.NDArray[Any] | None) -&gt; None:\n        if obj is None:\n            return\n        self.grid = getattr(obj, \"grid\", None)\n\n    def __deepcopy__(self, memodict: object | None = None) -&gt; SaliencyMap:\n        sm = SaliencyMap(deepcopy(self.grid))\n        for row, col in np.ndindex(self.shape):\n            sm[row, col] = self[row, col].copy()\n        return sm\n\n    def clear(self) -&gt; None:\n        \"\"\"Clears out all values from the SaliencyMap.\"\"\"\n        for row, col in np.ndindex(self.shape):\n            self[row, col].clear()\n\n    @property\n    def size(self) -&gt; int:\n        sz = 0\n        for val in self:\n            sz = sz + len(val)\n\n        return sz\n\n    def add_val(self, x: int, y: int, val: Feature[Any]) -&gt; None:\n        feature_list = self.get_val(x, y)\n        feature_list.append(val)\n\n    def get_max_strength(self) -&gt; int:\n        max = 0\n        for y in range(self.height):\n            for x in range(self.width):\n                curr = self.get_strength(x, y)\n                if max &lt; curr:\n                    max = curr\n\n        return max\n\n    def get_strength(self, x: int, y: int) -&gt; int:\n        feature_list = self.get_val(x, y)\n        # TODO: not really sure that the strength should depend on the number of features\n        ret = len(feature_list)\n\n        def add_strength(f: Feature[Any]) -&gt; None:\n            nonlocal ret\n\n            # TODO: this is pretty arbitrary and might be biased based on my\n            # domain knowledge... I suspect I will come back and modify this\n            # based on object recognition and other factors at some point in\n            # the future\n            if f.feature_name == \"Single\":\n                ret += 10\n            if f.feature_name == \"Delta\":\n                ret += 15\n            if f.feature_name == \"Motion\":\n                ret += 20\n\n        for f in feature_list:\n            add_strength(f)\n\n        return ret\n\n    def feature_report(self) -&gt; dict[str, int]:\n        feature_id: dict[str, set[int]] = dict()\n\n        # create a set of unique IDs for every distinct feature\n        for row, col in np.ndindex(self.shape):\n            feature_list = self[row, col]\n            for f in feature_list:\n                feature_name = f.feature_name\n                if feature_name not in feature_id:\n                    feature_id[feature_name] = set()\n                feature_id[feature_name].add(id(f))\n\n        # count all the sets\n        ret = {k: len(feature_id[k]) for k in feature_id}\n        return ret\n\n    def get_focus(self) -&gt; DataSet[VisionAttentionSchema]:\n        max_str = self.get_max_strength()\n\n        # prevent divide by zero\n        if max_str == 0:\n            max_str = 1\n\n        fkimg = np.array(\n            [\n                [self.get_strength(x, y) / max_str for y in range(self.height)]\n                for x in range(self.width)\n            ]\n        )\n\n        # find peaks through dilation\n        seed = np.copy(fkimg)\n        seed[1:-1, 1:-1] = fkimg.min()\n        rec = reconstruction(seed, fkimg, method=\"dilation\")\n        peaks = fkimg - rec\n\n        # get coordinates of peaks\n        nz = peaks.nonzero()\n        coords = np.column_stack(nz)\n\n        # label points that are adjacent / diagonal\n        structure = np.ones((3, 3), dtype=int)\n        labeled, ncomponents = label(peaks, structure)\n\n        # get values for each coordinate\n        flat_indicies = np.ravel_multi_index(tuple(coords.T), fkimg.shape)\n        vals = np.take(fkimg, flat_indicies)\n        labels = np.take(labeled, flat_indicies)\n\n        # create table of peak info, ordered by strength\n        df = (\n            pd.DataFrame(\n                {\n                    \"x\": nz[0],\n                    \"y\": nz[1],\n                    \"strength\": vals,\n                    \"label\": labels,\n                }\n            )\n            .astype({\"x\": int, \"y\": int, \"strength\": float, \"label\": int})\n            .sort_values(\"strength\", ascending=False)\n            .reset_index(drop=True)\n        )\n\n        return DataSet[VisionAttentionSchema](df)\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.grid","title":"<code>grid: IntGrid | None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.SaliencyMap.size","title":"<code>size: int</code>  <code>property</code>","text":""},{"location":"reference/attention/#attention.SaliencyMap.__array_finalize__","title":"<code>__array_finalize__(obj)</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def __array_finalize__(self, obj: npt.NDArray[Any] | None) -&gt; None:\n    if obj is None:\n        return\n    self.grid = getattr(obj, \"grid\", None)\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.__deepcopy__","title":"<code>__deepcopy__(memodict=None)</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def __deepcopy__(self, memodict: object | None = None) -&gt; SaliencyMap:\n    sm = SaliencyMap(deepcopy(self.grid))\n    for row, col in np.ndindex(self.shape):\n        sm[row, col] = self[row, col].copy()\n    return sm\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.__new__","title":"<code>__new__(grid=None)</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def __new__(cls, grid: IntGrid | None = None) -&gt; Self:\n    settings = Config.get()\n    my_shape = grid.shape if grid is not None else settings.observation_shape\n    assert my_shape is not None\n    obj = np.ndarray(my_shape, dtype=object).view(cls)\n    for row, col in np.ndindex(my_shape):\n        obj[row, col] = list()\n    obj.grid = grid\n\n    return obj\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def __str__(self) -&gt; str:\n    assert self.grid is not None\n    dg = DebugGrid(self.grid)\n    max_str = self.get_max_strength()\n\n    # prevent divide by zero\n    if max_str == 0:\n        max_str = 1\n\n    for p in self.grid.points():\n        rel_strength = self.get_strength(p.x, p.y) / max_str\n        color = DebugGrid.blue_to_red_hue(rel_strength)\n        dg.set_style(p.x, p.y, back_brightness=1, back_hue=color)\n    return str(dg)\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.add_val","title":"<code>add_val(x, y, val)</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def add_val(self, x: int, y: int, val: Feature[Any]) -&gt; None:\n    feature_list = self.get_val(x, y)\n    feature_list.append(val)\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.clear","title":"<code>clear()</code>","text":"<p>Clears out all values from the SaliencyMap.</p> Source code in <code>roc/attention.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clears out all values from the SaliencyMap.\"\"\"\n    for row, col in np.ndindex(self.shape):\n        self[row, col].clear()\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.feature_report","title":"<code>feature_report()</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def feature_report(self) -&gt; dict[str, int]:\n    feature_id: dict[str, set[int]] = dict()\n\n    # create a set of unique IDs for every distinct feature\n    for row, col in np.ndindex(self.shape):\n        feature_list = self[row, col]\n        for f in feature_list:\n            feature_name = f.feature_name\n            if feature_name not in feature_id:\n                feature_id[feature_name] = set()\n            feature_id[feature_name].add(id(f))\n\n    # count all the sets\n    ret = {k: len(feature_id[k]) for k in feature_id}\n    return ret\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.get_focus","title":"<code>get_focus()</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def get_focus(self) -&gt; DataSet[VisionAttentionSchema]:\n    max_str = self.get_max_strength()\n\n    # prevent divide by zero\n    if max_str == 0:\n        max_str = 1\n\n    fkimg = np.array(\n        [\n            [self.get_strength(x, y) / max_str for y in range(self.height)]\n            for x in range(self.width)\n        ]\n    )\n\n    # find peaks through dilation\n    seed = np.copy(fkimg)\n    seed[1:-1, 1:-1] = fkimg.min()\n    rec = reconstruction(seed, fkimg, method=\"dilation\")\n    peaks = fkimg - rec\n\n    # get coordinates of peaks\n    nz = peaks.nonzero()\n    coords = np.column_stack(nz)\n\n    # label points that are adjacent / diagonal\n    structure = np.ones((3, 3), dtype=int)\n    labeled, ncomponents = label(peaks, structure)\n\n    # get values for each coordinate\n    flat_indicies = np.ravel_multi_index(tuple(coords.T), fkimg.shape)\n    vals = np.take(fkimg, flat_indicies)\n    labels = np.take(labeled, flat_indicies)\n\n    # create table of peak info, ordered by strength\n    df = (\n        pd.DataFrame(\n            {\n                \"x\": nz[0],\n                \"y\": nz[1],\n                \"strength\": vals,\n                \"label\": labels,\n            }\n        )\n        .astype({\"x\": int, \"y\": int, \"strength\": float, \"label\": int})\n        .sort_values(\"strength\", ascending=False)\n        .reset_index(drop=True)\n    )\n\n    return DataSet[VisionAttentionSchema](df)\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.get_max_strength","title":"<code>get_max_strength()</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def get_max_strength(self) -&gt; int:\n    max = 0\n    for y in range(self.height):\n        for x in range(self.width):\n            curr = self.get_strength(x, y)\n            if max &lt; curr:\n                max = curr\n\n    return max\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.get_strength","title":"<code>get_strength(x, y)</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def get_strength(self, x: int, y: int) -&gt; int:\n    feature_list = self.get_val(x, y)\n    # TODO: not really sure that the strength should depend on the number of features\n    ret = len(feature_list)\n\n    def add_strength(f: Feature[Any]) -&gt; None:\n        nonlocal ret\n\n        # TODO: this is pretty arbitrary and might be biased based on my\n        # domain knowledge... I suspect I will come back and modify this\n        # based on object recognition and other factors at some point in\n        # the future\n        if f.feature_name == \"Single\":\n            ret += 10\n        if f.feature_name == \"Delta\":\n            ret += 15\n        if f.feature_name == \"Motion\":\n            ret += 20\n\n    for f in feature_list:\n        add_strength(f)\n\n    return ret\n</code></pre>"},{"location":"reference/attention/#attention.VisionAttention","title":"<code>VisionAttention</code>","text":"<p>               Bases: <code>Attention</code></p> Source code in <code>roc/attention.py</code> <pre><code>@register_component(\"vision\", \"attention\", auto=True)\nclass VisionAttention(Attention):\n    saliency_map: SaliencyMap\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.pb_conn = self.connect_bus(Perception.bus)\n        self.pb_conn.listen(self.do_attention)\n        self.att_conn = self.connect_bus(Attention.bus)\n        self.saliency_map = SaliencyMap()\n        self.settled: set[str] = set()\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        allow = (\n            isinstance(e.data, Feature)\n            or isinstance(e.data, Settled)\n            or isinstance(e.data, VisionData)\n        )\n        return allow\n\n    def do_attention(self, e: PerceptionEvent) -&gt; None:\n        # create right-sized SaliencyMap based on VisionData\n        if isinstance(e.data, VisionData):\n            self.saliency_map.grid = IntGrid(e.data.chars)\n            return\n\n        # check to see if all feature extractors have settled\n        if isinstance(e.data, Settled):\n            self.settled.add(str(e.src_id))\n\n            unsettled = set(FeatureExtractor.list()) - self.settled\n            if len(unsettled) == 0:\n                assert self.saliency_map is not None\n                focus = self.saliency_map.get_focus()\n\n                self.att_conn.send(\n                    VisionAttentionData(\n                        focus_points=self.saliency_map.get_focus(),\n                        saliency_map=self.saliency_map,\n                    )\n                )\n\n                # reset\n                self.settled.clear()\n                self.saliency_map = SaliencyMap()\n\n            return\n\n        # register each location in the saliency map\n        assert isinstance(e.data, Feature)\n        f = e.data\n\n        # create saliency map\n        for p in f.get_points():\n            self.saliency_map.add_val(p[0], p[1], f)\n</code></pre>"},{"location":"reference/attention/#attention.VisionAttention.att_conn","title":"<code>att_conn = self.connect_bus(Attention.bus)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.VisionAttention.pb_conn","title":"<code>pb_conn = self.connect_bus(Perception.bus)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.VisionAttention.saliency_map","title":"<code>saliency_map: SaliencyMap = SaliencyMap()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.VisionAttention.settled","title":"<code>settled: set[str] = set()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.VisionAttention.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.pb_conn = self.connect_bus(Perception.bus)\n    self.pb_conn.listen(self.do_attention)\n    self.att_conn = self.connect_bus(Attention.bus)\n    self.saliency_map = SaliencyMap()\n    self.settled: set[str] = set()\n</code></pre>"},{"location":"reference/attention/#attention.VisionAttention.do_attention","title":"<code>do_attention(e)</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def do_attention(self, e: PerceptionEvent) -&gt; None:\n    # create right-sized SaliencyMap based on VisionData\n    if isinstance(e.data, VisionData):\n        self.saliency_map.grid = IntGrid(e.data.chars)\n        return\n\n    # check to see if all feature extractors have settled\n    if isinstance(e.data, Settled):\n        self.settled.add(str(e.src_id))\n\n        unsettled = set(FeatureExtractor.list()) - self.settled\n        if len(unsettled) == 0:\n            assert self.saliency_map is not None\n            focus = self.saliency_map.get_focus()\n\n            self.att_conn.send(\n                VisionAttentionData(\n                    focus_points=self.saliency_map.get_focus(),\n                    saliency_map=self.saliency_map,\n                )\n            )\n\n            # reset\n            self.settled.clear()\n            self.saliency_map = SaliencyMap()\n\n        return\n\n    # register each location in the saliency map\n    assert isinstance(e.data, Feature)\n    f = e.data\n\n    # create saliency map\n    for p in f.get_points():\n        self.saliency_map.add_val(p[0], p[1], f)\n</code></pre>"},{"location":"reference/attention/#attention.VisionAttention.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    allow = (\n        isinstance(e.data, Feature)\n        or isinstance(e.data, Settled)\n        or isinstance(e.data, VisionData)\n    )\n    return allow\n</code></pre>"},{"location":"reference/attention/#attention.VisionAttentionData","title":"<code>VisionAttentionData</code>  <code>dataclass</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>@dataclass\nclass VisionAttentionData:\n    focus_points: DataSet[VisionAttentionSchema]\n    saliency_map: SaliencyMap\n\n    def __str__(self) -&gt; str:\n        assert self.saliency_map.grid is not None\n        dg = DebugGrid(self.saliency_map.grid)\n\n        for idx, row in self.focus_points.iterrows():\n            x = int(row[\"x\"])\n            y = int(row[\"y\"])\n            dg.set_style(x, y, back_brightness=row[\"strength\"], back_hue=1)\n\n        return f\"{str(dg)}\\n\\nFocus Points:\\n{self.focus_points}\"\n</code></pre>"},{"location":"reference/attention/#attention.VisionAttentionData.focus_points","title":"<code>focus_points: DataSet[VisionAttentionSchema]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.VisionAttentionData.saliency_map","title":"<code>saliency_map: SaliencyMap</code>  <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.VisionAttentionData.__init__","title":"<code>__init__(focus_points, saliency_map)</code>","text":""},{"location":"reference/attention/#attention.VisionAttentionData.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def __str__(self) -&gt; str:\n    assert self.saliency_map.grid is not None\n    dg = DebugGrid(self.saliency_map.grid)\n\n    for idx, row in self.focus_points.iterrows():\n        x = int(row[\"x\"])\n        y = int(row[\"y\"])\n        dg.set_style(x, y, back_brightness=row[\"strength\"], back_hue=1)\n\n    return f\"{str(dg)}\\n\\nFocus Points:\\n{self.focus_points}\"\n</code></pre>"},{"location":"reference/attention/#attention.VisionAttentionSchema","title":"<code>VisionAttentionSchema</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>class VisionAttentionSchema:\n    x: int\n    y: int\n    strength: float\n    label: int\n</code></pre>"},{"location":"reference/attention/#attention.VisionAttentionSchema.label","title":"<code>label: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.VisionAttentionSchema.strength","title":"<code>strength: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.VisionAttentionSchema.x","title":"<code>x: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.VisionAttentionSchema.y","title":"<code>y: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/breakpoint/","title":"breakpoint","text":"<p>Execution control for ROC, primarily used in Jupyter notebooks</p>"},{"location":"reference/breakpoint/#breakpoint.ConditionFn","title":"<code>ConditionFn: TypeAlias = Callable[[], bool]</code>  <code>module-attribute</code>","text":""},{"location":"reference/breakpoint/#breakpoint.breakpoints","title":"<code>breakpoints = Breakpoint()</code>  <code>module-attribute</code>","text":""},{"location":"reference/breakpoint/#breakpoint.Breakpoint","title":"<code>Breakpoint</code>","text":"<p>Controls the state of breakpoints and program execution. This should probably be renamed to <code>BreakpointControl</code>. :)</p> Source code in <code>roc/breakpoint.py</code> <pre><code>class Breakpoint:\n    \"\"\"Controls the state of breakpoints and program execution. This should\n    probably be renamed to `BreakpointControl`. :)\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.brk = False\n        self.trigger: str | None = None\n        self.lock = Lock()\n\n    def __len__(self) -&gt; int:\n        global _breakpoints_dict\n\n        return len(_breakpoints_dict)\n\n    def __contains__(self, key: str) -&gt; bool:\n        global _breakpoints_dict\n\n        return key in _breakpoints_dict\n\n    def __str__(self) -&gt; str:\n        global _breakpoints_dict\n\n        def mkrow(k: str) -&gt; list[str | bool]:\n            fn = _breakpoints_dict[k].fn\n            src = _breakpoints_dict[k].src\n            if not src:\n                filename = inspect.getfile(fn).split(os.path.sep)[-1]\n                line = inspect.getsourcelines(fn)[1]\n                src = f\"{filename}:{line}\"\n            triggered = \" \" if (self.trigger is None or self.trigger != k) else \"*\"\n            return [triggered, k, src]\n\n        rows = map(mkrow, _breakpoints_dict.keys())\n\n        hdr = f\"{self.count} breakpoint(s). State: {self.state}.\"\n        tbl = (\n            \"\"\n            if self.count == 0\n            else \"\\n\\n\"\n            + tabulate(\n                rows, headers=[\" \", \"Breakpoints\", \"Source\"], showindex=\"always\", tablefmt=\"simple\"\n            )\n        )\n\n        return f\"{hdr}{tbl}\"\n\n    def add(\n        self,\n        fn: ConditionFn,\n        *,\n        name: str | None = None,\n        overwrite: Optional[bool] = False,\n        src: str | None = None,\n    ) -&gt; None:\n        \"\"\"Adds a new breakpoint\n\n        Args:\n            fn (ConditionFn): A function that returns True when program\n                execution should stop\n            name (str | None, optional): The name of this breakpoint. Defaults\n                to the __name__ of the specified function, or '&lt;unknown&gt;' if name\n                isn't specified and __name__ doesn't exist.\n            overwrite (bool, optional): If True, this will overwrite existing\n                breakpoints with the same name. Defaults to False.\n            src (str | None, optional): The source / sourcecode for the\n                breakpoint. If not specified, it will use the file and line\n                number of the specified function. Mostly used by the Jupyter\n                shell to pass in 'iPython' as the source for functions defined\n                in Jupyter, because knowing that the function is stored in a\n                tempfile isn't especially helpful.\n\n        Raises:\n            Exception: Raises an exception if the specified breakpoint name\n            already exists and overwrite is False.\n        \"\"\"\n        global _breakpoints_dict\n\n        if not name and hasattr(fn, \"__name__\"):\n            name = fn.__name__\n\n        if not name:\n            name = \"&lt;unknown&gt;\"\n\n        if name in _breakpoints_dict and not overwrite:\n            raise Exception(\n                f\"'{name}' already exists in breakpoints, call 'remove' first or specify 'overwrite=True' while adding\"\n            )\n\n        _breakpoints_dict[name] = BreakpointInfo(fn=fn, src=src)\n\n    def remove(self, name: str) -&gt; None:\n        \"\"\"Removes the breakpoint with the specified name\n\n        Args:\n            name (str): The name of the breakpoint to remove\n\n        Raises:\n            Exception: If the specified breakpoint doesn't exist\n        \"\"\"\n        global _breakpoints_dict\n\n        if name not in _breakpoints_dict:\n            raise Exception(f\"can't remove '{name}' from breakpoints because it doesn't exist\")\n\n        del _breakpoints_dict[name]\n\n    def clear(self) -&gt; None:\n        \"\"\"Removes all breakpoints\"\"\"\n        global _breakpoints_dict\n\n        _breakpoints_dict.clear()\n\n    @property\n    def count(self) -&gt; int:\n        \"\"\"The number of breakpoints that have been added.\"\"\"\n        return len(self)\n\n    @property\n    def state(self) -&gt; str:\n        \"\"\"The state of execution, either 'stopped' or 'running'\"\"\"\n        return \"stopped\" if self.brk else \"running\"\n\n    def list(self) -&gt; None:\n        \"\"\"Prints all current breakpoints and the state of execution\"\"\"\n        print(str(self))  # noqa: T201\n\n    def resume(self, quiet: Optional[bool] = False) -&gt; None:\n        \"\"\"If execution is currently stopped, this will resume execution. If not\n        stopped, this does nothing.\n\n        Args:\n            quiet (bool, optional): If True, this function won't log status\n                messages about resuming. Defaults to False.\n        \"\"\"\n        if not self.brk:\n            return\n\n        self.brk = False\n        self.trigger = None\n        self.lock.release()\n\n        if not quiet:\n            logger.info(\"resuming\")\n\n    def do_break(\n        self, trigger: Optional[str] = \"&lt;user request&gt;\", quiet: Optional[bool] = False\n    ) -&gt; None:\n        \"\"\"Sets the state of execution to 'stopped' and blocks further execution\n        until `resume` is called. This is typically called by `check` inside the\n        program, but may be called directly (e.g. by a Jupyter magic command) to\n        manually stop execution.\n\n        Args:\n            trigger (str, optional): The name of the breakpoint that caused the\n                break. Defaults to \"&lt;user request&gt;\".\n            quiet (bool, optional): If True, this function won't log status\n                messages about resuming. Defaults to False.\n        \"\"\"\n        if self.brk:\n            return\n\n        self.brk = True\n        self.trigger = trigger\n\n        if not quiet:\n            logger.info(f\"breaking due to: {trigger}\")\n\n        self.lock.acquire()\n\n    def check(self) -&gt; None:\n        \"\"\"Checks whether any breakpoints are currently triggered by calling the\n        functions that were submitted by `add`. If / when the first function\n        returns True, program execution stops and will only resume when `resume`\n        is called.\n\n        This function is intended to be included in a execution loop or any\n        place you want to check for breakpoints before continuing to execute code.\n        \"\"\"\n        global _breakpoints_dict\n\n        waslocked = False\n        if self.lock.locked():\n            waslocked = True\n\n        # stop here if we are in a break\n        with self.lock:\n            # if we were stopped and are continuing now, don't immediately stop\n            # again due to another breakpoint\n            if not waslocked:\n                for b in _breakpoints_dict:\n                    if _breakpoints_dict[b].fn():\n                        self.do_break(trigger=b)\n                        waslocked = True\n                        break\n\n        if waslocked:\n            logger.info(\"break done, continuing operations...\")\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.brk","title":"<code>brk = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/breakpoint/#breakpoint.Breakpoint.count","title":"<code>count: int</code>  <code>property</code>","text":"<p>The number of breakpoints that have been added.</p>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.lock","title":"<code>lock = Lock()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/breakpoint/#breakpoint.Breakpoint.state","title":"<code>state: str</code>  <code>property</code>","text":"<p>The state of execution, either 'stopped' or 'running'</p>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.trigger","title":"<code>trigger: str | None = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/breakpoint/#breakpoint.Breakpoint.__contains__","title":"<code>__contains__(key)</code>","text":"Source code in <code>roc/breakpoint.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n    global _breakpoints_dict\n\n    return key in _breakpoints_dict\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/breakpoint.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.brk = False\n    self.trigger: str | None = None\n    self.lock = Lock()\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.__len__","title":"<code>__len__()</code>","text":"Source code in <code>roc/breakpoint.py</code> <pre><code>def __len__(self) -&gt; int:\n    global _breakpoints_dict\n\n    return len(_breakpoints_dict)\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/breakpoint.py</code> <pre><code>def __str__(self) -&gt; str:\n    global _breakpoints_dict\n\n    def mkrow(k: str) -&gt; list[str | bool]:\n        fn = _breakpoints_dict[k].fn\n        src = _breakpoints_dict[k].src\n        if not src:\n            filename = inspect.getfile(fn).split(os.path.sep)[-1]\n            line = inspect.getsourcelines(fn)[1]\n            src = f\"{filename}:{line}\"\n        triggered = \" \" if (self.trigger is None or self.trigger != k) else \"*\"\n        return [triggered, k, src]\n\n    rows = map(mkrow, _breakpoints_dict.keys())\n\n    hdr = f\"{self.count} breakpoint(s). State: {self.state}.\"\n    tbl = (\n        \"\"\n        if self.count == 0\n        else \"\\n\\n\"\n        + tabulate(\n            rows, headers=[\" \", \"Breakpoints\", \"Source\"], showindex=\"always\", tablefmt=\"simple\"\n        )\n    )\n\n    return f\"{hdr}{tbl}\"\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.add","title":"<code>add(fn, *, name=None, overwrite=False, src=None)</code>","text":"<p>Adds a new breakpoint</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>ConditionFn</code> <p>A function that returns True when program execution should stop</p> required <code>name</code> <code>str | None</code> <p>The name of this breakpoint. Defaults to the name of the specified function, or '' if name isn't specified and name doesn't exist. <code>None</code> <code>overwrite</code> <code>bool</code> <p>If True, this will overwrite existing breakpoints with the same name. Defaults to False.</p> <code>False</code> <code>src</code> <code>str | None</code> <p>The source / sourcecode for the breakpoint. If not specified, it will use the file and line number of the specified function. Mostly used by the Jupyter shell to pass in 'iPython' as the source for functions defined in Jupyter, because knowing that the function is stored in a tempfile isn't especially helpful.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Raises an exception if the specified breakpoint name</p> Source code in <code>roc/breakpoint.py</code> <pre><code>def add(\n    self,\n    fn: ConditionFn,\n    *,\n    name: str | None = None,\n    overwrite: Optional[bool] = False,\n    src: str | None = None,\n) -&gt; None:\n    \"\"\"Adds a new breakpoint\n\n    Args:\n        fn (ConditionFn): A function that returns True when program\n            execution should stop\n        name (str | None, optional): The name of this breakpoint. Defaults\n            to the __name__ of the specified function, or '&lt;unknown&gt;' if name\n            isn't specified and __name__ doesn't exist.\n        overwrite (bool, optional): If True, this will overwrite existing\n            breakpoints with the same name. Defaults to False.\n        src (str | None, optional): The source / sourcecode for the\n            breakpoint. If not specified, it will use the file and line\n            number of the specified function. Mostly used by the Jupyter\n            shell to pass in 'iPython' as the source for functions defined\n            in Jupyter, because knowing that the function is stored in a\n            tempfile isn't especially helpful.\n\n    Raises:\n        Exception: Raises an exception if the specified breakpoint name\n        already exists and overwrite is False.\n    \"\"\"\n    global _breakpoints_dict\n\n    if not name and hasattr(fn, \"__name__\"):\n        name = fn.__name__\n\n    if not name:\n        name = \"&lt;unknown&gt;\"\n\n    if name in _breakpoints_dict and not overwrite:\n        raise Exception(\n            f\"'{name}' already exists in breakpoints, call 'remove' first or specify 'overwrite=True' while adding\"\n        )\n\n    _breakpoints_dict[name] = BreakpointInfo(fn=fn, src=src)\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.check","title":"<code>check()</code>","text":"<p>Checks whether any breakpoints are currently triggered by calling the functions that were submitted by <code>add</code>. If / when the first function returns True, program execution stops and will only resume when <code>resume</code> is called.</p> <p>This function is intended to be included in a execution loop or any place you want to check for breakpoints before continuing to execute code.</p> Source code in <code>roc/breakpoint.py</code> <pre><code>def check(self) -&gt; None:\n    \"\"\"Checks whether any breakpoints are currently triggered by calling the\n    functions that were submitted by `add`. If / when the first function\n    returns True, program execution stops and will only resume when `resume`\n    is called.\n\n    This function is intended to be included in a execution loop or any\n    place you want to check for breakpoints before continuing to execute code.\n    \"\"\"\n    global _breakpoints_dict\n\n    waslocked = False\n    if self.lock.locked():\n        waslocked = True\n\n    # stop here if we are in a break\n    with self.lock:\n        # if we were stopped and are continuing now, don't immediately stop\n        # again due to another breakpoint\n        if not waslocked:\n            for b in _breakpoints_dict:\n                if _breakpoints_dict[b].fn():\n                    self.do_break(trigger=b)\n                    waslocked = True\n                    break\n\n    if waslocked:\n        logger.info(\"break done, continuing operations...\")\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.clear","title":"<code>clear()</code>","text":"<p>Removes all breakpoints</p> Source code in <code>roc/breakpoint.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Removes all breakpoints\"\"\"\n    global _breakpoints_dict\n\n    _breakpoints_dict.clear()\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.do_break","title":"<code>do_break(trigger='&lt;user request&gt;', quiet=False)</code>","text":"<p>Sets the state of execution to 'stopped' and blocks further execution until <code>resume</code> is called. This is typically called by <code>check</code> inside the program, but may be called directly (e.g. by a Jupyter magic command) to manually stop execution.</p> <p>Parameters:</p> Name Type Description Default <code>trigger</code> <code>str</code> <p>The name of the breakpoint that caused the break. Defaults to \"\". <code>'&lt;user request&gt;'</code> <code>quiet</code> <code>bool</code> <p>If True, this function won't log status messages about resuming. Defaults to False.</p> <code>False</code> Source code in <code>roc/breakpoint.py</code> <pre><code>def do_break(\n    self, trigger: Optional[str] = \"&lt;user request&gt;\", quiet: Optional[bool] = False\n) -&gt; None:\n    \"\"\"Sets the state of execution to 'stopped' and blocks further execution\n    until `resume` is called. This is typically called by `check` inside the\n    program, but may be called directly (e.g. by a Jupyter magic command) to\n    manually stop execution.\n\n    Args:\n        trigger (str, optional): The name of the breakpoint that caused the\n            break. Defaults to \"&lt;user request&gt;\".\n        quiet (bool, optional): If True, this function won't log status\n            messages about resuming. Defaults to False.\n    \"\"\"\n    if self.brk:\n        return\n\n    self.brk = True\n    self.trigger = trigger\n\n    if not quiet:\n        logger.info(f\"breaking due to: {trigger}\")\n\n    self.lock.acquire()\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.list","title":"<code>list()</code>","text":"<p>Prints all current breakpoints and the state of execution</p> Source code in <code>roc/breakpoint.py</code> <pre><code>def list(self) -&gt; None:\n    \"\"\"Prints all current breakpoints and the state of execution\"\"\"\n    print(str(self))  # noqa: T201\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.remove","title":"<code>remove(name)</code>","text":"<p>Removes the breakpoint with the specified name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the breakpoint to remove</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the specified breakpoint doesn't exist</p> Source code in <code>roc/breakpoint.py</code> <pre><code>def remove(self, name: str) -&gt; None:\n    \"\"\"Removes the breakpoint with the specified name\n\n    Args:\n        name (str): The name of the breakpoint to remove\n\n    Raises:\n        Exception: If the specified breakpoint doesn't exist\n    \"\"\"\n    global _breakpoints_dict\n\n    if name not in _breakpoints_dict:\n        raise Exception(f\"can't remove '{name}' from breakpoints because it doesn't exist\")\n\n    del _breakpoints_dict[name]\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.resume","title":"<code>resume(quiet=False)</code>","text":"<p>If execution is currently stopped, this will resume execution. If not stopped, this does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>quiet</code> <code>bool</code> <p>If True, this function won't log status messages about resuming. Defaults to False.</p> <code>False</code> Source code in <code>roc/breakpoint.py</code> <pre><code>def resume(self, quiet: Optional[bool] = False) -&gt; None:\n    \"\"\"If execution is currently stopped, this will resume execution. If not\n    stopped, this does nothing.\n\n    Args:\n        quiet (bool, optional): If True, this function won't log status\n            messages about resuming. Defaults to False.\n    \"\"\"\n    if not self.brk:\n        return\n\n    self.brk = False\n    self.trigger = None\n    self.lock.release()\n\n    if not quiet:\n        logger.info(\"resuming\")\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.BreakpointInfo","title":"<code>BreakpointInfo</code>  <code>dataclass</code>","text":"<p>Information about a specific breakpoint</p> Source code in <code>roc/breakpoint.py</code> <pre><code>@dataclass\nclass BreakpointInfo:\n    \"\"\"Information about a specific breakpoint\"\"\"\n\n    fn: ConditionFn\n    src: str | None\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.BreakpointInfo.fn","title":"<code>fn: ConditionFn</code>  <code>instance-attribute</code>","text":""},{"location":"reference/breakpoint/#breakpoint.BreakpointInfo.src","title":"<code>src: str | None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/breakpoint/#breakpoint.BreakpointInfo.__init__","title":"<code>__init__(fn, src)</code>","text":""},{"location":"reference/component/","title":"component","text":"<p>This module defines the Component base class, which is instantiated for nearly every part of the system. It implements interfaces for communications, initialization, shutdown, etc.</p>"},{"location":"reference/component/#component.T","title":"<code>T = TypeVar('T')</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.WrappedComponentBase","title":"<code>WrappedComponentBase = TypeVar('WrappedComponentBase', bound=Component)</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.component_registry","title":"<code>component_registry: dict[str, type[Component]] = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.component_set","title":"<code>component_set: WeakSet[Component] = WeakSet()</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.default_components","title":"<code>default_components: set[str] = set()</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.loaded_components","title":"<code>loaded_components: dict[str, Component] = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.Component","title":"<code>Component</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract component class for building pieces of ROC that will talk to each other.</p> Source code in <code>roc/component.py</code> <pre><code>class Component(ABC):\n    \"\"\"An abstract component class for building pieces of ROC that will talk to each other.\"\"\"\n\n    name: str = \"&lt;name unassigned&gt;\"\n    type: str = \"&lt;type unassigned&gt;\"\n\n    def __init__(self) -&gt; None:\n        global component_set\n        component_set.add(self)\n        self.bus_conns: dict[str, BusConnection[Any]] = {}\n        logger.trace(f\"++ incrementing component count: {self.name}:{self.type} {self}\")\n        # traceback.print_stack()\n\n    def __del__(self) -&gt; None:\n        global component_set\n        component_set.add(self)\n        logger.trace(f\"-- decrementing component count: {self.name}:{self.type} {self}\")\n\n    def connect_bus(self, bus: EventBus[T]) -&gt; BusConnection[T]:\n        \"\"\"Create a new bus connection for the component, storing the result for\n        later shutdown.\n\n        Args:\n            bus (EventBus[T]): The event bus to attach to\n\n        Raises:\n            ValueError: if the bus has already been connected to by this component\n\n        Returns:\n            BusConnection[T]: The bus connection for listening or sending events\n        \"\"\"\n        if bus.name in self.bus_conns:\n            raise ValueError(\n                f\"Component '{self.name}' attempting duplicate connection to bus '{bus.name}'\"\n            )\n\n        conn = bus.connect(self)\n        self.bus_conns[bus.name] = conn\n        return conn\n\n    def event_filter(self, e: Event[Any]) -&gt; bool:\n        \"\"\"A filter for any incoming events. By default it filters out events\n        sent by itself, but it is especially useful for creating new filters in\n        sub-classes.\n\n        Args:\n            e (Event[Any]): The event to be evaluated\n\n        Returns:\n            bool: True if the event should be sent, False if it should be dropped\n        \"\"\"\n        return e.src_id != self.id\n\n    def shutdown(self) -&gt; None:\n        \"\"\"De-initializes the component, removing any bus connections and any\n        other clean-up that needs to be performed\n        \"\"\"\n        logger.debug(f\"Component {self.name}:{self.type} shutting down.\")\n\n        for conn in self.bus_conns:\n            for obs in self.bus_conns[conn].attached_bus.subject.observers:\n                obs.on_completed()\n            self.bus_conns[conn].close()\n\n    @property\n    def id(self) -&gt; ComponentId:\n        return ComponentId(self.type, self.name)\n\n    @staticmethod\n    def init() -&gt; None:\n        \"\"\"Loads all components registered as `auto` and perception components\n        in the `perception_components` config field.\n        \"\"\"\n        settings = Config.get()\n        component_list = default_components\n        logger.debug(\"perception components from settings\", settings.perception_components)\n        component_list = component_list.union(settings.perception_components, default_components)\n        logger.debug(f\"Component.init: default components: {component_list}\")\n\n        # TODO: shutdown previously loaded components\n\n        for reg_str in component_list:\n            logger.trace(f\"Loading component: {reg_str} ...\")\n            (name, type) = reg_str.split(\":\")\n            loaded_components[reg_str] = Component.get(name, type)\n\n    @classmethod\n    def get(cls, name: str, type: str, *args: Any, **kwargs: Any) -&gt; Self:\n        \"\"\"Retreives a component with the specified name from the registry and\n        creates a new version of it with the specified args. Used by\n        `Config.init` and for testing.\n\n        Args:\n            name (str): The name of the component to get, as specified during\n                its registration\n            type (str): The type of the component to get, as specified during\n                its registration\n            args (Any): Fixed position arguments to pass to the Component\n                constructor\n            kwargs (Any): Keyword args to pass to the Component constructor\n\n        Returns:\n            Self: the component that was created, casted as the calling class.\n            (e.g. `Perception.get(...)` will return a Perception component and\n            `Action.get(...)` will return an Action component)\n        \"\"\"\n        reg_str = _component_registry_key(name, type)\n        return cast(Self, component_registry[reg_str](*args, **kwargs))\n\n    @staticmethod\n    def get_component_count() -&gt; int:\n        \"\"\"Returns the number of currently created Components. The number goes\n        up on __init__ and down on __del__. Primarily used for testing to ensure\n        Components are being shutdown appropriately.\n\n        Returns:\n            int: The number of currently active Component instances\n        \"\"\"\n        # global component_count\n        # return component_count\n        global component_set\n        return len(component_set)\n\n    @staticmethod\n    def get_loaded_components() -&gt; list[str]:\n        \"\"\"Returns the names and types of all initiated components.\n\n        Returns:\n            list[str]: A list of the names and types of components, as strings.\n        \"\"\"\n        global loaded_components\n        return [s for s in loaded_components.keys()]\n\n    @staticmethod\n    def deregister(name: str, type: str) -&gt; None:\n        \"\"\"Removes a component from the Component registry. Primarlly used for testing.\n\n        Args:\n            name (str): The name of the Component to deregister\n            type (str): The type of the Component to deregister\n        \"\"\"\n        reg_str = _component_registry_key(name, type)\n        del component_registry[reg_str]\n\n    @staticmethod\n    def reset() -&gt; None:\n        \"\"\"Shuts down all components\"\"\"\n        # shutdown all components\n        global loaded_components\n        for name in loaded_components:\n            logger.trace(f\"Shutting down component: {name}.\")\n            c = loaded_components[name]\n            c.shutdown()\n\n        loaded_components.clear()\n\n        global component_set\n        for c in component_set:\n            c.shutdown()\n</code></pre>"},{"location":"reference/component/#component.Component.bus_conns","title":"<code>bus_conns: dict[str, BusConnection[Any]] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.Component.id","title":"<code>id: ComponentId</code>  <code>property</code>","text":""},{"location":"reference/component/#component.Component.name","title":"<code>name: str = '&lt;name unassigned&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.Component.type","title":"<code>type: str = '&lt;type unassigned&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.Component.__del__","title":"<code>__del__()</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __del__(self) -&gt; None:\n    global component_set\n    component_set.add(self)\n    logger.trace(f\"-- decrementing component count: {self.name}:{self.type} {self}\")\n</code></pre>"},{"location":"reference/component/#component.Component.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __init__(self) -&gt; None:\n    global component_set\n    component_set.add(self)\n    self.bus_conns: dict[str, BusConnection[Any]] = {}\n    logger.trace(f\"++ incrementing component count: {self.name}:{self.type} {self}\")\n</code></pre>"},{"location":"reference/component/#component.Component.connect_bus","title":"<code>connect_bus(bus)</code>","text":"<p>Create a new bus connection for the component, storing the result for later shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>EventBus[T]</code> <p>The event bus to attach to</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the bus has already been connected to by this component</p> <p>Returns:</p> Type Description <code>BusConnection[T]</code> <p>BusConnection[T]: The bus connection for listening or sending events</p> Source code in <code>roc/component.py</code> <pre><code>def connect_bus(self, bus: EventBus[T]) -&gt; BusConnection[T]:\n    \"\"\"Create a new bus connection for the component, storing the result for\n    later shutdown.\n\n    Args:\n        bus (EventBus[T]): The event bus to attach to\n\n    Raises:\n        ValueError: if the bus has already been connected to by this component\n\n    Returns:\n        BusConnection[T]: The bus connection for listening or sending events\n    \"\"\"\n    if bus.name in self.bus_conns:\n        raise ValueError(\n            f\"Component '{self.name}' attempting duplicate connection to bus '{bus.name}'\"\n        )\n\n    conn = bus.connect(self)\n    self.bus_conns[bus.name] = conn\n    return conn\n</code></pre>"},{"location":"reference/component/#component.Component.deregister","title":"<code>deregister(name, type)</code>  <code>staticmethod</code>","text":"<p>Removes a component from the Component registry. Primarlly used for testing.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the Component to deregister</p> required <code>type</code> <code>str</code> <p>The type of the Component to deregister</p> required Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef deregister(name: str, type: str) -&gt; None:\n    \"\"\"Removes a component from the Component registry. Primarlly used for testing.\n\n    Args:\n        name (str): The name of the Component to deregister\n        type (str): The type of the Component to deregister\n    \"\"\"\n    reg_str = _component_registry_key(name, type)\n    del component_registry[reg_str]\n</code></pre>"},{"location":"reference/component/#component.Component.event_filter","title":"<code>event_filter(e)</code>","text":"<p>A filter for any incoming events. By default it filters out events sent by itself, but it is especially useful for creating new filters in sub-classes.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Event[Any]</code> <p>The event to be evaluated</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the event should be sent, False if it should be dropped</p> Source code in <code>roc/component.py</code> <pre><code>def event_filter(self, e: Event[Any]) -&gt; bool:\n    \"\"\"A filter for any incoming events. By default it filters out events\n    sent by itself, but it is especially useful for creating new filters in\n    sub-classes.\n\n    Args:\n        e (Event[Any]): The event to be evaluated\n\n    Returns:\n        bool: True if the event should be sent, False if it should be dropped\n    \"\"\"\n    return e.src_id != self.id\n</code></pre>"},{"location":"reference/component/#component.Component.get","title":"<code>get(name, type, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Retreives a component with the specified name from the registry and creates a new version of it with the specified args. Used by <code>Config.init</code> and for testing.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the component to get, as specified during its registration</p> required <code>type</code> <code>str</code> <p>The type of the component to get, as specified during its registration</p> required <code>args</code> <code>Any</code> <p>Fixed position arguments to pass to the Component constructor</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>Keyword args to pass to the Component constructor</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the component that was created, casted as the calling class.</p> <code>Self</code> <p>(e.g. <code>Perception.get(...)</code> will return a Perception component and</p> <code>Self</code> <p><code>Action.get(...)</code> will return an Action component)</p> Source code in <code>roc/component.py</code> <pre><code>@classmethod\ndef get(cls, name: str, type: str, *args: Any, **kwargs: Any) -&gt; Self:\n    \"\"\"Retreives a component with the specified name from the registry and\n    creates a new version of it with the specified args. Used by\n    `Config.init` and for testing.\n\n    Args:\n        name (str): The name of the component to get, as specified during\n            its registration\n        type (str): The type of the component to get, as specified during\n            its registration\n        args (Any): Fixed position arguments to pass to the Component\n            constructor\n        kwargs (Any): Keyword args to pass to the Component constructor\n\n    Returns:\n        Self: the component that was created, casted as the calling class.\n        (e.g. `Perception.get(...)` will return a Perception component and\n        `Action.get(...)` will return an Action component)\n    \"\"\"\n    reg_str = _component_registry_key(name, type)\n    return cast(Self, component_registry[reg_str](*args, **kwargs))\n</code></pre>"},{"location":"reference/component/#component.Component.get_component_count","title":"<code>get_component_count()</code>  <code>staticmethod</code>","text":"<p>Returns the number of currently created Components. The number goes up on init and down on del. Primarily used for testing to ensure Components are being shutdown appropriately.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of currently active Component instances</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef get_component_count() -&gt; int:\n    \"\"\"Returns the number of currently created Components. The number goes\n    up on __init__ and down on __del__. Primarily used for testing to ensure\n    Components are being shutdown appropriately.\n\n    Returns:\n        int: The number of currently active Component instances\n    \"\"\"\n    # global component_count\n    # return component_count\n    global component_set\n    return len(component_set)\n</code></pre>"},{"location":"reference/component/#component.Component.get_loaded_components","title":"<code>get_loaded_components()</code>  <code>staticmethod</code>","text":"<p>Returns the names and types of all initiated components.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of the names and types of components, as strings.</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef get_loaded_components() -&gt; list[str]:\n    \"\"\"Returns the names and types of all initiated components.\n\n    Returns:\n        list[str]: A list of the names and types of components, as strings.\n    \"\"\"\n    global loaded_components\n    return [s for s in loaded_components.keys()]\n</code></pre>"},{"location":"reference/component/#component.Component.init","title":"<code>init()</code>  <code>staticmethod</code>","text":"<p>Loads all components registered as <code>auto</code> and perception components in the <code>perception_components</code> config field.</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef init() -&gt; None:\n    \"\"\"Loads all components registered as `auto` and perception components\n    in the `perception_components` config field.\n    \"\"\"\n    settings = Config.get()\n    component_list = default_components\n    logger.debug(\"perception components from settings\", settings.perception_components)\n    component_list = component_list.union(settings.perception_components, default_components)\n    logger.debug(f\"Component.init: default components: {component_list}\")\n\n    # TODO: shutdown previously loaded components\n\n    for reg_str in component_list:\n        logger.trace(f\"Loading component: {reg_str} ...\")\n        (name, type) = reg_str.split(\":\")\n        loaded_components[reg_str] = Component.get(name, type)\n</code></pre>"},{"location":"reference/component/#component.Component.reset","title":"<code>reset()</code>  <code>staticmethod</code>","text":"<p>Shuts down all components</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef reset() -&gt; None:\n    \"\"\"Shuts down all components\"\"\"\n    # shutdown all components\n    global loaded_components\n    for name in loaded_components:\n        logger.trace(f\"Shutting down component: {name}.\")\n        c = loaded_components[name]\n        c.shutdown()\n\n    loaded_components.clear()\n\n    global component_set\n    for c in component_set:\n        c.shutdown()\n</code></pre>"},{"location":"reference/component/#component.Component.shutdown","title":"<code>shutdown()</code>","text":"<p>De-initializes the component, removing any bus connections and any other clean-up that needs to be performed</p> Source code in <code>roc/component.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"De-initializes the component, removing any bus connections and any\n    other clean-up that needs to be performed\n    \"\"\"\n    logger.debug(f\"Component {self.name}:{self.type} shutting down.\")\n\n    for conn in self.bus_conns:\n        for obs in self.bus_conns[conn].attached_bus.subject.observers:\n            obs.on_completed()\n        self.bus_conns[conn].close()\n</code></pre>"},{"location":"reference/component/#component.ComponentId","title":"<code>ComponentId</code>","text":"<p>               Bases: <code>NamedTuple</code></p> Source code in <code>roc/component.py</code> <pre><code>class ComponentId(NamedTuple):\n    type: str\n    name: str\n\n    def __str__(self) -&gt; str:\n        return f\"{self.name}:{self.type}\"\n</code></pre>"},{"location":"reference/component/#component.ComponentId.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.ComponentId.type","title":"<code>type: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.ComponentId.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"{self.name}:{self.type}\"\n</code></pre>"},{"location":"reference/component/#component.register_component","title":"<code>register_component</code>","text":"<p>A decorator to register a new component.</p> Source code in <code>roc/component.py</code> <pre><code>class register_component:\n    \"\"\"A decorator to register a new component.\"\"\"\n\n    def __init__(self, name: str, type: str, *, auto: bool = False) -&gt; None:\n        self.name = name\n        self.type = type\n        self.auto = auto\n\n    def __call__(self, cls: type[Component]) -&gt; type[Component]:  # noqa: D102\n        global register_component\n        global component_registry\n\n        logger.trace(f\"Registering component: {self.name}:{self.type} (auto={self.auto})\")\n\n        reg_str = _component_registry_key(self.name, self.type)\n        if reg_str in component_registry:\n            raise ValueError(f\"Registering duplicate component name: '{self.name}'\")\n\n        if self.auto:\n            global default_components\n            default_components.add(reg_str)\n\n        component_registry[reg_str] = cls\n        cls.name = self.name\n        cls.type = self.type\n\n        return cls\n</code></pre>"},{"location":"reference/component/#component.register_component.auto","title":"<code>auto = auto</code>  <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.register_component.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.register_component.type","title":"<code>type = type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.register_component.__call__","title":"<code>__call__(cls)</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __call__(self, cls: type[Component]) -&gt; type[Component]:  # noqa: D102\n    global register_component\n    global component_registry\n\n    logger.trace(f\"Registering component: {self.name}:{self.type} (auto={self.auto})\")\n\n    reg_str = _component_registry_key(self.name, self.type)\n    if reg_str in component_registry:\n        raise ValueError(f\"Registering duplicate component name: '{self.name}'\")\n\n    if self.auto:\n        global default_components\n        default_components.add(reg_str)\n\n    component_registry[reg_str] = cls\n    cls.name = self.name\n    cls.type = self.type\n\n    return cls\n</code></pre>"},{"location":"reference/component/#component.register_component.__init__","title":"<code>__init__(name, type, *, auto=False)</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __init__(self, name: str, type: str, *, auto: bool = False) -&gt; None:\n    self.name = name\n    self.type = type\n    self.auto = auto\n</code></pre>"},{"location":"reference/config/","title":"config","text":"<p>This module contains all the settings for the system.</p>"},{"location":"reference/config/#config.config_settings","title":"<code>config_settings = {'env_prefix': 'roc_', 'env_file': '.env'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/config/#config.Config","title":"<code>Config</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>A Pydantic settings model for configuration of the agent.</p> Source code in <code>roc/config.py</code> <pre><code>class Config(BaseSettings):\n    \"\"\"A Pydantic settings model for configuration of the agent.\"\"\"\n\n    global config_settings\n    model_config = SettingsConfigDict(\n        # XXX: can't do **config_settings 'cause of TypedDict?\n        env_prefix=config_settings[\"env_prefix\"],\n        env_file=config_settings[\"env_file\"],\n        extra=\"forbid\",\n    )\n    # database config\n    db_host: str = Field(default=\"127.0.0.1\")\n    db_port: int = Field(default=7687)\n    db_conn_encrypted: bool = Field(default=False)\n    db_username: str = Field(default=\"\")\n    db_password: str = Field(default=\"\")\n    db_lazy: bool = Field(default=False)\n    db_strict_schema: bool = Field(default=True)\n    db_strict_schema_warns: bool = Field(default=False)\n    # graph config\n    node_cache_size: int = Field(default=2**30)\n    edge_cache_size: int = Field(default=2**30)\n    # log config\n    log_enable: bool = Field(default=True)\n    log_level: str = Field(default=\"INFO\")\n    log_modules: str = Field(default=\"\")\n    # agent config\n    gym_actions: tuple[int, ...] | None = Field(default=None)  # configured by the gym\n    observation_shape: tuple[int, ...] | None = Field(default=None)  # configured by the gym\n    allow_unknown_intrinsic: bool = Field(default=True)\n    # jupyter config\n    status_update: int = Field(default=50)\n    experiment_dir: str = Field(default=\"/home/apowers/experiment\")\n    data_dir: str = Field(default=\"/home/apowers/data\")\n    # gym config\n    num_games: int = Field(default=5)\n    enable_gym_dump_env: bool = Field(default=False)\n    dump_file: str = Field(default=f\"env_dump-{datetime.now().strftime('%Y.%m.%d-%H.%M.%S')}.py\")\n    max_dump_frames: int = Field(default=10)\n    # nethack config\n    nethack_extra_options: list[str] = [\"autoopen\"]\n    nethack_max_turns: int = Field(default=100000)\n    # experiment modules\n    expmod_dirs: list[str] = [\"experiments/modules\"]\n    expmods: list[str] = []\n    expmods_use: list[str] = [\"action:weighted\"]\n    # component config\n    perception_components: list[str] = Field(\n        default=[\n            \"delta:perception\",\n            \"distance:perception\",\n            \"flood:perception\",\n            \"motion:perception\",\n            \"single:perception\",\n            \"line:perception\",\n            \"color:perception\",\n            \"shape:perception\",\n        ]\n    )\n\n    def __str__(self) -&gt; str:\n        ret = \"\"\n        d = self.dict()\n        for k in d:\n            ret += f\"{k} = {str(d[k])}\\n\"\n\n        return ret\n\n    @staticmethod\n    def print() -&gt; None:\n        print(Config.get())  # noqa: T201\n\n    @staticmethod\n    def get() -&gt; Config:\n        \"\"\"Returns the config singleton, which is strongly typed and can be used to\n        get or set configuration settings.\n\n        Returns:\n            Config: The configuration for ROC.\n        \"\"\"\n        global _config_singleton\n        if _config_singleton is None:\n            warnings.warn(\n                \"Getting settings before config module was initialized. Please call init() first\",\n                ConfigInitWarning,\n            )\n            Config.init()\n            assert _config_singleton is not None\n        return _config_singleton\n\n    @staticmethod\n    def init(\n        config: dict[str, Any] | None = None,\n        *,\n        force: bool = False,\n        use_secrets: bool = True,\n    ) -&gt; None:\n        \"\"\"Initializes the settings by reading the configuration files and environment variables\"\"\"\n        global _config_singleton\n        initialized = _config_singleton is not None\n        if initialized and not force:\n            warnings.warn(\n                \"Config already initialized, returning existing configuration.\",\n                ConfigInitWarning,\n            )\n            return\n\n        passed_conf = config or {}\n        _config_singleton = Config(**passed_conf)\n\n    @staticmethod\n    def reset() -&gt; None:\n        \"\"\"Reset the configuration. Mostly used for testing.\"\"\"\n        global _config_singleton\n        _config_singleton = None\n</code></pre>"},{"location":"reference/config/#config.Config.allow_unknown_intrinsic","title":"<code>allow_unknown_intrinsic: bool = Field(default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.data_dir","title":"<code>data_dir: str = Field(default='/home/apowers/data')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_conn_encrypted","title":"<code>db_conn_encrypted: bool = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_host","title":"<code>db_host: str = Field(default='127.0.0.1')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_lazy","title":"<code>db_lazy: bool = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_password","title":"<code>db_password: str = Field(default='')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_port","title":"<code>db_port: int = Field(default=7687)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_strict_schema","title":"<code>db_strict_schema: bool = Field(default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_strict_schema_warns","title":"<code>db_strict_schema_warns: bool = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_username","title":"<code>db_username: str = Field(default='')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.dump_file","title":"<code>dump_file: str = Field(default=f'env_dump-{datetime.now().strftime('%Y.%m.%d-%H.%M.%S')}.py')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.edge_cache_size","title":"<code>edge_cache_size: int = Field(default=2 ** 30)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.enable_gym_dump_env","title":"<code>enable_gym_dump_env: bool = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.experiment_dir","title":"<code>experiment_dir: str = Field(default='/home/apowers/experiment')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.expmod_dirs","title":"<code>expmod_dirs: list[str] = ['experiments/modules']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.expmods","title":"<code>expmods: list[str] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.expmods_use","title":"<code>expmods_use: list[str] = ['action:weighted']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.gym_actions","title":"<code>gym_actions: tuple[int, ...] | None = Field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.log_enable","title":"<code>log_enable: bool = Field(default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.log_level","title":"<code>log_level: str = Field(default='INFO')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.log_modules","title":"<code>log_modules: str = Field(default='')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.max_dump_frames","title":"<code>max_dump_frames: int = Field(default=10)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.model_config","title":"<code>model_config = SettingsConfigDict(env_prefix=config_settings['env_prefix'], env_file=config_settings['env_file'], extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.nethack_extra_options","title":"<code>nethack_extra_options: list[str] = ['autoopen']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.nethack_max_turns","title":"<code>nethack_max_turns: int = Field(default=100000)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.node_cache_size","title":"<code>node_cache_size: int = Field(default=2 ** 30)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.num_games","title":"<code>num_games: int = Field(default=5)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.observation_shape","title":"<code>observation_shape: tuple[int, ...] | None = Field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.perception_components","title":"<code>perception_components: list[str] = Field(default=['delta:perception', 'distance:perception', 'flood:perception', 'motion:perception', 'single:perception', 'line:perception', 'color:perception', 'shape:perception'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.status_update","title":"<code>status_update: int = Field(default=50)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/config.py</code> <pre><code>def __str__(self) -&gt; str:\n    ret = \"\"\n    d = self.dict()\n    for k in d:\n        ret += f\"{k} = {str(d[k])}\\n\"\n\n    return ret\n</code></pre>"},{"location":"reference/config/#config.Config.get","title":"<code>get()</code>  <code>staticmethod</code>","text":"<p>Returns the config singleton, which is strongly typed and can be used to get or set configuration settings.</p> <p>Returns:</p> Name Type Description <code>Config</code> <code>Config</code> <p>The configuration for ROC.</p> Source code in <code>roc/config.py</code> <pre><code>@staticmethod\ndef get() -&gt; Config:\n    \"\"\"Returns the config singleton, which is strongly typed and can be used to\n    get or set configuration settings.\n\n    Returns:\n        Config: The configuration for ROC.\n    \"\"\"\n    global _config_singleton\n    if _config_singleton is None:\n        warnings.warn(\n            \"Getting settings before config module was initialized. Please call init() first\",\n            ConfigInitWarning,\n        )\n        Config.init()\n        assert _config_singleton is not None\n    return _config_singleton\n</code></pre>"},{"location":"reference/config/#config.Config.init","title":"<code>init(config=None, *, force=False, use_secrets=True)</code>  <code>staticmethod</code>","text":"<p>Initializes the settings by reading the configuration files and environment variables</p> Source code in <code>roc/config.py</code> <pre><code>@staticmethod\ndef init(\n    config: dict[str, Any] | None = None,\n    *,\n    force: bool = False,\n    use_secrets: bool = True,\n) -&gt; None:\n    \"\"\"Initializes the settings by reading the configuration files and environment variables\"\"\"\n    global _config_singleton\n    initialized = _config_singleton is not None\n    if initialized and not force:\n        warnings.warn(\n            \"Config already initialized, returning existing configuration.\",\n            ConfigInitWarning,\n        )\n        return\n\n    passed_conf = config or {}\n    _config_singleton = Config(**passed_conf)\n</code></pre>"},{"location":"reference/config/#config.Config.print","title":"<code>print()</code>  <code>staticmethod</code>","text":"Source code in <code>roc/config.py</code> <pre><code>@staticmethod\ndef print() -&gt; None:\n    print(Config.get())  # noqa: T201\n</code></pre>"},{"location":"reference/config/#config.Config.reset","title":"<code>reset()</code>  <code>staticmethod</code>","text":"<p>Reset the configuration. Mostly used for testing.</p> Source code in <code>roc/config.py</code> <pre><code>@staticmethod\ndef reset() -&gt; None:\n    \"\"\"Reset the configuration. Mostly used for testing.\"\"\"\n    global _config_singleton\n    _config_singleton = None\n</code></pre>"},{"location":"reference/config/#config.ConfigInitWarning","title":"<code>ConfigInitWarning</code>","text":"<p>               Bases: <code>Warning</code></p> <p>A Warning for when attempting to access config before it has been initialized.</p> Source code in <code>roc/config.py</code> <pre><code>class ConfigInitWarning(Warning):\n    \"\"\"A Warning for when attempting to access config before it has been initialized.\"\"\"\n</code></pre>"},{"location":"reference/event/","title":"event","text":"<p>This module defines all the communications and eventing interfaces for the system.</p>"},{"location":"reference/event/#event.EventData","title":"<code>EventData = TypeVar('EventData')</code>  <code>module-attribute</code>","text":""},{"location":"reference/event/#event.EventFilter","title":"<code>EventFilter = Callable[[Event[EventData]], bool]</code>  <code>module-attribute</code>","text":""},{"location":"reference/event/#event.EventListener","title":"<code>EventListener = Callable[[Event[EventData]], None]</code>  <code>module-attribute</code>","text":""},{"location":"reference/event/#event.eventbus_names","title":"<code>eventbus_names: set[str] = set()</code>  <code>module-attribute</code>","text":""},{"location":"reference/event/#event.BusConnection","title":"<code>BusConnection</code>","text":"<p>               Bases: <code>Generic[EventData]</code></p> <p>A connection between an EventBus and a Component, used to send Events</p> <p>Parameters:</p> Name Type Description Default <code>Generic</code> <code>EventData</code> <p>The data type that will be sent over this connection</p> required Source code in <code>roc/event.py</code> <pre><code>class BusConnection(Generic[EventData]):\n    \"\"\"A connection between an EventBus and a Component, used to send Events\n\n    Args:\n        Generic (EventData): The data type that will be sent over this connection\n    \"\"\"\n\n    def __init__(self, bus: EventBus[EventData], component: Component):\n        logger.debug(f\"{component.name}:{component.type} attaching to bus {bus.name}\")\n        self.attached_bus = bus\n        self.attached_component = component\n        self.subject: rx.Subject[Event[EventData]] = self.attached_bus.subject\n        self.subscribers: list[Disposable] = []\n\n    def send(self, data: EventData) -&gt; None:\n        \"\"\"Send data over the EventBus. Internally, the data is converted to an Event\n        with the relevant data (such as the source Component).\n\n        Args:\n            data (EventData): The data type of the data to be sent\n        \"\"\"\n        e = Event[EventData](data, self.attached_component.id, self.attached_bus)\n        logger.trace(f\"&gt;&gt;&gt; Sending {e}\")\n        self.attached_bus.subject.on_next(e)\n\n    def listen(\n        self,\n        listener: EventListener[EventData],\n        *,\n        filter: EventFilter[EventData] | None = None,\n    ) -&gt; None:\n        pipe_args: list[Callable[[Any], Observable[Event[EventData]]]] = [\n            # op.filter(lambda e: e.src is not self.attached_component),\n            # op.do_action(lambda e: print(\"before filter\", e)),\n            op.filter(self.attached_component.event_filter),\n        ]\n        if filter is not None:\n            pipe_args.append(op.filter(filter))\n\n        sub = self.subject.pipe(*pipe_args).subscribe(listener)\n        self.subscribers.append(sub)\n\n    def close(self) -&gt; None:\n        logger.debug(\n            f\"Closing connection from component {self.attached_component.id}  -&gt; {self.attached_bus.name} bus\"\n        )\n\n        for sub in self.subscribers:\n            sub.dispose()\n</code></pre>"},{"location":"reference/event/#event.BusConnection.attached_bus","title":"<code>attached_bus = bus</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.BusConnection.attached_component","title":"<code>attached_component = component</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.BusConnection.subject","title":"<code>subject: rx.Subject[Event[EventData]] = self.attached_bus.subject</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.BusConnection.subscribers","title":"<code>subscribers: list[Disposable] = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.BusConnection.__init__","title":"<code>__init__(bus, component)</code>","text":"Source code in <code>roc/event.py</code> <pre><code>def __init__(self, bus: EventBus[EventData], component: Component):\n    logger.debug(f\"{component.name}:{component.type} attaching to bus {bus.name}\")\n    self.attached_bus = bus\n    self.attached_component = component\n    self.subject: rx.Subject[Event[EventData]] = self.attached_bus.subject\n    self.subscribers: list[Disposable] = []\n</code></pre>"},{"location":"reference/event/#event.BusConnection.close","title":"<code>close()</code>","text":"Source code in <code>roc/event.py</code> <pre><code>def close(self) -&gt; None:\n    logger.debug(\n        f\"Closing connection from component {self.attached_component.id}  -&gt; {self.attached_bus.name} bus\"\n    )\n\n    for sub in self.subscribers:\n        sub.dispose()\n</code></pre>"},{"location":"reference/event/#event.BusConnection.listen","title":"<code>listen(listener, *, filter=None)</code>","text":"Source code in <code>roc/event.py</code> <pre><code>def listen(\n    self,\n    listener: EventListener[EventData],\n    *,\n    filter: EventFilter[EventData] | None = None,\n) -&gt; None:\n    pipe_args: list[Callable[[Any], Observable[Event[EventData]]]] = [\n        # op.filter(lambda e: e.src is not self.attached_component),\n        # op.do_action(lambda e: print(\"before filter\", e)),\n        op.filter(self.attached_component.event_filter),\n    ]\n    if filter is not None:\n        pipe_args.append(op.filter(filter))\n\n    sub = self.subject.pipe(*pipe_args).subscribe(listener)\n    self.subscribers.append(sub)\n</code></pre>"},{"location":"reference/event/#event.BusConnection.send","title":"<code>send(data)</code>","text":"<p>Send data over the EventBus. Internally, the data is converted to an Event with the relevant data (such as the source Component).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>EventData</code> <p>The data type of the data to be sent</p> required Source code in <code>roc/event.py</code> <pre><code>def send(self, data: EventData) -&gt; None:\n    \"\"\"Send data over the EventBus. Internally, the data is converted to an Event\n    with the relevant data (such as the source Component).\n\n    Args:\n        data (EventData): The data type of the data to be sent\n    \"\"\"\n    e = Event[EventData](data, self.attached_component.id, self.attached_bus)\n    logger.trace(f\"&gt;&gt;&gt; Sending {e}\")\n    self.attached_bus.subject.on_next(e)\n</code></pre>"},{"location":"reference/event/#event.Event","title":"<code>Event</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[EventData]</code></p> <p>An abstract event class for sending messages between Components over an EventBus</p> <p>Parameters:</p> Name Type Description Default <code>ABC</code> <code>ABC</code> <p>Abstract base class</p> required <code>Generic</code> <code>EventData</code> <p>The data to be carried by the event</p> required Source code in <code>roc/event.py</code> <pre><code>class Event(ABC, Generic[EventData]):\n    \"\"\"An abstract event class for sending messages between Components over an EventBus\n\n    Args:\n        ABC (ABC): Abstract base class\n        Generic (EventData): The data to be carried by the event\n    \"\"\"\n\n    def __init__(self, data: EventData, src_id: ComponentId, bus: EventBus[EventData]):\n        \"\"\"The initializer for the Event\n\n        Args:\n            data (EventData): The data for this event\n            src_id (ComponentId): The name and type of the Component sending the event\n            bus (EventBus): The EventBus that the event is being sent over\n        \"\"\"\n        self.data = data\n        self.src_id = src_id\n        self.bus = bus\n\n    def __repr__(self) -&gt; str:\n        data_str = pretty_repr(\n            self.data,\n            # max_depth=4, # Maximum depth of nested data structure\n            max_length=5,  # Maximum length of containers before abbreviating\n            max_string=60,  # Maximum length of string before truncating\n            expand_all=False,  # Expand all containers regardless of available width\n            max_width=120,\n        )\n        if \"\\n\" in data_str:\n            data_str = \"\\n\" + data_str\n        return f\"[EVENT: {self.src_id} &gt;&gt;&gt; {self.bus.name}]: {data_str}\"\n</code></pre>"},{"location":"reference/event/#event.Event.bus","title":"<code>bus = bus</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.Event.data","title":"<code>data = data</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.Event.src_id","title":"<code>src_id = src_id</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.Event.__init__","title":"<code>__init__(data, src_id, bus)</code>","text":"<p>The initializer for the Event</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>EventData</code> <p>The data for this event</p> required <code>src_id</code> <code>ComponentId</code> <p>The name and type of the Component sending the event</p> required <code>bus</code> <code>EventBus</code> <p>The EventBus that the event is being sent over</p> required Source code in <code>roc/event.py</code> <pre><code>def __init__(self, data: EventData, src_id: ComponentId, bus: EventBus[EventData]):\n    \"\"\"The initializer for the Event\n\n    Args:\n        data (EventData): The data for this event\n        src_id (ComponentId): The name and type of the Component sending the event\n        bus (EventBus): The EventBus that the event is being sent over\n    \"\"\"\n    self.data = data\n    self.src_id = src_id\n    self.bus = bus\n</code></pre>"},{"location":"reference/event/#event.Event.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>roc/event.py</code> <pre><code>def __repr__(self) -&gt; str:\n    data_str = pretty_repr(\n        self.data,\n        # max_depth=4, # Maximum depth of nested data structure\n        max_length=5,  # Maximum length of containers before abbreviating\n        max_string=60,  # Maximum length of string before truncating\n        expand_all=False,  # Expand all containers regardless of available width\n        max_width=120,\n    )\n    if \"\\n\" in data_str:\n        data_str = \"\\n\" + data_str\n    return f\"[EVENT: {self.src_id} &gt;&gt;&gt; {self.bus.name}]: {data_str}\"\n</code></pre>"},{"location":"reference/event/#event.EventBus","title":"<code>EventBus</code>","text":"<p>               Bases: <code>Generic[EventData]</code></p> <p>A communication channel for sending events between Components</p> <p>Parameters:</p> Name Type Description Default <code>Generic</code> <code>EventData</code> <p>The data type that is allowed to be sent over the bus</p> required Source code in <code>roc/event.py</code> <pre><code>class EventBus(Generic[EventData]):\n    \"\"\"A communication channel for sending events between Components\n\n    Args:\n        Generic (EventData): The data type that is allowed to be sent over the bus\n    \"\"\"\n\n    name: str\n    \"\"\"The name of the bus. Used to ensure uniqueness.\"\"\"\n    subject: rx.Subject[Event[EventData]]\n    \"\"\"The RxPy Subject that the bus uses to communicate.\"\"\"\n\n    def __init__(self, name: str, cache_depth: int = 0) -&gt; None:\n        if name in eventbus_names:\n            raise Exception(f\"Duplicate EventBus name: {name}\")\n        self.name = name\n        eventbus_names.add(name)\n        self.subject = rx.Subject[Event[EventData]]()\n        self.cache_depth = cache_depth\n        self.cache: deque[Event[EventData]] | None = None\n\n        if cache_depth &gt; 0:\n            self.cache = deque(maxlen=cache_depth)\n            self.subject.subscribe(lambda e: self.cache.append(e))  # type: ignore\n\n    def connect(self, component: Component) -&gt; BusConnection[EventData]:\n        \"\"\"Creates a connection between an EventBus and a Component for sending Events\n\n        Args:\n            component (Component): The Component to connect to the bus\n\n        Returns:\n            BusConnection[EventData]: A new connection that can be used to send data\n        \"\"\"\n        return BusConnection[EventData](self, component)\n\n    @staticmethod\n    def clear_names() -&gt; None:\n        \"\"\"Clears all EventBusses that have been registered, mostly used for testing.\"\"\"\n        eventbus_names.clear()\n</code></pre>"},{"location":"reference/event/#event.EventBus.cache","title":"<code>cache: deque[Event[EventData]] | None = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.EventBus.cache_depth","title":"<code>cache_depth = cache_depth</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.EventBus.name","title":"<code>name: str = name</code>  <code>instance-attribute</code>","text":"<p>The name of the bus. Used to ensure uniqueness.</p>"},{"location":"reference/event/#event.EventBus.subject","title":"<code>subject: rx.Subject[Event[EventData]] = rx.Subject[Event[EventData]]()</code>  <code>instance-attribute</code>","text":"<p>The RxPy Subject that the bus uses to communicate.</p>"},{"location":"reference/event/#event.EventBus.__init__","title":"<code>__init__(name, cache_depth=0)</code>","text":"Source code in <code>roc/event.py</code> <pre><code>def __init__(self, name: str, cache_depth: int = 0) -&gt; None:\n    if name in eventbus_names:\n        raise Exception(f\"Duplicate EventBus name: {name}\")\n    self.name = name\n    eventbus_names.add(name)\n    self.subject = rx.Subject[Event[EventData]]()\n    self.cache_depth = cache_depth\n    self.cache: deque[Event[EventData]] | None = None\n\n    if cache_depth &gt; 0:\n        self.cache = deque(maxlen=cache_depth)\n        self.subject.subscribe(lambda e: self.cache.append(e))  # type: ignore\n</code></pre>"},{"location":"reference/event/#event.EventBus.clear_names","title":"<code>clear_names()</code>  <code>staticmethod</code>","text":"<p>Clears all EventBusses that have been registered, mostly used for testing.</p> Source code in <code>roc/event.py</code> <pre><code>@staticmethod\ndef clear_names() -&gt; None:\n    \"\"\"Clears all EventBusses that have been registered, mostly used for testing.\"\"\"\n    eventbus_names.clear()\n</code></pre>"},{"location":"reference/event/#event.EventBus.connect","title":"<code>connect(component)</code>","text":"<p>Creates a connection between an EventBus and a Component for sending Events</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>Component</code> <p>The Component to connect to the bus</p> required <p>Returns:</p> Type Description <code>BusConnection[EventData]</code> <p>BusConnection[EventData]: A new connection that can be used to send data</p> Source code in <code>roc/event.py</code> <pre><code>def connect(self, component: Component) -&gt; BusConnection[EventData]:\n    \"\"\"Creates a connection between an EventBus and a Component for sending Events\n\n    Args:\n        component (Component): The Component to connect to the bus\n\n    Returns:\n        BusConnection[EventData]: A new connection that can be used to send data\n    \"\"\"\n    return BusConnection[EventData](self, component)\n</code></pre>"},{"location":"reference/expmod/","title":"expmod","text":""},{"location":"reference/expmod/#expmod.expmod_loaded","title":"<code>expmod_loaded: dict[str, ModuleType] = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/expmod/#expmod.expmod_modtype_current","title":"<code>expmod_modtype_current: dict[str, str | None] = defaultdict(lambda: None)</code>  <code>module-attribute</code>","text":""},{"location":"reference/expmod/#expmod.expmod_registry","title":"<code>expmod_registry: dict[str, dict[str, ExpMod]] = defaultdict(dict)</code>  <code>module-attribute</code>","text":""},{"location":"reference/expmod/#expmod.DefaultActionExpMod","title":"<code>DefaultActionExpMod</code>","text":"<p>               Bases: <code>ExpMod</code></p> Source code in <code>roc/expmod.py</code> <pre><code>class DefaultActionExpMod(ExpMod):\n    modtype = \"action\"\n\n    @abstractmethod\n    def get_action(self) -&gt; int: ...\n</code></pre>"},{"location":"reference/expmod/#expmod.DefaultActionExpMod.modtype","title":"<code>modtype = 'action'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/expmod/#expmod.DefaultActionExpMod.get_action","title":"<code>get_action()</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/expmod.py</code> <pre><code>@abstractmethod\ndef get_action(self) -&gt; int: ...\n</code></pre>"},{"location":"reference/expmod/#expmod.ExpMod","title":"<code>ExpMod</code>","text":"Source code in <code>roc/expmod.py</code> <pre><code>class ExpMod:\n    modtype: str\n\n    def __init_subclass__(cls) -&gt; None:\n        if not hasattr(cls, \"modtype\"):\n            raise NotImplementedError(f\"{cls} must implement class attribute 'modtype'\")\n\n    @staticmethod\n    def register(name: str) -&gt; Callable[[type[ExpMod]], type[ExpMod]]:\n        def register_decorator(cls: type[ExpMod]) -&gt; type[ExpMod]:\n            if name in expmod_registry[cls.modtype]:\n                raise Exception(\n                    f\"ExpMod.register attempting to register duplicate name '{name}' for module '{cls.modtype}'\"\n                )\n            expmod_registry[cls.modtype][name] = cls()\n\n            return cls\n\n        return register_decorator\n\n    @classmethod\n    def get(cls, default: str | None = None) -&gt; Self:\n        modtype = cls.modtype\n        name: str | None = (\n            expmod_modtype_current[modtype]\n            if expmod_modtype_current[modtype] is not None\n            else default\n        )\n        if name is None:\n            raise Exception(f\"ExpMod couldn't get module for type: '{modtype}'\")\n\n        return cast(Self, expmod_registry[modtype][name])\n\n    @classmethod\n    def set(cls, name: str, modtype: str | None = None) -&gt; None:\n        if modtype is None:\n            modtype = cls.modtype\n\n        if modtype not in expmod_registry:\n            raise Exception(f\"ExpMod.set can't find module for type: '{modtype}'\")\n\n        if name not in expmod_registry[modtype]:\n            raise Exception(\n                f\"ExpMod.set can't find module for name: '{name}' in module '{modtype}'\"\n            )\n\n        expmod_modtype_current[modtype] = name\n\n    @staticmethod\n    def import_file(filename: str, basepath: str = \"\") -&gt; ModuleType:\n        module_name = f\"roc:expmod:{filename}\"\n        filepath = Path(basepath) / filename\n\n        spec = importlib.util.spec_from_file_location(module_name, filepath)\n        assert spec is not None\n        assert spec.loader is not None\n\n        module = importlib.util.module_from_spec(spec)\n        sys.modules[module_name] = module\n        spec.loader.exec_module(module)\n\n        return module\n\n    @staticmethod\n    def init() -&gt; None:\n        settings = Config.get()\n\n        mods = settings.expmods.copy()\n        basepaths = settings.expmod_dirs.copy()\n        basepaths.insert(0, \"\")\n\n        # load module files\n        missing_mods: list[str] = []\n        for base in basepaths:\n            for mod in mods:\n                file = mod if mod.endswith(\".py\") else mod + \".py\"\n                try:\n                    expmod_loaded[mod] = ExpMod.import_file(file, base)\n                except FileNotFoundError:\n                    missing_mods.append(mod)\n            mods = missing_mods.copy()\n            missing_mods.clear()\n\n        if len(mods) &gt; 0:\n            raise FileNotFoundError(f\"could not load experiment modules: {mods}\")\n\n        # set modules\n        use_mods = [m.split(\":\") for m in settings.expmods_use]\n        mod_name_count = Counter([m[0] for m in use_mods])\n        duplicate_names = {k: v for k, v in mod_name_count.items() if v &gt; 1}\n        if len(duplicate_names) &gt; 0:\n            dupes = \", \".join(duplicate_names.keys())\n            raise Exception(f\"ExpMod.init found multiple attempts to set the same modules: {dupes}\")\n\n        for mod_tn in use_mods:\n            t, n = mod_tn\n            ExpMod.set(name=n, modtype=t)\n</code></pre>"},{"location":"reference/expmod/#expmod.ExpMod.modtype","title":"<code>modtype: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/expmod/#expmod.ExpMod.__init_subclass__","title":"<code>__init_subclass__()</code>","text":"Source code in <code>roc/expmod.py</code> <pre><code>def __init_subclass__(cls) -&gt; None:\n    if not hasattr(cls, \"modtype\"):\n        raise NotImplementedError(f\"{cls} must implement class attribute 'modtype'\")\n</code></pre>"},{"location":"reference/expmod/#expmod.ExpMod.get","title":"<code>get(default=None)</code>  <code>classmethod</code>","text":"Source code in <code>roc/expmod.py</code> <pre><code>@classmethod\ndef get(cls, default: str | None = None) -&gt; Self:\n    modtype = cls.modtype\n    name: str | None = (\n        expmod_modtype_current[modtype]\n        if expmod_modtype_current[modtype] is not None\n        else default\n    )\n    if name is None:\n        raise Exception(f\"ExpMod couldn't get module for type: '{modtype}'\")\n\n    return cast(Self, expmod_registry[modtype][name])\n</code></pre>"},{"location":"reference/expmod/#expmod.ExpMod.import_file","title":"<code>import_file(filename, basepath='')</code>  <code>staticmethod</code>","text":"Source code in <code>roc/expmod.py</code> <pre><code>@staticmethod\ndef import_file(filename: str, basepath: str = \"\") -&gt; ModuleType:\n    module_name = f\"roc:expmod:{filename}\"\n    filepath = Path(basepath) / filename\n\n    spec = importlib.util.spec_from_file_location(module_name, filepath)\n    assert spec is not None\n    assert spec.loader is not None\n\n    module = importlib.util.module_from_spec(spec)\n    sys.modules[module_name] = module\n    spec.loader.exec_module(module)\n\n    return module\n</code></pre>"},{"location":"reference/expmod/#expmod.ExpMod.init","title":"<code>init()</code>  <code>staticmethod</code>","text":"Source code in <code>roc/expmod.py</code> <pre><code>@staticmethod\ndef init() -&gt; None:\n    settings = Config.get()\n\n    mods = settings.expmods.copy()\n    basepaths = settings.expmod_dirs.copy()\n    basepaths.insert(0, \"\")\n\n    # load module files\n    missing_mods: list[str] = []\n    for base in basepaths:\n        for mod in mods:\n            file = mod if mod.endswith(\".py\") else mod + \".py\"\n            try:\n                expmod_loaded[mod] = ExpMod.import_file(file, base)\n            except FileNotFoundError:\n                missing_mods.append(mod)\n        mods = missing_mods.copy()\n        missing_mods.clear()\n\n    if len(mods) &gt; 0:\n        raise FileNotFoundError(f\"could not load experiment modules: {mods}\")\n\n    # set modules\n    use_mods = [m.split(\":\") for m in settings.expmods_use]\n    mod_name_count = Counter([m[0] for m in use_mods])\n    duplicate_names = {k: v for k, v in mod_name_count.items() if v &gt; 1}\n    if len(duplicate_names) &gt; 0:\n        dupes = \", \".join(duplicate_names.keys())\n        raise Exception(f\"ExpMod.init found multiple attempts to set the same modules: {dupes}\")\n\n    for mod_tn in use_mods:\n        t, n = mod_tn\n        ExpMod.set(name=n, modtype=t)\n</code></pre>"},{"location":"reference/expmod/#expmod.ExpMod.register","title":"<code>register(name)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/expmod.py</code> <pre><code>@staticmethod\ndef register(name: str) -&gt; Callable[[type[ExpMod]], type[ExpMod]]:\n    def register_decorator(cls: type[ExpMod]) -&gt; type[ExpMod]:\n        if name in expmod_registry[cls.modtype]:\n            raise Exception(\n                f\"ExpMod.register attempting to register duplicate name '{name}' for module '{cls.modtype}'\"\n            )\n        expmod_registry[cls.modtype][name] = cls()\n\n        return cls\n\n    return register_decorator\n</code></pre>"},{"location":"reference/expmod/#expmod.ExpMod.set","title":"<code>set(name, modtype=None)</code>  <code>classmethod</code>","text":"Source code in <code>roc/expmod.py</code> <pre><code>@classmethod\ndef set(cls, name: str, modtype: str | None = None) -&gt; None:\n    if modtype is None:\n        modtype = cls.modtype\n\n    if modtype not in expmod_registry:\n        raise Exception(f\"ExpMod.set can't find module for type: '{modtype}'\")\n\n    if name not in expmod_registry[modtype]:\n        raise Exception(\n            f\"ExpMod.set can't find module for name: '{name}' in module '{modtype}'\"\n        )\n\n    expmod_modtype_current[modtype] = name\n</code></pre>"},{"location":"reference/graphdb/","title":"graphdb","text":"<p>This module is a wrapper around a graph database and abstracts away all the database-specific features as various classes (GraphDB, Node, Edge, etc)</p>"},{"location":"reference/graphdb/#graphdb.CacheDefault","title":"<code>CacheDefault = TypeVar('CacheDefault')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.CacheId","title":"<code>CacheId = TypeVar('CacheId')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.CacheKey","title":"<code>CacheKey = TypeVar('CacheKey')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.CacheType","title":"<code>CacheType = TypeVar('CacheType')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.CacheValue","title":"<code>CacheValue = TypeVar('CacheValue')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeCache","title":"<code>EdgeCache = GraphCache[EdgeId, Edge]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeCallbackFn","title":"<code>EdgeCallbackFn = Callable[[Edge], None]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeConnectionsList","title":"<code>EdgeConnectionsList = Iterable[tuple[str, str]]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeFilterFn","title":"<code>EdgeFilterFn = Callable[[Edge], TypeGuard[Edge]]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeId","title":"<code>EdgeId = NewType('EdgeId', int)</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeType","title":"<code>EdgeType = TypeVar('EdgeType', bound='Edge')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.NodeCache","title":"<code>NodeCache = GraphCache[NodeId, Node]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.NodeCallbackFn","title":"<code>NodeCallbackFn = Callable[[Node], None]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.NodeFilterFn","title":"<code>NodeFilterFn = Callable[[Node], bool]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.NodeId","title":"<code>NodeId = NewType('NodeId', int)</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.NodeType","title":"<code>NodeType = TypeVar('NodeType', bound='Node')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.ProgressFn","title":"<code>ProgressFn = Callable[[list[Node]], None]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.QueryParamType","title":"<code>QueryParamType = dict[str, Any]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.RecordFn","title":"<code>RecordFn = Callable[[str, Iterator[Any]], None]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.WalkMode","title":"<code>WalkMode = Literal['src', 'dst', 'both']</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.edge_cache","title":"<code>edge_cache: EdgeCache | None = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.edge_registry","title":"<code>edge_registry: dict[str, type[Edge]] = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.graph_db_singleton","title":"<code>graph_db_singleton: GraphDB | None = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.next_new_edge","title":"<code>next_new_edge: EdgeId = cast(EdgeId, -1)</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.next_new_node","title":"<code>next_new_node: NodeId = cast(NodeId, -1)</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.node_cache","title":"<code>node_cache: NodeCache | None = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.node_label_registry","title":"<code>node_label_registry: dict[frozenset[str], type[Node]] = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.node_registry","title":"<code>node_registry: dict[str, type[Node]] = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge","title":"<code>Edge</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An edge (a.k.a. Relationship or Connection) between two Nodes. An edge obect automatically implements all phases of CRUD in the underlying graph database. This is a directional relationship with a \"source\" and \"destination\". The source and destination properties are dynamically loaded through property getters when they are called, and may trigger a graph database query if they don't already exist in the edge cache.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class Edge(BaseModel, extra=\"allow\"):\n    \"\"\"An edge (a.k.a. Relationship or Connection) between two Nodes. An edge obect automatically\n    implements all phases of CRUD in the underlying graph database. This is a directional\n    relationship with a \"source\" and \"destination\". The source and destination properties\n    are dynamically loaded through property getters when they are called, and may trigger\n    a graph database query if they don't already exist in the edge cache.\n    \"\"\"\n\n    _id: EdgeId\n    type: str = Field(exclude=True)\n    src_id: NodeId = Field(exclude=True)\n    dst_id: NodeId = Field(exclude=True)\n    allowed_connections: EdgeConnectionsList | None = Field(exclude=True, default=None)\n    _no_save = False\n    _new = False\n    _deleted = False\n\n    @property\n    def id(self) -&gt; EdgeId:\n        return self._id\n\n    @property\n    def src(self) -&gt; Node:\n        return Node.get(self.src_id)\n\n    @property\n    def dst(self) -&gt; Node:\n        return Node.get(self.dst_id)\n\n    @property\n    def new(self) -&gt; bool:\n        return self._new\n\n    def __init__(\n        self,\n        **kwargs: Any,\n    ):\n        super().__init__(**kwargs)\n\n        # set passed-in values or their defaults\n        # self._db = kwargs[\"_db\"] if \"_db\" in kwargs else GraphDB.singleton()\n        self._id = kwargs[\"_id\"] if \"_id\" in kwargs else get_next_new_edge_id()\n\n        if self._id &lt; 0:\n            self._new = True\n            Edge.get_cache()[self.id] = self\n\n    def __del__(self) -&gt; None:\n        # print(\"Edge.__del__:\", self)\n        Edge.save(self)\n\n    def __repr__(self) -&gt; str:\n        return f\"Edge({self.id} [{self.src_id}&gt;&gt;{self.dst_id}])\"\n\n    def __init_subclass__(cls, *args: Any, **kwargs: Any) -&gt; None:\n        super().__init_subclass__(*args, **kwargs)\n\n        if not hasattr(cls, \"type\"):\n            cls.type = Field(exclude=True, default_factory=lambda: cls.__name__)\n            edgetype = cls.__name__\n        else:\n            # XXX: not sure why this makes mypy angry here but not in Node.__init_subclass__\n            if isinstance(cls.type, FieldInfo):  # type: ignore\n                edgetype = cls.type.get_default(call_default_factory=True)  # type: ignore\n            else:\n                edgetype = cls.type\n\n        if edgetype in edge_registry:\n            raise Exception(\n                f\"edge_register can't register type '{edgetype}' because it has already been registered\"\n            )\n\n        edge_registry[edgetype] = cls\n\n    @classmethod\n    def get_cache(self) -&gt; EdgeCache:\n        global edge_cache\n        if edge_cache is None:\n            settings = Config.get()\n            edge_cache = EdgeCache(maxsize=settings.edge_cache_size)\n\n        return edge_cache\n\n    @classmethod\n    def get(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Looks up an Edge based on it's ID. If the Edge is cached, the cached edge is returned;\n        otherwise the Edge is queried from the graph database based the ID provided and a new\n        Edge is returned and cached.\n\n        Args:\n            id (EdgeId): the unique identifier for the Edge\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: returns the Edge requested by the id\n        \"\"\"\n        cache = Edge.get_cache()\n        e = cache.get(id)\n        if not e:\n            e = cls.load(id, db=db)\n            cache[id] = e\n\n        return cast(Self, e)\n\n    @classmethod\n    def load(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Loads an Edge from the graph database without attempting to check if the Edge\n        already exists in the cache. Typically this is only called by Edge.get()\n\n        Args:\n            id (EdgeId): the unique identifier of the Edge to fetch\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            EdgeNotFound: if the specified ID does not exist in the cache or the database\n\n        Returns:\n            Self: returns the Edge requested by the id\n        \"\"\"\n        db = db or GraphDB.singleton()\n        edge_list = list(db.raw_fetch(f\"MATCH (n)-[e]-(m) WHERE id(e) = {id} RETURN e LIMIT 1\"))\n        if not len(edge_list) == 1:\n            raise EdgeNotFound(f\"Couldn't find edge ID: {id}\")\n\n        e = edge_list[0][\"e\"]\n        props = {}\n        if hasattr(e, \"properties\"):\n            props = e.properties\n        return cls(\n            src_id=e.start_id,\n            dst_id=e.end_id,\n            _id=id,\n            type=e.type,\n            **props,\n        )\n\n    @classmethod\n    def save(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Saves the edge to the database. Calls Edge.create if the edge is new, or Edge.update if\n        edge already exists in the database.\n\n        Args:\n            e (Self): The edge to save\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: The same edge that was passed in, for convenience. The Edge may be updated with a\n            new identifier if it was newly created in the database.\n        \"\"\"\n        if e._new:\n            return cls.create(e, db=db)\n        else:\n            return cls.update(e, db=db)\n\n    @classmethod\n    def create(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Creates a new edge in the database. Typically only called by Edge.save\n\n        Args:\n            e (Self): The edge to create\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            EdgeCreateFailed: Failed to write the edge to the database, for eample\n                if the ID is wrong.\n\n        Returns:\n            Self: the edge that was created, with an updated identifier and other chagned attributes\n        \"\"\"\n        if e._no_save or e.src._no_save or e.dst._no_save:\n            return e\n\n        db = db or GraphDB.singleton()\n        old_id = e.id\n\n        if e.src._new:\n            Node.save(e.src)\n\n        if e.dst._new:\n            Node.save(e.dst)\n\n        params = {\"props\": Edge.to_dict(e)}\n\n        ret = list(\n            db.raw_fetch(\n                f\"\"\"\n                MATCH (src), (dst)\n                WHERE id(src) = {e.src_id} AND id(dst) = {e.dst_id} \n                CREATE (src)-[e:{e.type} $props]-&gt;(dst)\n                RETURN id(e) as e_id\n                \"\"\",\n                params=params,\n            )\n        )\n\n        if len(ret) != 1:\n            raise EdgeCreateFailed(\"failed to create new edge\")\n\n        e._id = ret[0][\"e_id\"]\n        e._new = False\n        # update the cache; if being called during __del__ then the cache entry may not exist\n        try:\n            cache = Edge.get_cache()\n            del cache[old_id]\n            cache[e.id] = e\n        except KeyError:\n            pass\n        # update references to edge id\n        e.src.src_edges.replace(old_id, e.id)\n        e.dst.dst_edges.replace(old_id, e.id)\n\n        return e\n\n    @classmethod\n    def update(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Updates the edge in the database. Typically only called by Edge.save\n\n        Args:\n            e (Self): The edge to update\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: The same edge that was passed in, for convenience\n        \"\"\"\n        if e._no_save:\n            return e\n\n        db = db or GraphDB.singleton()\n\n        params = {\"props\": Edge.to_dict(e)}\n\n        db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} SET e = $props\", params=params)\n\n        return e\n\n    @classmethod\n    def connect(\n        cls,\n        src: Node | NodeId,\n        dst: Node | NodeId,\n        edgetype: str | None = None,\n        db: GraphDB | None = None,\n        **kwargs: Any,\n    ) -&gt; Self:\n        db = db or GraphDB.singleton()\n        src_id = Node.to_id(src)\n        dst_id = Node.to_id(dst)\n        src_node = Node.get(src_id, db=db)\n        dst_node = Node.get(dst_id, db=db)\n\n        clstype: str | None = None\n        # lookup class in based on specified type\n        if cls is Edge and edgetype in edge_registry:\n            cls = edge_registry[edgetype]  # type: ignore\n\n        # get type from class model\n        if cls is not Edge:\n            clstype = pydantic_get_default(cls, \"type\")\n\n        # no class found, use edge type instead\n        if clstype is None and edgetype is not None:\n            clstype = edgetype\n\n        # couldn't find any type\n        if clstype is None:\n            raise Exception(\"no Edge type provided\")\n\n        # check allowed_connections\n        check_schema(cls, clstype, src_node, dst_node, db)\n\n        e = cls(src_id=src_id, dst_id=dst_id, type=clstype, **kwargs)\n        src_node.src_edges.add(e)\n        dst_node.dst_edges.add(e)\n\n        return e\n\n    @staticmethod\n    def delete(e: Edge, *, db: GraphDB | None = None) -&gt; None:\n        \"\"\"Deletes the specified edge from the database. If the edge has not already been persisted\n        to the database, this marks the edge as deleted and returns.\n\n        Args:\n            e (Edge): The edge to delete\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n        \"\"\"\n        e._deleted = True\n        e._no_save = True\n        db = db or GraphDB.singleton()\n\n        # remove e from src and dst nodes\n        e.src.src_edges.discard(e)\n        e.dst.dst_edges.discard(e)\n\n        # remove from cache\n        edge_cache = Edge.get_cache()\n        if e.id in edge_cache:\n            del edge_cache[e.id]\n\n        # delete from db\n        if not e._new:\n            db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} DELETE e\")\n\n    @staticmethod\n    def to_dict(e: Edge, include_type: bool = False) -&gt; dict[str, Any]:\n        \"\"\"Convert a Edge to a Python dictionary\"\"\"\n        # XXX: the excluded fields below shouldn't have been included in the\n        # first place because Pythonic should exclude fields with underscores\n        ret = e.model_dump(exclude={\"_id\"})\n\n        if include_type and hasattr(e, \"type\"):\n            ret[\"type\"] = e.type\n        return ret\n\n    @staticmethod\n    def to_id(e: Edge | EdgeId) -&gt; EdgeId:\n        if isinstance(e, Edge):\n            return e.id\n        else:\n            return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.allowed_connections","title":"<code>allowed_connections: EdgeConnectionsList | None = Field(exclude=True, default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.dst","title":"<code>dst: Node</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.dst_id","title":"<code>dst_id: NodeId = Field(exclude=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.id","title":"<code>id: EdgeId</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.new","title":"<code>new: bool</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.src","title":"<code>src: Node</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.src_id","title":"<code>src_id: NodeId = Field(exclude=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.type","title":"<code>type: str = Field(exclude=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.__del__","title":"<code>__del__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __del__(self) -&gt; None:\n    # print(\"Edge.__del__:\", self)\n    Edge.save(self)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.__init__","title":"<code>__init__(**kwargs)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(\n    self,\n    **kwargs: Any,\n):\n    super().__init__(**kwargs)\n\n    # set passed-in values or their defaults\n    # self._db = kwargs[\"_db\"] if \"_db\" in kwargs else GraphDB.singleton()\n    self._id = kwargs[\"_id\"] if \"_id\" in kwargs else get_next_new_edge_id()\n\n    if self._id &lt; 0:\n        self._new = True\n        Edge.get_cache()[self.id] = self\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.__init_subclass__","title":"<code>__init_subclass__(*args, **kwargs)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init_subclass__(cls, *args: Any, **kwargs: Any) -&gt; None:\n    super().__init_subclass__(*args, **kwargs)\n\n    if not hasattr(cls, \"type\"):\n        cls.type = Field(exclude=True, default_factory=lambda: cls.__name__)\n        edgetype = cls.__name__\n    else:\n        # XXX: not sure why this makes mypy angry here but not in Node.__init_subclass__\n        if isinstance(cls.type, FieldInfo):  # type: ignore\n            edgetype = cls.type.get_default(call_default_factory=True)  # type: ignore\n        else:\n            edgetype = cls.type\n\n    if edgetype in edge_registry:\n        raise Exception(\n            f\"edge_register can't register type '{edgetype}' because it has already been registered\"\n        )\n\n    edge_registry[edgetype] = cls\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"Edge({self.id} [{self.src_id}&gt;&gt;{self.dst_id}])\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.connect","title":"<code>connect(src, dst, edgetype=None, db=None, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef connect(\n    cls,\n    src: Node | NodeId,\n    dst: Node | NodeId,\n    edgetype: str | None = None,\n    db: GraphDB | None = None,\n    **kwargs: Any,\n) -&gt; Self:\n    db = db or GraphDB.singleton()\n    src_id = Node.to_id(src)\n    dst_id = Node.to_id(dst)\n    src_node = Node.get(src_id, db=db)\n    dst_node = Node.get(dst_id, db=db)\n\n    clstype: str | None = None\n    # lookup class in based on specified type\n    if cls is Edge and edgetype in edge_registry:\n        cls = edge_registry[edgetype]  # type: ignore\n\n    # get type from class model\n    if cls is not Edge:\n        clstype = pydantic_get_default(cls, \"type\")\n\n    # no class found, use edge type instead\n    if clstype is None and edgetype is not None:\n        clstype = edgetype\n\n    # couldn't find any type\n    if clstype is None:\n        raise Exception(\"no Edge type provided\")\n\n    # check allowed_connections\n    check_schema(cls, clstype, src_node, dst_node, db)\n\n    e = cls(src_id=src_id, dst_id=dst_id, type=clstype, **kwargs)\n    src_node.src_edges.add(e)\n    dst_node.dst_edges.add(e)\n\n    return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.create","title":"<code>create(e, *, db=None)</code>  <code>classmethod</code>","text":"<p>Creates a new edge in the database. Typically only called by Edge.save</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Self</code> <p>The edge to create</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>EdgeCreateFailed</code> <p>Failed to write the edge to the database, for eample if the ID is wrong.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the edge that was created, with an updated identifier and other chagned attributes</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef create(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Creates a new edge in the database. Typically only called by Edge.save\n\n    Args:\n        e (Self): The edge to create\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        EdgeCreateFailed: Failed to write the edge to the database, for eample\n            if the ID is wrong.\n\n    Returns:\n        Self: the edge that was created, with an updated identifier and other chagned attributes\n    \"\"\"\n    if e._no_save or e.src._no_save or e.dst._no_save:\n        return e\n\n    db = db or GraphDB.singleton()\n    old_id = e.id\n\n    if e.src._new:\n        Node.save(e.src)\n\n    if e.dst._new:\n        Node.save(e.dst)\n\n    params = {\"props\": Edge.to_dict(e)}\n\n    ret = list(\n        db.raw_fetch(\n            f\"\"\"\n            MATCH (src), (dst)\n            WHERE id(src) = {e.src_id} AND id(dst) = {e.dst_id} \n            CREATE (src)-[e:{e.type} $props]-&gt;(dst)\n            RETURN id(e) as e_id\n            \"\"\",\n            params=params,\n        )\n    )\n\n    if len(ret) != 1:\n        raise EdgeCreateFailed(\"failed to create new edge\")\n\n    e._id = ret[0][\"e_id\"]\n    e._new = False\n    # update the cache; if being called during __del__ then the cache entry may not exist\n    try:\n        cache = Edge.get_cache()\n        del cache[old_id]\n        cache[e.id] = e\n    except KeyError:\n        pass\n    # update references to edge id\n    e.src.src_edges.replace(old_id, e.id)\n    e.dst.dst_edges.replace(old_id, e.id)\n\n    return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.delete","title":"<code>delete(e, *, db=None)</code>  <code>staticmethod</code>","text":"<p>Deletes the specified edge from the database. If the edge has not already been persisted to the database, this marks the edge as deleted and returns.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Edge</code> <p>The edge to delete</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef delete(e: Edge, *, db: GraphDB | None = None) -&gt; None:\n    \"\"\"Deletes the specified edge from the database. If the edge has not already been persisted\n    to the database, this marks the edge as deleted and returns.\n\n    Args:\n        e (Edge): The edge to delete\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n    \"\"\"\n    e._deleted = True\n    e._no_save = True\n    db = db or GraphDB.singleton()\n\n    # remove e from src and dst nodes\n    e.src.src_edges.discard(e)\n    e.dst.dst_edges.discard(e)\n\n    # remove from cache\n    edge_cache = Edge.get_cache()\n    if e.id in edge_cache:\n        del edge_cache[e.id]\n\n    # delete from db\n    if not e._new:\n        db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} DELETE e\")\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.get","title":"<code>get(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Looks up an Edge based on it's ID. If the Edge is cached, the cached edge is returned; otherwise the Edge is queried from the graph database based the ID provided and a new Edge is returned and cached.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>EdgeId</code> <p>the unique identifier for the Edge</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>returns the Edge requested by the id</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Looks up an Edge based on it's ID. If the Edge is cached, the cached edge is returned;\n    otherwise the Edge is queried from the graph database based the ID provided and a new\n    Edge is returned and cached.\n\n    Args:\n        id (EdgeId): the unique identifier for the Edge\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: returns the Edge requested by the id\n    \"\"\"\n    cache = Edge.get_cache()\n    e = cache.get(id)\n    if not e:\n        e = cls.load(id, db=db)\n        cache[id] = e\n\n    return cast(Self, e)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.get_cache","title":"<code>get_cache()</code>  <code>classmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get_cache(self) -&gt; EdgeCache:\n    global edge_cache\n    if edge_cache is None:\n        settings = Config.get()\n        edge_cache = EdgeCache(maxsize=settings.edge_cache_size)\n\n    return edge_cache\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.load","title":"<code>load(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Loads an Edge from the graph database without attempting to check if the Edge already exists in the cache. Typically this is only called by Edge.get()</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>EdgeId</code> <p>the unique identifier of the Edge to fetch</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>EdgeNotFound</code> <p>if the specified ID does not exist in the cache or the database</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>returns the Edge requested by the id</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef load(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Loads an Edge from the graph database without attempting to check if the Edge\n    already exists in the cache. Typically this is only called by Edge.get()\n\n    Args:\n        id (EdgeId): the unique identifier of the Edge to fetch\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        EdgeNotFound: if the specified ID does not exist in the cache or the database\n\n    Returns:\n        Self: returns the Edge requested by the id\n    \"\"\"\n    db = db or GraphDB.singleton()\n    edge_list = list(db.raw_fetch(f\"MATCH (n)-[e]-(m) WHERE id(e) = {id} RETURN e LIMIT 1\"))\n    if not len(edge_list) == 1:\n        raise EdgeNotFound(f\"Couldn't find edge ID: {id}\")\n\n    e = edge_list[0][\"e\"]\n    props = {}\n    if hasattr(e, \"properties\"):\n        props = e.properties\n    return cls(\n        src_id=e.start_id,\n        dst_id=e.end_id,\n        _id=id,\n        type=e.type,\n        **props,\n    )\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.save","title":"<code>save(e, *, db=None)</code>  <code>classmethod</code>","text":"<p>Saves the edge to the database. Calls Edge.create if the edge is new, or Edge.update if edge already exists in the database.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Self</code> <p>The edge to save</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The same edge that was passed in, for convenience. The Edge may be updated with a</p> <code>Self</code> <p>new identifier if it was newly created in the database.</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef save(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Saves the edge to the database. Calls Edge.create if the edge is new, or Edge.update if\n    edge already exists in the database.\n\n    Args:\n        e (Self): The edge to save\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: The same edge that was passed in, for convenience. The Edge may be updated with a\n        new identifier if it was newly created in the database.\n    \"\"\"\n    if e._new:\n        return cls.create(e, db=db)\n    else:\n        return cls.update(e, db=db)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.to_dict","title":"<code>to_dict(e, include_type=False)</code>  <code>staticmethod</code>","text":"<p>Convert a Edge to a Python dictionary</p> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef to_dict(e: Edge, include_type: bool = False) -&gt; dict[str, Any]:\n    \"\"\"Convert a Edge to a Python dictionary\"\"\"\n    # XXX: the excluded fields below shouldn't have been included in the\n    # first place because Pythonic should exclude fields with underscores\n    ret = e.model_dump(exclude={\"_id\"})\n\n    if include_type and hasattr(e, \"type\"):\n        ret[\"type\"] = e.type\n    return ret\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.to_id","title":"<code>to_id(e)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef to_id(e: Edge | EdgeId) -&gt; EdgeId:\n    if isinstance(e, Edge):\n        return e.id\n    else:\n        return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.update","title":"<code>update(e, *, db=None)</code>  <code>classmethod</code>","text":"<p>Updates the edge in the database. Typically only called by Edge.save</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Self</code> <p>The edge to update</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The same edge that was passed in, for convenience</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef update(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Updates the edge in the database. Typically only called by Edge.save\n\n    Args:\n        e (Self): The edge to update\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: The same edge that was passed in, for convenience\n    \"\"\"\n    if e._no_save:\n        return e\n\n    db = db or GraphDB.singleton()\n\n    params = {\"props\": Edge.to_dict(e)}\n\n    db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} SET e = $props\", params=params)\n\n    return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeCreateFailed","title":"<code>EdgeCreateFailed</code>","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeCreateFailed(Exception):\n    pass\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeDescription","title":"<code>EdgeDescription</code>","text":"<p>               Bases: <code>ModelDescription</code></p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeDescription(ModelDescription):\n    def __init__(self, edge_cls: type[Edge]) -&gt; None:\n        super().__init__(edge_cls)\n\n        self.edge_cls = edge_cls\n        self.name = edge_cls.__name__\n        self.edgetype = pydantic_get_default(edge_cls, \"type\")\n\n        # allowed connections\n        self.allowed_connections = cast(\n            EdgeConnectionsList, pydantic_get_default(edge_cls, \"allowed_connections\")\n        )\n        assert self.allowed_connections is not None\n\n        # related nodes\n        self.related_nodes: set[str] = set()\n        for conn in self.allowed_connections:\n            self.related_nodes.add(conn[0])\n            self.related_nodes.add(conn[1])\n\n    def __str__(self) -&gt; str:\n        return f\"EdgeDesc({self.name})\"\n\n    @property\n    def resolved_name(self) -&gt; str:\n        if self.edgetype == self.name:\n            return self.name\n\n        return f\"{self.edgetype} ({self.name})\"\n\n    def to_mermaid(self, indent: int = 4) -&gt; str:\n        ret = f\"\"\"\\n{' ':&gt;{indent}}%% Edge: {self.resolved_name}\\n\"\"\"\n\n        # add connections\n        for conn in self.allowed_connections:\n            ret += f\"\"\"{' ':&gt;{indent}}{conn[0]} --&gt; {conn[1]}: {self.resolved_name}\\n\"\"\"\n\n        return ret\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeDescription.allowed_connections","title":"<code>allowed_connections = cast(EdgeConnectionsList, pydantic_get_default(edge_cls, 'allowed_connections'))</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeDescription.edge_cls","title":"<code>edge_cls = edge_cls</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeDescription.edgetype","title":"<code>edgetype = pydantic_get_default(edge_cls, 'type')</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeDescription.name","title":"<code>name = edge_cls.__name__</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeDescription.related_nodes","title":"<code>related_nodes: set[str] = set()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeDescription.resolved_name","title":"<code>resolved_name: str</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeDescription.__init__","title":"<code>__init__(edge_cls)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, edge_cls: type[Edge]) -&gt; None:\n    super().__init__(edge_cls)\n\n    self.edge_cls = edge_cls\n    self.name = edge_cls.__name__\n    self.edgetype = pydantic_get_default(edge_cls, \"type\")\n\n    # allowed connections\n    self.allowed_connections = cast(\n        EdgeConnectionsList, pydantic_get_default(edge_cls, \"allowed_connections\")\n    )\n    assert self.allowed_connections is not None\n\n    # related nodes\n    self.related_nodes: set[str] = set()\n    for conn in self.allowed_connections:\n        self.related_nodes.add(conn[0])\n        self.related_nodes.add(conn[1])\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeDescription.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"EdgeDesc({self.name})\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeDescription.to_mermaid","title":"<code>to_mermaid(indent=4)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def to_mermaid(self, indent: int = 4) -&gt; str:\n    ret = f\"\"\"\\n{' ':&gt;{indent}}%% Edge: {self.resolved_name}\\n\"\"\"\n\n    # add connections\n    for conn in self.allowed_connections:\n        ret += f\"\"\"{' ':&gt;{indent}}{conn[0]} --&gt; {conn[1]}: {self.resolved_name}\\n\"\"\"\n\n    return ret\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator","title":"<code>EdgeFetchIterator</code>","text":"<p>The implementation of an iterator for an EdgeList. Only intended to be used internally by EdgeList.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeFetchIterator:\n    \"\"\"The implementation of an iterator for an EdgeList. Only intended to be used internally by\n    EdgeList.\n    \"\"\"\n\n    def __init__(self, edge_list: list[EdgeId]):\n        self.__edge_list = edge_list\n        self.cur = 0\n\n    def __iter__(self) -&gt; EdgeFetchIterator:\n        return self\n\n    def __next__(self) -&gt; Edge:\n        if self.cur &gt;= len(self.__edge_list):\n            raise StopIteration\n\n        id = self.__edge_list[self.cur]\n        self.cur = self.cur + 1\n        return Edge.get(id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator.__edge_list","title":"<code>__edge_list = edge_list</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator.cur","title":"<code>cur = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator.__init__","title":"<code>__init__(edge_list)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, edge_list: list[EdgeId]):\n    self.__edge_list = edge_list\n    self.cur = 0\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __iter__(self) -&gt; EdgeFetchIterator:\n    return self\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator.__next__","title":"<code>__next__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __next__(self) -&gt; Edge:\n    if self.cur &gt;= len(self.__edge_list):\n        raise StopIteration\n\n    id = self.__edge_list[self.cur]\n    self.cur = self.cur + 1\n    return Edge.get(id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList","title":"<code>EdgeList</code>","text":"<p>               Bases: <code>MutableSet[Edge | EdgeId]</code>, <code>Mapping[int, Edge]</code></p> <p>A list of Edges that is used by Node for keeping track of the connections it has. Implements interfaces for both a MutableSet (i.e. set()) and a Mapping (i.e. read-only list())</p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeList(MutableSet[Edge | EdgeId], Mapping[int, Edge]):\n    \"\"\"A list of Edges that is used by Node for keeping track of the connections it has.\n    Implements interfaces for both a MutableSet (i.e. set()) and a Mapping (i.e. read-only list())\n    \"\"\"\n\n    def __init__(self, ids: Iterable[EdgeId]):\n        self.__edges: list[EdgeId] = list(ids)\n\n    def __iter__(self) -&gt; EdgeFetchIterator:\n        return EdgeFetchIterator(self.__edges)\n\n    def __getitem__(self, key: int) -&gt; Edge:\n        return Edge.get(self.__edges[key])\n\n    def __len__(self) -&gt; int:\n        return len(self.__edges)\n\n    def __contains__(self, e: Any) -&gt; bool:\n        if isinstance(e, Edge) or isinstance(e, int):\n            e_id = Edge.to_id(e)  # type: ignore\n        else:\n            return False\n\n        return e_id in self.__edges\n\n    def __add__(self, l2: EdgeList) -&gt; EdgeList:\n        return EdgeList(self.__edges + l2.__edges)\n\n    def add(self, e: Edge | EdgeId) -&gt; None:\n        \"\"\"Adds a new Edge to the list\"\"\"\n        e_id = Edge.to_id(e)\n\n        if e_id in self.__edges:\n            return\n\n        self.__edges.append(e_id)\n\n    def discard(self, e: Edge | EdgeId) -&gt; None:\n        \"\"\"Removes an edge from the list\"\"\"\n        e_id = Edge.to_id(e)\n\n        self.__edges.remove(e_id)\n\n    def replace(self, old: Edge | EdgeId, new: Edge | EdgeId) -&gt; None:\n        \"\"\"Replaces all instances of an old Edge with a new Edge. Useful for when an Edge is\n        persisted to the graph database and its permanent ID is assigned\n        \"\"\"\n        old_id = Edge.to_id(old)\n        new_id = Edge.to_id(new)\n        for i in range(len(self.__edges)):\n            if self.__edges[i] == old_id:\n                self.__edges[i] = new_id\n\n    def select(\n        self,\n        *,\n        filter_fn: EdgeFilterFn | None = None,\n        type: str | None = None,\n        id: EdgeId | None = None,\n    ) -&gt; EdgeList:\n        edge_ids = self.__edges\n        if filter_fn is not None:\n            # TODO: Edge.get_many() would be more efficient here if / when it\n            # gets implemented\n            edge_ids = [e for e in edge_ids if filter_fn(Edge.get(e))]\n\n        if type is not None:\n            edge_ids = [e for e in edge_ids if Edge.get(e).type == type]\n\n        if id is not None:\n            edge_ids = [e for e in edge_ids if e == id]\n\n        return EdgeList(edge_ids)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__edges","title":"<code>__edges: list[EdgeId] = list(ids)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeList.__add__","title":"<code>__add__(l2)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __add__(self, l2: EdgeList) -&gt; EdgeList:\n    return EdgeList(self.__edges + l2.__edges)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__contains__","title":"<code>__contains__(e)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __contains__(self, e: Any) -&gt; bool:\n    if isinstance(e, Edge) or isinstance(e, int):\n        e_id = Edge.to_id(e)  # type: ignore\n    else:\n        return False\n\n    return e_id in self.__edges\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__getitem__","title":"<code>__getitem__(key)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __getitem__(self, key: int) -&gt; Edge:\n    return Edge.get(self.__edges[key])\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__init__","title":"<code>__init__(ids)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, ids: Iterable[EdgeId]):\n    self.__edges: list[EdgeId] = list(ids)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __iter__(self) -&gt; EdgeFetchIterator:\n    return EdgeFetchIterator(self.__edges)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__len__","title":"<code>__len__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.__edges)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.add","title":"<code>add(e)</code>","text":"<p>Adds a new Edge to the list</p> Source code in <code>roc/graphdb.py</code> <pre><code>def add(self, e: Edge | EdgeId) -&gt; None:\n    \"\"\"Adds a new Edge to the list\"\"\"\n    e_id = Edge.to_id(e)\n\n    if e_id in self.__edges:\n        return\n\n    self.__edges.append(e_id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.discard","title":"<code>discard(e)</code>","text":"<p>Removes an edge from the list</p> Source code in <code>roc/graphdb.py</code> <pre><code>def discard(self, e: Edge | EdgeId) -&gt; None:\n    \"\"\"Removes an edge from the list\"\"\"\n    e_id = Edge.to_id(e)\n\n    self.__edges.remove(e_id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.replace","title":"<code>replace(old, new)</code>","text":"<p>Replaces all instances of an old Edge with a new Edge. Useful for when an Edge is persisted to the graph database and its permanent ID is assigned</p> Source code in <code>roc/graphdb.py</code> <pre><code>def replace(self, old: Edge | EdgeId, new: Edge | EdgeId) -&gt; None:\n    \"\"\"Replaces all instances of an old Edge with a new Edge. Useful for when an Edge is\n    persisted to the graph database and its permanent ID is assigned\n    \"\"\"\n    old_id = Edge.to_id(old)\n    new_id = Edge.to_id(new)\n    for i in range(len(self.__edges)):\n        if self.__edges[i] == old_id:\n            self.__edges[i] = new_id\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.select","title":"<code>select(*, filter_fn=None, type=None, id=None)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def select(\n    self,\n    *,\n    filter_fn: EdgeFilterFn | None = None,\n    type: str | None = None,\n    id: EdgeId | None = None,\n) -&gt; EdgeList:\n    edge_ids = self.__edges\n    if filter_fn is not None:\n        # TODO: Edge.get_many() would be more efficient here if / when it\n        # gets implemented\n        edge_ids = [e for e in edge_ids if filter_fn(Edge.get(e))]\n\n    if type is not None:\n        edge_ids = [e for e in edge_ids if Edge.get(e).type == type]\n\n    if id is not None:\n        edge_ids = [e for e in edge_ids if e == id]\n\n    return EdgeList(edge_ids)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeNotFound","title":"<code>EdgeNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeNotFound(Exception):\n    pass\n</code></pre>"},{"location":"reference/graphdb/#graphdb.ErrorSavingDuringDelWarning","title":"<code>ErrorSavingDuringDelWarning</code>","text":"<p>               Bases: <code>Warning</code></p> <p>An error that occurs while saving a Node during del</p> Source code in <code>roc/graphdb.py</code> <pre><code>class ErrorSavingDuringDelWarning(Warning):\n    \"\"\"An error that occurs while saving a Node during __del__\"\"\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.FieldDescription","title":"<code>FieldDescription</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>class FieldDescription:\n    def __init__(self, model: type[BaseModel], fieldname: str) -&gt; None:\n        self.model = model\n        self.field_info = pydantic_get_field(model, fieldname)\n        self.name = fieldname\n        self.default_val = self.field_info.get_default(call_default_factory=True)\n        self.type = clean_annotation(self.field_info.annotation)\n        self.exclude = self.field_info.exclude\n\n    def __str__(self) -&gt; str:\n        return f\"Field({self.name}: {self.type} = {self.default_val})\"\n\n    @property\n    def default_val_str(self) -&gt; str:\n        \"\"\"Control over a reliable and reproducable default value for printing\n        the schema.\n        \"\"\"\n        if isinstance(self.default_val, set):\n            return str(sorted(self.default_val))\n\n        return str(self.default_val)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.FieldDescription.default_val","title":"<code>default_val = self.field_info.get_default(call_default_factory=True)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.FieldDescription.default_val_str","title":"<code>default_val_str: str</code>  <code>property</code>","text":"<p>Control over a reliable and reproducable default value for printing the schema.</p>"},{"location":"reference/graphdb/#graphdb.FieldDescription.exclude","title":"<code>exclude = self.field_info.exclude</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.FieldDescription.field_info","title":"<code>field_info = pydantic_get_field(model, fieldname)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.FieldDescription.model","title":"<code>model = model</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.FieldDescription.name","title":"<code>name = fieldname</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.FieldDescription.type","title":"<code>type = clean_annotation(self.field_info.annotation)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.FieldDescription.__init__","title":"<code>__init__(model, fieldname)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, model: type[BaseModel], fieldname: str) -&gt; None:\n    self.model = model\n    self.field_info = pydantic_get_field(model, fieldname)\n    self.name = fieldname\n    self.default_val = self.field_info.get_default(call_default_factory=True)\n    self.type = clean_annotation(self.field_info.annotation)\n    self.exclude = self.field_info.exclude\n</code></pre>"},{"location":"reference/graphdb/#graphdb.FieldDescription.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"Field({self.name}: {self.type} = {self.default_val})\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphCache","title":"<code>GraphCache</code>","text":"<p>               Bases: <code>LRUCache[CacheKey, CacheValue]</code>, <code>Generic[CacheKey, CacheValue]</code></p> <p>A generic cache that is used for both the Node cache and the Edge cache</p> Source code in <code>roc/graphdb.py</code> <pre><code>class GraphCache(LRUCache[CacheKey, CacheValue], Generic[CacheKey, CacheValue]):\n    \"\"\"A generic cache that is used for both the Node cache and the Edge cache\"\"\"\n\n    def __init__(self, maxsize: int):\n        super().__init__(maxsize=maxsize)\n        self.hits = 0\n        self.misses = 0\n\n    def __str__(self) -&gt; str:\n        return f\"Size: {self.currsize}/{self.maxsize} ({self.currsize/self.maxsize*100:1.2f}%), Hits: {self.hits}, Misses: {self.misses}\"\n\n    def get(  # type: ignore [override]\n        self,\n        key: CacheKey,\n        /,\n        default: CacheValue | None = None,\n    ) -&gt; CacheValue | None:\n        \"\"\"Uses the specified CacheKey to fetch an object from the cache.\n\n        Args:\n            key (CacheKey): The key to use to fetch the object\n            default (CacheValue | None, optional): If the object isn't found,\n                the default value to return. Defaults to None.\n\n        Returns:\n            CacheValue | None: The object from the cache, or None if not found.\n        \"\"\"\n        v = super().get(key)\n        if not v:\n            self.misses = self.misses + 1\n            if self.currsize == self.maxsize:\n                logger.warning(\n                    f\"Cache miss and cache is full ({self.currsize}/{self.maxsize}). Cache may start thrashing and performance may be impaired.\"\n                )\n        else:\n            self.hits = self.hits + 1\n        return v\n\n    def clear(self) -&gt; None:\n        \"\"\"Clears out all items from the cache and resets the cache\n        statistics\n        \"\"\"\n        super().clear()\n        self.hits = 0\n        self.misses = 0\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphCache.hits","title":"<code>hits = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphCache.misses","title":"<code>misses = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphCache.__init__","title":"<code>__init__(maxsize)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, maxsize: int):\n    super().__init__(maxsize=maxsize)\n    self.hits = 0\n    self.misses = 0\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphCache.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"Size: {self.currsize}/{self.maxsize} ({self.currsize/self.maxsize*100:1.2f}%), Hits: {self.hits}, Misses: {self.misses}\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphCache.clear","title":"<code>clear()</code>","text":"<p>Clears out all items from the cache and resets the cache statistics</p> Source code in <code>roc/graphdb.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clears out all items from the cache and resets the cache\n    statistics\n    \"\"\"\n    super().clear()\n    self.hits = 0\n    self.misses = 0\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphCache.get","title":"<code>get(key, /, default=None)</code>","text":"<p>Uses the specified CacheKey to fetch an object from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>CacheKey</code> <p>The key to use to fetch the object</p> required <code>default</code> <code>CacheValue | None</code> <p>If the object isn't found, the default value to return. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>CacheValue | None</code> <p>CacheValue | None: The object from the cache, or None if not found.</p> Source code in <code>roc/graphdb.py</code> <pre><code>def get(  # type: ignore [override]\n    self,\n    key: CacheKey,\n    /,\n    default: CacheValue | None = None,\n) -&gt; CacheValue | None:\n    \"\"\"Uses the specified CacheKey to fetch an object from the cache.\n\n    Args:\n        key (CacheKey): The key to use to fetch the object\n        default (CacheValue | None, optional): If the object isn't found,\n            the default value to return. Defaults to None.\n\n    Returns:\n        CacheValue | None: The object from the cache, or None if not found.\n    \"\"\"\n    v = super().get(key)\n    if not v:\n        self.misses = self.misses + 1\n        if self.currsize == self.maxsize:\n            logger.warning(\n                f\"Cache miss and cache is full ({self.currsize}/{self.maxsize}). Cache may start thrashing and performance may be impaired.\"\n            )\n    else:\n        self.hits = self.hits + 1\n    return v\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB","title":"<code>GraphDB</code>","text":"<p>A graph database singleton. Settings for the graph database come from the config module.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class GraphDB:\n    \"\"\"A graph database singleton. Settings for the graph database come from the config module.\"\"\"\n\n    def __init__(self) -&gt; None:\n        settings = Config.get()\n        self.host = settings.db_host\n        self.port = settings.db_port\n        self.encrypted = settings.db_conn_encrypted\n        self.username = settings.db_username\n        self.password = settings.db_password\n        self.lazy = settings.db_lazy\n        self.strict_schema = settings.db_strict_schema\n        self.strict_schema_warns = settings.db_strict_schema_warns\n        self.client_name = \"roc-graphdb-client\"\n        self.db_conn = self.connect()\n        self.closed = False\n\n        if self.strict_schema:\n            Schema.validate()\n\n    def raw_fetch(\n        self, query: str, *, params: dict[str, Any] | None = None\n    ) -&gt; Iterator[dict[str, Any]]:\n        \"\"\"Executes a Cypher query and returns the results as an iterator of\n        dictionaries. Used for any query that has a 'RETURN' clause.\n\n        Args:\n            query (str): The Cypher query to execute\n            params (dict[str, Any] | None, optional): Any parameters to pass to\n                the query. Defaults to None. See also: https://memgraph.com/docs/querying/expressions#parameters\n\n        Yields:\n            Iterator[dict[str, Any]]: An iterator of the results from the database.\n        \"\"\"\n        params = params or {}\n        logger.trace(f\"raw_fetch: '{query}' *** with params: *** '{params}\")\n\n        cursor = self.db_conn.cursor()\n        cursor.execute(query, params)\n        while True:\n            row = cursor.fetchone()\n            if row is None:\n                break\n            yield {dsc.name: row[index] for index, dsc in enumerate(cursor.description)}\n\n    def raw_execute(self, query: str, *, params: dict[str, Any] | None = None) -&gt; None:\n        \"\"\"Executes a query with no return value. Used for 'SET', 'DELETE' or\n        other queries without a 'RETURN' clause.\n\n        Args:\n            query (str): The Cypher query to execute\n            params (dict[str, Any] | None, optional): Any parameters to pass to\n                the query. Defaults to None. See also: https://memgraph.com/docs/querying/expressions#parameters\n        \"\"\"\n        params = params or {}\n        logger.trace(f\"raw_execute: '{query}' *** with params: *** '{params}'\")\n\n        cursor = self.db_conn.cursor()\n        cursor.execute(query, params)\n        cursor.fetchall()\n\n    def connected(self) -&gt; bool:\n        \"\"\"Returns True if the database is connected, False otherwise\"\"\"\n        return self.db_conn is not None and self.db_conn.status == mgclient.CONN_STATUS_READY\n\n    def connect(self) -&gt; mgclient.Connection:\n        \"\"\"Connects to the database and returns a Connection object\"\"\"\n        sslmode = mgclient.MG_SSLMODE_REQUIRE if self.encrypted else mgclient.MG_SSLMODE_DISABLE\n        connection = mgclient.connect(\n            host=self.host,\n            port=self.port,\n            username=self.username,\n            password=self.password,\n            sslmode=sslmode,\n            lazy=self.lazy,\n            client_name=self.client_name,\n        )\n        connection.autocommit = True\n        return connection\n\n    def close(self) -&gt; None:\n        \"\"\"Closes the connection to the database\"\"\"\n        self.db_conn.close()\n        self.closed = True\n\n    @classmethod\n    def singleton(cls) -&gt; GraphDB:\n        \"\"\"This returns a singleton object for the graph database. If the\n        singleton isn't created yet, it creates it.\n        \"\"\"\n        global graph_db_singleton\n        if not graph_db_singleton:\n            graph_db_singleton = GraphDB()\n\n        assert graph_db_singleton.closed is False\n        return graph_db_singleton\n\n    @staticmethod\n    def to_networkx(\n        db: GraphDB | None = None,\n        node_ids: set[NodeId] | None = None,\n        filter: NodeFilterFn | None = None,\n    ) -&gt; nx.DiGraph:\n        \"\"\"Converts the entire graph database (and local cache of objects) into\n        a NetworkX graph\n\n        Args:\n            db (GraphDB | None, optional): The database to convert to NetworkX.\n                Defaults to the GraphDB singleton if not specified.\n            node_ids (set[NodeId] | None, optional): The NodeIDs to add to the\n                NetworkX graph. Defaults to all IDs if not specified.\n            filter (NodeFilterFn | None, optional): A Node filter to filter out\n                nodes before adding them to the NetworkX graph. Also useful for a\n                callback that can be used for progress updates. Defaults to None.\n\n        Returns:\n            nx.DiGraph: _description_\n        \"\"\"\n        db = db or GraphDB.singleton()\n        node_ids = node_ids or Node.all_ids(db=db)\n        filter = filter or true_filter\n        G = nx.DiGraph()\n\n        def nx_add(n: Node) -&gt; None:\n            n_data = Node.to_dict(n, include_labels=True)\n\n            # TODO: this converts labels to a string, but maybe there's a better\n            # way to preserve the list so that it can be used for filtering in\n            # external programs\n            if \"labels\" in n_data and isinstance(n_data[\"labels\"], set):\n                n_data[\"labels\"] = \", \".join(n_data[\"labels\"])\n\n            G.add_node(n.id, **n_data)\n\n            for e in n.src_edges:\n                e_data = Edge.to_dict(e, include_type=True)\n                G.add_edge(e.src_id, e.dst_id, **e_data)\n\n        # iterate all specified node_ids, adding all of them to the nx graph\n        def nx_add_many(nodes: list[Node]) -&gt; None:\n            for n in nodes:\n                if filter(n):\n                    nx_add(n)\n\n        Node.get_many(node_ids, load_edges=True, progress_callback=nx_add_many)\n\n        return G\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.client_name","title":"<code>client_name = 'roc-graphdb-client'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.closed","title":"<code>closed = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.db_conn","title":"<code>db_conn = self.connect()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.encrypted","title":"<code>encrypted = settings.db_conn_encrypted</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.host","title":"<code>host = settings.db_host</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.lazy","title":"<code>lazy = settings.db_lazy</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.password","title":"<code>password = settings.db_password</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.port","title":"<code>port = settings.db_port</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.strict_schema","title":"<code>strict_schema = settings.db_strict_schema</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.strict_schema_warns","title":"<code>strict_schema_warns = settings.db_strict_schema_warns</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.username","title":"<code>username = settings.db_username</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self) -&gt; None:\n    settings = Config.get()\n    self.host = settings.db_host\n    self.port = settings.db_port\n    self.encrypted = settings.db_conn_encrypted\n    self.username = settings.db_username\n    self.password = settings.db_password\n    self.lazy = settings.db_lazy\n    self.strict_schema = settings.db_strict_schema\n    self.strict_schema_warns = settings.db_strict_schema_warns\n    self.client_name = \"roc-graphdb-client\"\n    self.db_conn = self.connect()\n    self.closed = False\n\n    if self.strict_schema:\n        Schema.validate()\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.close","title":"<code>close()</code>","text":"<p>Closes the connection to the database</p> Source code in <code>roc/graphdb.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Closes the connection to the database\"\"\"\n    self.db_conn.close()\n    self.closed = True\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.connect","title":"<code>connect()</code>","text":"<p>Connects to the database and returns a Connection object</p> Source code in <code>roc/graphdb.py</code> <pre><code>def connect(self) -&gt; mgclient.Connection:\n    \"\"\"Connects to the database and returns a Connection object\"\"\"\n    sslmode = mgclient.MG_SSLMODE_REQUIRE if self.encrypted else mgclient.MG_SSLMODE_DISABLE\n    connection = mgclient.connect(\n        host=self.host,\n        port=self.port,\n        username=self.username,\n        password=self.password,\n        sslmode=sslmode,\n        lazy=self.lazy,\n        client_name=self.client_name,\n    )\n    connection.autocommit = True\n    return connection\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.connected","title":"<code>connected()</code>","text":"<p>Returns True if the database is connected, False otherwise</p> Source code in <code>roc/graphdb.py</code> <pre><code>def connected(self) -&gt; bool:\n    \"\"\"Returns True if the database is connected, False otherwise\"\"\"\n    return self.db_conn is not None and self.db_conn.status == mgclient.CONN_STATUS_READY\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.raw_execute","title":"<code>raw_execute(query, *, params=None)</code>","text":"<p>Executes a query with no return value. Used for 'SET', 'DELETE' or other queries without a 'RETURN' clause.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The Cypher query to execute</p> required <code>params</code> <code>dict[str, Any] | None</code> <p>Any parameters to pass to the query. Defaults to None. See also: https://memgraph.com/docs/querying/expressions#parameters</p> <code>None</code> Source code in <code>roc/graphdb.py</code> <pre><code>def raw_execute(self, query: str, *, params: dict[str, Any] | None = None) -&gt; None:\n    \"\"\"Executes a query with no return value. Used for 'SET', 'DELETE' or\n    other queries without a 'RETURN' clause.\n\n    Args:\n        query (str): The Cypher query to execute\n        params (dict[str, Any] | None, optional): Any parameters to pass to\n            the query. Defaults to None. See also: https://memgraph.com/docs/querying/expressions#parameters\n    \"\"\"\n    params = params or {}\n    logger.trace(f\"raw_execute: '{query}' *** with params: *** '{params}'\")\n\n    cursor = self.db_conn.cursor()\n    cursor.execute(query, params)\n    cursor.fetchall()\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.raw_fetch","title":"<code>raw_fetch(query, *, params=None)</code>","text":"<p>Executes a Cypher query and returns the results as an iterator of dictionaries. Used for any query that has a 'RETURN' clause.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The Cypher query to execute</p> required <code>params</code> <code>dict[str, Any] | None</code> <p>Any parameters to pass to the query. Defaults to None. See also: https://memgraph.com/docs/querying/expressions#parameters</p> <code>None</code> <p>Yields:</p> Type Description <code>dict[str, Any]</code> <p>Iterator[dict[str, Any]]: An iterator of the results from the database.</p> Source code in <code>roc/graphdb.py</code> <pre><code>def raw_fetch(\n    self, query: str, *, params: dict[str, Any] | None = None\n) -&gt; Iterator[dict[str, Any]]:\n    \"\"\"Executes a Cypher query and returns the results as an iterator of\n    dictionaries. Used for any query that has a 'RETURN' clause.\n\n    Args:\n        query (str): The Cypher query to execute\n        params (dict[str, Any] | None, optional): Any parameters to pass to\n            the query. Defaults to None. See also: https://memgraph.com/docs/querying/expressions#parameters\n\n    Yields:\n        Iterator[dict[str, Any]]: An iterator of the results from the database.\n    \"\"\"\n    params = params or {}\n    logger.trace(f\"raw_fetch: '{query}' *** with params: *** '{params}\")\n\n    cursor = self.db_conn.cursor()\n    cursor.execute(query, params)\n    while True:\n        row = cursor.fetchone()\n        if row is None:\n            break\n        yield {dsc.name: row[index] for index, dsc in enumerate(cursor.description)}\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.singleton","title":"<code>singleton()</code>  <code>classmethod</code>","text":"<p>This returns a singleton object for the graph database. If the singleton isn't created yet, it creates it.</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef singleton(cls) -&gt; GraphDB:\n    \"\"\"This returns a singleton object for the graph database. If the\n    singleton isn't created yet, it creates it.\n    \"\"\"\n    global graph_db_singleton\n    if not graph_db_singleton:\n        graph_db_singleton = GraphDB()\n\n    assert graph_db_singleton.closed is False\n    return graph_db_singleton\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.to_networkx","title":"<code>to_networkx(db=None, node_ids=None, filter=None)</code>  <code>staticmethod</code>","text":"<p>Converts the entire graph database (and local cache of objects) into a NetworkX graph</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>GraphDB | None</code> <p>The database to convert to NetworkX. Defaults to the GraphDB singleton if not specified.</p> <code>None</code> <code>node_ids</code> <code>set[NodeId] | None</code> <p>The NodeIDs to add to the NetworkX graph. Defaults to all IDs if not specified.</p> <code>None</code> <code>filter</code> <code>NodeFilterFn | None</code> <p>A Node filter to filter out nodes before adding them to the NetworkX graph. Also useful for a callback that can be used for progress updates. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DiGraph</code> <p>nx.DiGraph: description</p> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef to_networkx(\n    db: GraphDB | None = None,\n    node_ids: set[NodeId] | None = None,\n    filter: NodeFilterFn | None = None,\n) -&gt; nx.DiGraph:\n    \"\"\"Converts the entire graph database (and local cache of objects) into\n    a NetworkX graph\n\n    Args:\n        db (GraphDB | None, optional): The database to convert to NetworkX.\n            Defaults to the GraphDB singleton if not specified.\n        node_ids (set[NodeId] | None, optional): The NodeIDs to add to the\n            NetworkX graph. Defaults to all IDs if not specified.\n        filter (NodeFilterFn | None, optional): A Node filter to filter out\n            nodes before adding them to the NetworkX graph. Also useful for a\n            callback that can be used for progress updates. Defaults to None.\n\n    Returns:\n        nx.DiGraph: _description_\n    \"\"\"\n    db = db or GraphDB.singleton()\n    node_ids = node_ids or Node.all_ids(db=db)\n    filter = filter or true_filter\n    G = nx.DiGraph()\n\n    def nx_add(n: Node) -&gt; None:\n        n_data = Node.to_dict(n, include_labels=True)\n\n        # TODO: this converts labels to a string, but maybe there's a better\n        # way to preserve the list so that it can be used for filtering in\n        # external programs\n        if \"labels\" in n_data and isinstance(n_data[\"labels\"], set):\n            n_data[\"labels\"] = \", \".join(n_data[\"labels\"])\n\n        G.add_node(n.id, **n_data)\n\n        for e in n.src_edges:\n            e_data = Edge.to_dict(e, include_type=True)\n            G.add_edge(e.src_id, e.dst_id, **e_data)\n\n    # iterate all specified node_ids, adding all of them to the nx graph\n    def nx_add_many(nodes: list[Node]) -&gt; None:\n        for n in nodes:\n            if filter(n):\n                nx_add(n)\n\n    Node.get_many(node_ids, load_edges=True, progress_callback=nx_add_many)\n\n    return G\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDBInternalError","title":"<code>GraphDBInternalError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>An generic exception for unexpected errors</p> Source code in <code>roc/graphdb.py</code> <pre><code>class GraphDBInternalError(Exception):\n    \"\"\"An generic exception for unexpected errors\"\"\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.MethodDescription","title":"<code>MethodDescription</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>class MethodDescription:\n    def __init__(self, model: type[BaseModel], name: str) -&gt; None:\n        self.model = model\n        self.name = name\n        self.signature = inspect.signature(getattr(model, name))\n        self.return_type = clean_annotation(self.signature.return_annotation)\n        self.params = self.signature.parameters\n\n    @property\n    def uml_params(self) -&gt; list[str]:\n        ret: list[str] = []\n\n        for param_name, param in self.params.items():\n            if param_name == \"self\":\n                continue\n\n            t = (\n                f\"{clean_annotation(param.annotation)} \"\n                if param.annotation is not inspect._empty\n                else \"\"\n            )\n            default_val = f\" = {param.default}\" if param.default is not inspect._empty else \"\"\n            ret.append(f\"{t}{param_name}{default_val}\")\n\n        return ret\n</code></pre>"},{"location":"reference/graphdb/#graphdb.MethodDescription.model","title":"<code>model = model</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.MethodDescription.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.MethodDescription.params","title":"<code>params = self.signature.parameters</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.MethodDescription.return_type","title":"<code>return_type = clean_annotation(self.signature.return_annotation)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.MethodDescription.signature","title":"<code>signature = inspect.signature(getattr(model, name))</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.MethodDescription.uml_params","title":"<code>uml_params: list[str]</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.MethodDescription.__init__","title":"<code>__init__(model, name)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, model: type[BaseModel], name: str) -&gt; None:\n    self.model = model\n    self.name = name\n    self.signature = inspect.signature(getattr(model, name))\n    self.return_type = clean_annotation(self.signature.return_annotation)\n    self.params = self.signature.parameters\n</code></pre>"},{"location":"reference/graphdb/#graphdb.ModelDescription","title":"<code>ModelDescription</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>class ModelDescription:\n    def __init__(self, model: type[BaseModel]) -&gt; None:\n        self.model = model\n\n        # fields\n        self.fields = [\n            FieldDescription(model, fieldname) for fieldname in pydantic_get_fields(model)\n        ]\n        self.fields.sort(key=lambda f: f.name)\n\n        # parents\n        self.parent_class_names = get_node_parent_names(model)\n        self.parents = [\n            NodeDescription(node_registry[node_name]) for node_name in self.parent_class_names\n        ]\n        self.parents.sort(key=lambda p: p.name)\n\n        # methods\n        self.method_names = (\n            get_methods(model) - get_methods(object) - get_methods(BaseModel) - get_methods(Node)\n        )\n        self.methods = [MethodDescription(model, name) for name in self.method_names]\n        self.methods.sort(key=lambda m: m.name)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.ModelDescription.fields","title":"<code>fields = [FieldDescription(model, fieldname) for fieldname in pydantic_get_fields(model)]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.ModelDescription.method_names","title":"<code>method_names = get_methods(model) - get_methods(object) - get_methods(BaseModel) - get_methods(Node)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.ModelDescription.methods","title":"<code>methods = [MethodDescription(model, name) for name in self.method_names]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.ModelDescription.model","title":"<code>model = model</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.ModelDescription.parent_class_names","title":"<code>parent_class_names = get_node_parent_names(model)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.ModelDescription.parents","title":"<code>parents = [NodeDescription(node_registry[node_name]) for node_name in self.parent_class_names]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.ModelDescription.__init__","title":"<code>__init__(model)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, model: type[BaseModel]) -&gt; None:\n    self.model = model\n\n    # fields\n    self.fields = [\n        FieldDescription(model, fieldname) for fieldname in pydantic_get_fields(model)\n    ]\n    self.fields.sort(key=lambda f: f.name)\n\n    # parents\n    self.parent_class_names = get_node_parent_names(model)\n    self.parents = [\n        NodeDescription(node_registry[node_name]) for node_name in self.parent_class_names\n    ]\n    self.parents.sort(key=lambda p: p.name)\n\n    # methods\n    self.method_names = (\n        get_methods(model) - get_methods(object) - get_methods(BaseModel) - get_methods(Node)\n    )\n    self.methods = [MethodDescription(model, name) for name in self.method_names]\n    self.methods.sort(key=lambda m: m.name)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node","title":"<code>Node</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An graph database node that automatically handles CRUD for the underlying graph database objects</p> Source code in <code>roc/graphdb.py</code> <pre><code>class Node(BaseModel, extra=\"allow\"):\n    \"\"\"An graph database node that automatically handles CRUD for the underlying graph database objects\"\"\"\n\n    _id: NodeId\n    labels: set[str] = Field(exclude=True, default_factory=set)\n    _orig_labels: set[str]\n    _src_edges: EdgeList\n    _dst_edges: EdgeList\n    _db: GraphDB\n    _new = False\n    _no_save = False\n    _deleted = False\n\n    @property\n    def id(self) -&gt; NodeId:\n        \"\"\"The unique ID of the node\"\"\"\n        return self._id\n\n    @property\n    def src_edges(self) -&gt; EdgeList:\n        \"\"\"All Edges that originate at this Node\"\"\"\n        return self._src_edges\n\n    @property\n    def dst_edges(self) -&gt; EdgeList:\n        \"\"\"All Edges that terminate at this Node\"\"\"\n        return self._dst_edges\n\n    @property\n    def edges(self) -&gt; EdgeList:\n        \"\"\"All Edges attached to this Node, regardless of direction\"\"\"\n        return self._src_edges + self._dst_edges\n\n    @property\n    def predecessors(self) -&gt; NodeList:\n        \"\"\"All Nodes connected with an directed Edge that ends with this node.\n        Also referred to as an 'in-neighbor'.\n        \"\"\"\n        return NodeList([e.src.id for e in self.dst_edges])\n\n    @property\n    def successors(self) -&gt; NodeList:\n        \"\"\"All Nodes connected with an directed Edge that starts with this node.\n        Also referred to as an 'out-neighbor'.\n        \"\"\"\n        return NodeList([e.dst.id for e in self.src_edges])\n\n    @property\n    def neighbors(self) -&gt; NodeList:\n        \"\"\"All adjacent nodes, regardless of edge direction\"\"\"\n        return self.successors + self.predecessors\n\n    @property\n    def new(self) -&gt; bool:\n        \"\"\"Whether or not this Node is new (not saved to the database yet)\"\"\"\n        return self._new\n\n    def __init__(\n        self,\n        **kwargs: Any,\n    ):\n        super().__init__(**kwargs)\n\n        # set passed-in private values or their defaults\n        self._db = kwargs[\"_db\"] if \"_db\" in kwargs else GraphDB.singleton()\n        self._id = kwargs[\"_id\"] if \"_id\" in kwargs else get_next_new_node_id()\n        self._src_edges = kwargs[\"_src_edges\"] if \"_src_edges\" in kwargs else EdgeList([])\n        self._dst_edges = kwargs[\"_dst_edges\"] if \"_dst_edges\" in kwargs else EdgeList([])\n\n        if self.id &lt; 0:\n            self._new = True  # TODO: derived?\n            Node.get_cache()[self.id] = self\n\n        self._orig_labels = self.labels.copy()\n\n    def __del__(self) -&gt; None:\n        # print(\"Node.__del__:\", self)\n        try:\n            self.__class__.save(self, db=self._db)\n        except Exception as e:\n            err_msg = f\"error saving during del: {e}\"\n            # logger.warning(err_msg)\n            warnings.warn(err_msg, ErrorSavingDuringDelWarning)\n\n    def __repr__(self) -&gt; str:\n        return f\"Node({self.id})\"\n\n    def __str__(self) -&gt; str:\n        return f\"Node({self.id}, labels={self.labels})\"\n\n    def __init_subclass__(cls, *args: Any, **kwargs: Any) -&gt; None:\n        super().__init_subclass__(*args, **kwargs)\n        clsname = cls.__name__\n\n        if not hasattr(cls, \"labels\"):\n            new_lbls = {c.__name__ for c in cls.__mro__ if c not in [Node, BaseModel, object]}\n\n            def default_subclass_fields() -&gt; set[str]:\n                return new_lbls\n\n            cls.labels = Field(default_factory=default_subclass_fields, exclude=True)\n            labels_key = frozenset(new_lbls)\n        else:\n            if isinstance(cls.labels, FieldInfo):\n                labels_key = frozenset(cls.labels.get_default(call_default_factory=True))\n            else:\n                labels_key = frozenset(cls.labels)\n\n        if clsname in node_registry:\n            raise Exception(\n                f\"\"\"node_register can't register '{clsname}' because that name has already been registered\"\"\"\n            )\n\n        if labels_key in node_label_registry:\n            labels = \", \".join(sorted(list(labels_key)))\n            raise Exception(\n                f\"\"\"node_register can't register labels '{labels}' because they have already been registered\"\"\"\n            )\n\n        node_registry[clsname] = cls\n        node_label_registry[labels_key] = cls\n\n    @classmethod\n    def load(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Loads a node from the database. Use `Node.get` or other methods instead.\n\n        Args:\n            id (NodeId): The identifier of the node to fetch\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            NodeNotFound: The node specified by the identifier does not exist in the database\n            GraphDBInternalError: If the requested ID returns multiple nodes\n\n        Returns:\n            Self: The node from the database\n        \"\"\"\n        res = cls.load_many({id}, db=db)\n\n        # print(\"RES\", res)\n\n        if len(res) &lt; 1:\n            raise NodeNotFound(f\"Couldn't find node ID: {id}\")\n\n        if len(res) &gt; 1:\n            raise GraphDBInternalError(\n                f\"Too many nodes returned while trying to load single node: {id}\"\n            )\n\n        return res[0]\n\n    @classmethod\n    def load_many(\n        cls,\n        node_set: set[NodeId],\n        db: GraphDB | None = None,\n        load_edges: bool = False,\n    ) -&gt; list[Self]:\n        db = db or GraphDB.singleton()\n        node_ids = \",\".join(map(str, node_set))\n\n        ret = cls.find(\n            where=f\"id(src) IN [{node_ids}]\",  # TODO: use params?\n            db=db,\n            load_edges=load_edges,\n        )\n\n        if len(ret) != len(node_set):\n            id_set = {n.id for n in ret}\n            missing_ids = node_set - id_set\n            raise NodeNotFound(f\"Couldn't find node IDs: {', '.join(map(str, missing_ids))}\")\n\n        return ret\n\n    @classmethod\n    def find(\n        cls,\n        where: str,\n        src_node_name: str = \"src\",\n        src_labels: set[str] = set(),\n        edge_name: str = \"e\",\n        edge_type: str = \"\",\n        params: QueryParamType = dict(),\n        db: GraphDB | None = None,\n        load_edges: bool = False,\n        params_to_str: bool = True,\n    ) -&gt; list[Self]:\n        db = db or GraphDB.singleton()\n\n        if load_edges:\n            edge_fmt = f\"{edge_name}\"\n        else:\n            edge_fmt = f\"{{id: id({edge_name}), start: id(startNode({edge_name})), end: id(endNode({edge_name}))}}\"\n\n        if len(src_labels) == 0:\n            src_label_str = \"\"\n        else:\n            src_label_str = f\":{':'.join(src_labels)}\"\n\n        if len(edge_type) &gt; 0:\n            edge_type = \":\" + edge_type\n\n        if params_to_str:\n            for k in params.keys():\n                params[k] = str(params[k])\n\n        res_iter = db.raw_fetch(\n            f\"\"\"\n                MATCH ({src_node_name}{src_label_str})-[{edge_name}{edge_type}*0..1]-() \n                WITH {src_node_name}, head({edge_name}) AS {edge_name}\n                WHERE {where}\n                RETURN {src_node_name} AS n, collect({edge_fmt}) AS edges\n                \"\"\",\n            params=params,\n        )\n\n        ret_list = list()\n        for r in res_iter:\n            logger.trace(f\"find result: {r}\")\n            n = r[\"n\"]\n            if n is None:\n                # NOTE: I can't think of any circumstances where there would be\n                # multiple \"None\" results, so I think this is just an empty list\n                continue\n\n            if load_edges:\n                # XXX: memgraph converts edges to Relationship objects if you\n                # return the whole edge\n                src_edges = list()\n                dst_edges = list()\n                edge_cache = Edge.get_cache()\n                for e in r[\"edges\"]:\n                    # add edge_id to to the right list for the node creation below\n                    if n.id == e.start_id:\n                        src_edges.append(e.id)\n                    else:\n                        dst_edges.append(e.id)\n\n                    # edge already loaded, continue to next one\n                    if e.id in edge_cache:\n                        continue\n\n                    # create a new edge\n                    props = {}\n                    if hasattr(e, \"properties\"):\n                        props = e.properties\n                    new_edge = Edge(\n                        src_id=e.start_id,\n                        dst_id=e.end_id,\n                        _id=e.id,\n                        type=e.type,\n                        **props,\n                    )\n                    edge_cache[e.id] = new_edge\n            else:\n                # edges are just the IDs\n                src_edges = [e[\"id\"] for e in r[\"edges\"] if e[\"start\"] == n.id]\n                dst_edges = [e[\"id\"] for e in r[\"edges\"] if e[\"end\"] == n.id]\n\n            node_cache = cls.get_cache()\n            if n.id in node_cache:\n                new_node = cast(Self, node_cache[n.id])\n            else:\n                mkcls = cls\n                cls_lbls = frozenset(n.labels)\n                if cls is Node and cls_lbls in node_label_registry:\n                    mkcls = cast(type[Self], node_label_registry[cls_lbls])\n                new_node = mkcls(\n                    _id=n.id,\n                    _src_edges=EdgeList(src_edges),\n                    _dst_edges=EdgeList(dst_edges),\n                    labels=n.labels,\n                    **n.properties,\n                )\n                node_cache[n.id] = new_node\n            ret_list.append(new_node)\n\n        return ret_list\n\n    @classmethod\n    def find_one(\n        cls,\n        where: str,\n        src_node_name: str = \"src\",\n        src_labels: set[str] = set(),\n        edge_name: str = \"e\",\n        edge_type: str = \"\",\n        params: QueryParamType = dict(),\n        db: GraphDB | None = None,\n        load_edges: bool = False,\n        params_to_str: bool = True,\n        exactly_one: bool = False,\n    ) -&gt; Self | None:\n        \"\"\"Finds a single Node.find results down to a single node. Raises an\n        exception of the list contains more than one node.\n\n        Args:\n            nodes (Sequence[NodeType]): The list of nodes returned by Node.find\n\n        Raises:\n            Exception: Raised if there is more than 1 node in the list\n\n        Returns:\n            NodeType | None: Returns None if the list is empty, or the node in the list.\n        \"\"\"\n        nodes = cls.find(\n            where=where,\n            src_node_name=src_node_name,\n            src_labels=src_labels,\n            edge_name=edge_name,\n            edge_type=edge_type,\n            params=params,\n            db=db,\n            load_edges=load_edges,\n            params_to_str=params_to_str,\n        )\n\n        match len(nodes):\n            case 0:\n                if exactly_one:\n                    raise Exception(\"expect exactly one node in find_one\")\n                return None\n            case 1:\n                return nodes[0]\n            case _:\n                raise Exception(\"expected zero or one node in find_one\")\n\n    @classmethod\n    def get_many(\n        cls,\n        node_ids: Collection[NodeId],\n        *,\n        batch_size: int = 128,\n        db: GraphDB | None = None,\n        load_edges: bool = False,\n        return_nodes: bool = False,\n        progress_callback: ProgressFn | None = None,\n    ) -&gt; list[Node]:\n        db = db or GraphDB.singleton()\n\n        if not isinstance(node_ids, set):\n            node_ids = set(node_ids)\n\n        c = Node.get_cache()\n        if len(node_ids) &gt; c.maxsize:\n            raise GraphDBInternalError(\n                f\"get_many attempting to load more nodes than cache size ({len(node_ids)} &gt; {c.maxsize})\"\n            )\n\n        cache_ids = set(c.keys())\n        fetch_ids = node_ids - cache_ids\n\n        start = 0\n        curr = batch_size\n        ret_list = [c[nid] for nid in c]\n        if progress_callback:\n            progress_callback(ret_list)\n        while start &lt; len(fetch_ids):\n            id_set = set(islice(fetch_ids, start, curr))\n\n            res = cls.load_many(id_set, db=db, load_edges=load_edges)\n            for n in res:\n                c[n.id] = n\n\n            if progress_callback:\n                progress_callback(res)\n\n            ret_list.extend(res)\n            # import pprint\n            # pprint.pp(list(res))\n            # print(f\"got {len(list(res))} nodes\")\n\n            start = curr\n            curr += batch_size\n\n        assert len(ret_list) == len(node_ids)\n        return ret_list\n\n    @classmethod\n    def get_cache(cls) -&gt; NodeCache:\n        global node_cache\n        if node_cache is None:\n            settings = Config.get()\n            node_cache = NodeCache(settings.node_cache_size)\n\n        return node_cache\n\n    @classmethod\n    def get(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Returns a cached node with the specified id. If no node is cached, it is retrieved from\n        the database.\n\n\n        Args:\n            id (NodeId): The unique identifier of the node to fetch\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: the cached or newly retrieved node\n        \"\"\"\n        cache = Node.get_cache()\n        n = cache.get(id)\n        if n is None:\n            n = cls.load(id, db=db)\n\n        return cast(Self, n)\n\n    @classmethod\n    def save(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Save a node to persistent storage\n\n        Writes the specified node to the GraphDB for persistent storage. If the node does not\n        already exist in storage, it is created via the `create` method. If the node does exist, it\n        is updated via the `update` method.\n\n        If the _no_save flag is True on the node, the save request will be silently ignored.\n\n        Args:\n            n (Self): The Node to be saved\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: As a convenience, the node that was stored is returned. This may be useful\n            since the the id of the node may change if it was created in the database.\n        \"\"\"\n        if n._new:\n            return cls.create(n, db=db)\n        else:\n            return cls.update(n, db=db)\n\n    @classmethod\n    def update(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Update an existing node in the GraphDB.\n\n        Calling `save` is preferred to using this method so that the caller doesn't need to know the\n        state of the node.\n\n        Args:\n            n (Self): The node to be updated\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: The node that was passed in, for convenience\n        \"\"\"\n        if n._no_save:\n            return n\n\n        db = db or GraphDB.singleton()\n\n        orig_labels = n._orig_labels\n        curr_labels = set(n.labels)\n        new_labels = curr_labels - orig_labels\n        rm_labels = orig_labels - curr_labels\n        set_label_str = Node.mklabels(new_labels)\n        if set_label_str:\n            set_query = f\"SET n{set_label_str}, n = $props\"\n        else:\n            set_query = \"SET n = $props\"\n        rm_label_str = Node.mklabels(rm_labels)\n        if rm_label_str:\n            rm_query = f\"REMOVE n{rm_label_str}\"\n        else:\n            rm_query = \"\"\n\n        params = {\"props\": Node.to_dict(n)}\n\n        db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} {set_query} {rm_query}\", params=params)\n\n        return n\n\n    @classmethod\n    def create(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Creates the specified node in the GraphDB.\n\n        Calling `save` is preferred to using this method so that the caller doesn't need to know the\n        state of the node.\n\n        Args:\n            n (Self): the node to be created\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            NodeCreationFailed: if creating the node failed in the database\n\n        Returns:\n            Self: the node that was passed in, albeit with a new `id` and potenitally other new\n            fields\n        \"\"\"\n        if n._no_save:\n            return n\n\n        db = db or GraphDB.singleton()\n        old_id = n.id\n\n        label_str = Node.mklabels(n.labels)\n        params = {\"props\": Node.to_dict(n)}\n\n        res = list(db.raw_fetch(f\"CREATE (n{label_str} $props) RETURN id(n) as id\", params=params))\n\n        if not len(res) &gt;= 1:\n            raise NodeCreationFailed(f\"Couldn't create node ID: {id}\")\n\n        new_id = res[0][\"id\"]\n        n._id = new_id\n        n._new = False\n        # update the cache; if being called during c then the cache entry may not exist\n        try:\n            cache = Node.get_cache()\n            del cache[old_id]\n            cache[new_id] = n\n        except KeyError:\n            pass\n\n        for e in n.src_edges:\n            assert e.src_id == old_id\n            e.src_id = new_id\n\n        for e in n.dst_edges:\n            assert e.dst_id == old_id\n            e.dst_id = new_id\n\n        return n\n\n    @classmethod\n    def connect(\n        cls,\n        src: NodeId | Self,\n        dst: NodeId | Self,\n        type: str | None = None,\n        *,\n        db: GraphDB | None = None,\n    ) -&gt; Edge:\n        \"\"\"Connects two nodes (creates an Edge between two nodes)\n\n        Args:\n            src (NodeId | Node): The Node to use at the start of the connection\n            dst (NodeId | Node): The Node to use at the end of the connection\n            type (str): The type of the edge to use for the connection\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Edge: The Edge that was created\n        \"\"\"\n        return Edge.connect(src, dst, type, db=db)\n\n    @staticmethod\n    def delete(n: Node, *, db: GraphDB | None = None) -&gt; None:\n        db = db or GraphDB.singleton()\n\n        # remove edges\n        for e in n.src_edges:\n            Edge.delete(e)\n\n        for e in n.dst_edges:\n            Edge.delete(e)\n\n        # remove from cache\n        node_cache = Node.get_cache()\n        if n.id in node_cache:\n            del node_cache[n.id]\n\n        if not n._new:\n            db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} DELETE n\")\n\n        n._deleted = True\n        n._no_save = True\n\n    @staticmethod\n    def to_dict(n: Node, include_labels: bool = False) -&gt; dict[str, Any]:\n        \"\"\"Convert a Node to a Python dictionary\"\"\"\n        # XXX: the excluded fields below shouldn't have been included in the\n        # first place because Pythonic should exclude fields with underscores\n        ret = n.model_dump(exclude={\"_id\", \"_src_edges\", \"_dst_edges\"})\n\n        if include_labels and hasattr(n, \"labels\"):\n            ret[\"labels\"] = n.labels\n\n        return ret\n\n    @staticmethod\n    def mklabels(labels: set[str]) -&gt; str:\n        \"\"\"Converts a list of strings into proper Cypher syntax for a graph database query\"\"\"\n        labels_list = [i for i in labels]\n        labels_list.sort()\n        label_str = \":\".join(labels_list)\n        if len(label_str) &gt; 0:\n            label_str = \":\" + label_str\n\n        return label_str\n\n    @staticmethod\n    def all_ids(db: GraphDB | None = None) -&gt; set[NodeId]:\n        \"\"\"Returns an exhaustive Set of all NodeIds that exist in both the graph\n        database and the NodeCache\n        \"\"\"\n        db = db or GraphDB.singleton()\n\n        # get all NodeIds in the cache\n        c = Node.get_cache()\n        cached_ids = set(c.keys())\n\n        # get all NodeIds in the database\n        db_ids = {n[\"id\"] for n in db.raw_fetch(\"MATCH (n) RETURN id(n) as id\")}\n\n        # return the combination of both\n        return db_ids.union(cached_ids)\n\n    @staticmethod\n    def to_id(n: Node | NodeId) -&gt; NodeId:\n        if isinstance(n, Node):\n            return n.id\n        else:\n            return n\n\n    @staticmethod\n    def walk(\n        n: Node,\n        *,\n        mode: WalkMode = \"both\",\n        edge_filter: EdgeFilterFn | None = None,\n        # edge_callback: EdgeCallbackFn | None = None,\n        node_filter: NodeFilterFn | None = None,\n        node_callback: NodeCallbackFn | None = None,\n        _walk_history: set[int] | None = None,\n    ) -&gt; None:\n        # if we have walked this node before, just return\n        _walk_history = _walk_history or set()\n        if n.id in _walk_history:\n            return\n        _walk_history.add(n.id)\n\n        edge_filter = edge_filter or cast(EdgeFilterFn, true_filter)\n        node_filter = node_filter or true_filter\n        # edge_callback = edge_callback or no_callback\n        node_callback = node_callback or no_callback\n\n        # callback for this node, if not filtered\n        if node_filter(n):\n            node_callback(n)\n        else:\n            return\n\n        if mode == \"src\" or mode == \"both\":\n            for e in n.src_edges:\n                if edge_filter(e):\n                    Node.walk(\n                        e.dst,\n                        mode=mode,\n                        edge_filter=edge_filter,\n                        # edge_callback=edge_callback,\n                        node_filter=node_filter,\n                        node_callback=node_callback,\n                        _walk_history=_walk_history,\n                    )\n\n        if mode == \"dst\" or mode == \"both\":\n            for e in n.dst_edges:\n                if edge_filter(e):\n                    Node.walk(\n                        e.src,\n                        mode=mode,\n                        edge_filter=edge_filter,\n                        # edge_callback=edge_callback,\n                        node_filter=node_filter,\n                        node_callback=node_callback,\n                        _walk_history=_walk_history,\n                    )\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.dst_edges","title":"<code>dst_edges: EdgeList</code>  <code>property</code>","text":"<p>All Edges that terminate at this Node</p>"},{"location":"reference/graphdb/#graphdb.Node.edges","title":"<code>edges: EdgeList</code>  <code>property</code>","text":"<p>All Edges attached to this Node, regardless of direction</p>"},{"location":"reference/graphdb/#graphdb.Node.id","title":"<code>id: NodeId</code>  <code>property</code>","text":"<p>The unique ID of the node</p>"},{"location":"reference/graphdb/#graphdb.Node.labels","title":"<code>labels: set[str] = Field(exclude=True, default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Node.neighbors","title":"<code>neighbors: NodeList</code>  <code>property</code>","text":"<p>All adjacent nodes, regardless of edge direction</p>"},{"location":"reference/graphdb/#graphdb.Node.new","title":"<code>new: bool</code>  <code>property</code>","text":"<p>Whether or not this Node is new (not saved to the database yet)</p>"},{"location":"reference/graphdb/#graphdb.Node.predecessors","title":"<code>predecessors: NodeList</code>  <code>property</code>","text":"<p>All Nodes connected with an directed Edge that ends with this node. Also referred to as an 'in-neighbor'.</p>"},{"location":"reference/graphdb/#graphdb.Node.src_edges","title":"<code>src_edges: EdgeList</code>  <code>property</code>","text":"<p>All Edges that originate at this Node</p>"},{"location":"reference/graphdb/#graphdb.Node.successors","title":"<code>successors: NodeList</code>  <code>property</code>","text":"<p>All Nodes connected with an directed Edge that starts with this node. Also referred to as an 'out-neighbor'.</p>"},{"location":"reference/graphdb/#graphdb.Node.__del__","title":"<code>__del__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __del__(self) -&gt; None:\n    # print(\"Node.__del__:\", self)\n    try:\n        self.__class__.save(self, db=self._db)\n    except Exception as e:\n        err_msg = f\"error saving during del: {e}\"\n        # logger.warning(err_msg)\n        warnings.warn(err_msg, ErrorSavingDuringDelWarning)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.__init__","title":"<code>__init__(**kwargs)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(\n    self,\n    **kwargs: Any,\n):\n    super().__init__(**kwargs)\n\n    # set passed-in private values or their defaults\n    self._db = kwargs[\"_db\"] if \"_db\" in kwargs else GraphDB.singleton()\n    self._id = kwargs[\"_id\"] if \"_id\" in kwargs else get_next_new_node_id()\n    self._src_edges = kwargs[\"_src_edges\"] if \"_src_edges\" in kwargs else EdgeList([])\n    self._dst_edges = kwargs[\"_dst_edges\"] if \"_dst_edges\" in kwargs else EdgeList([])\n\n    if self.id &lt; 0:\n        self._new = True  # TODO: derived?\n        Node.get_cache()[self.id] = self\n\n    self._orig_labels = self.labels.copy()\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.__init_subclass__","title":"<code>__init_subclass__(*args, **kwargs)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init_subclass__(cls, *args: Any, **kwargs: Any) -&gt; None:\n    super().__init_subclass__(*args, **kwargs)\n    clsname = cls.__name__\n\n    if not hasattr(cls, \"labels\"):\n        new_lbls = {c.__name__ for c in cls.__mro__ if c not in [Node, BaseModel, object]}\n\n        def default_subclass_fields() -&gt; set[str]:\n            return new_lbls\n\n        cls.labels = Field(default_factory=default_subclass_fields, exclude=True)\n        labels_key = frozenset(new_lbls)\n    else:\n        if isinstance(cls.labels, FieldInfo):\n            labels_key = frozenset(cls.labels.get_default(call_default_factory=True))\n        else:\n            labels_key = frozenset(cls.labels)\n\n    if clsname in node_registry:\n        raise Exception(\n            f\"\"\"node_register can't register '{clsname}' because that name has already been registered\"\"\"\n        )\n\n    if labels_key in node_label_registry:\n        labels = \", \".join(sorted(list(labels_key)))\n        raise Exception(\n            f\"\"\"node_register can't register labels '{labels}' because they have already been registered\"\"\"\n        )\n\n    node_registry[clsname] = cls\n    node_label_registry[labels_key] = cls\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"Node({self.id})\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"Node({self.id}, labels={self.labels})\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.all_ids","title":"<code>all_ids(db=None)</code>  <code>staticmethod</code>","text":"<p>Returns an exhaustive Set of all NodeIds that exist in both the graph database and the NodeCache</p> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef all_ids(db: GraphDB | None = None) -&gt; set[NodeId]:\n    \"\"\"Returns an exhaustive Set of all NodeIds that exist in both the graph\n    database and the NodeCache\n    \"\"\"\n    db = db or GraphDB.singleton()\n\n    # get all NodeIds in the cache\n    c = Node.get_cache()\n    cached_ids = set(c.keys())\n\n    # get all NodeIds in the database\n    db_ids = {n[\"id\"] for n in db.raw_fetch(\"MATCH (n) RETURN id(n) as id\")}\n\n    # return the combination of both\n    return db_ids.union(cached_ids)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.connect","title":"<code>connect(src, dst, type=None, *, db=None)</code>  <code>classmethod</code>","text":"<p>Connects two nodes (creates an Edge between two nodes)</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>NodeId | Node</code> <p>The Node to use at the start of the connection</p> required <code>dst</code> <code>NodeId | Node</code> <p>The Node to use at the end of the connection</p> required <code>type</code> <code>str</code> <p>The type of the edge to use for the connection</p> <code>None</code> <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Edge</code> <code>Edge</code> <p>The Edge that was created</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef connect(\n    cls,\n    src: NodeId | Self,\n    dst: NodeId | Self,\n    type: str | None = None,\n    *,\n    db: GraphDB | None = None,\n) -&gt; Edge:\n    \"\"\"Connects two nodes (creates an Edge between two nodes)\n\n    Args:\n        src (NodeId | Node): The Node to use at the start of the connection\n        dst (NodeId | Node): The Node to use at the end of the connection\n        type (str): The type of the edge to use for the connection\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Edge: The Edge that was created\n    \"\"\"\n    return Edge.connect(src, dst, type, db=db)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.create","title":"<code>create(n, *, db=None)</code>  <code>classmethod</code>","text":"<p>Creates the specified node in the GraphDB.</p> <p>Calling <code>save</code> is preferred to using this method so that the caller doesn't need to know the state of the node.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Self</code> <p>the node to be created</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>NodeCreationFailed</code> <p>if creating the node failed in the database</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the node that was passed in, albeit with a new <code>id</code> and potenitally other new</p> <code>Self</code> <p>fields</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef create(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Creates the specified node in the GraphDB.\n\n    Calling `save` is preferred to using this method so that the caller doesn't need to know the\n    state of the node.\n\n    Args:\n        n (Self): the node to be created\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        NodeCreationFailed: if creating the node failed in the database\n\n    Returns:\n        Self: the node that was passed in, albeit with a new `id` and potenitally other new\n        fields\n    \"\"\"\n    if n._no_save:\n        return n\n\n    db = db or GraphDB.singleton()\n    old_id = n.id\n\n    label_str = Node.mklabels(n.labels)\n    params = {\"props\": Node.to_dict(n)}\n\n    res = list(db.raw_fetch(f\"CREATE (n{label_str} $props) RETURN id(n) as id\", params=params))\n\n    if not len(res) &gt;= 1:\n        raise NodeCreationFailed(f\"Couldn't create node ID: {id}\")\n\n    new_id = res[0][\"id\"]\n    n._id = new_id\n    n._new = False\n    # update the cache; if being called during c then the cache entry may not exist\n    try:\n        cache = Node.get_cache()\n        del cache[old_id]\n        cache[new_id] = n\n    except KeyError:\n        pass\n\n    for e in n.src_edges:\n        assert e.src_id == old_id\n        e.src_id = new_id\n\n    for e in n.dst_edges:\n        assert e.dst_id == old_id\n        e.dst_id = new_id\n\n    return n\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.delete","title":"<code>delete(n, *, db=None)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef delete(n: Node, *, db: GraphDB | None = None) -&gt; None:\n    db = db or GraphDB.singleton()\n\n    # remove edges\n    for e in n.src_edges:\n        Edge.delete(e)\n\n    for e in n.dst_edges:\n        Edge.delete(e)\n\n    # remove from cache\n    node_cache = Node.get_cache()\n    if n.id in node_cache:\n        del node_cache[n.id]\n\n    if not n._new:\n        db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} DELETE n\")\n\n    n._deleted = True\n    n._no_save = True\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.find","title":"<code>find(where, src_node_name='src', src_labels=set(), edge_name='e', edge_type='', params=dict(), db=None, load_edges=False, params_to_str=True)</code>  <code>classmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef find(\n    cls,\n    where: str,\n    src_node_name: str = \"src\",\n    src_labels: set[str] = set(),\n    edge_name: str = \"e\",\n    edge_type: str = \"\",\n    params: QueryParamType = dict(),\n    db: GraphDB | None = None,\n    load_edges: bool = False,\n    params_to_str: bool = True,\n) -&gt; list[Self]:\n    db = db or GraphDB.singleton()\n\n    if load_edges:\n        edge_fmt = f\"{edge_name}\"\n    else:\n        edge_fmt = f\"{{id: id({edge_name}), start: id(startNode({edge_name})), end: id(endNode({edge_name}))}}\"\n\n    if len(src_labels) == 0:\n        src_label_str = \"\"\n    else:\n        src_label_str = f\":{':'.join(src_labels)}\"\n\n    if len(edge_type) &gt; 0:\n        edge_type = \":\" + edge_type\n\n    if params_to_str:\n        for k in params.keys():\n            params[k] = str(params[k])\n\n    res_iter = db.raw_fetch(\n        f\"\"\"\n            MATCH ({src_node_name}{src_label_str})-[{edge_name}{edge_type}*0..1]-() \n            WITH {src_node_name}, head({edge_name}) AS {edge_name}\n            WHERE {where}\n            RETURN {src_node_name} AS n, collect({edge_fmt}) AS edges\n            \"\"\",\n        params=params,\n    )\n\n    ret_list = list()\n    for r in res_iter:\n        logger.trace(f\"find result: {r}\")\n        n = r[\"n\"]\n        if n is None:\n            # NOTE: I can't think of any circumstances where there would be\n            # multiple \"None\" results, so I think this is just an empty list\n            continue\n\n        if load_edges:\n            # XXX: memgraph converts edges to Relationship objects if you\n            # return the whole edge\n            src_edges = list()\n            dst_edges = list()\n            edge_cache = Edge.get_cache()\n            for e in r[\"edges\"]:\n                # add edge_id to to the right list for the node creation below\n                if n.id == e.start_id:\n                    src_edges.append(e.id)\n                else:\n                    dst_edges.append(e.id)\n\n                # edge already loaded, continue to next one\n                if e.id in edge_cache:\n                    continue\n\n                # create a new edge\n                props = {}\n                if hasattr(e, \"properties\"):\n                    props = e.properties\n                new_edge = Edge(\n                    src_id=e.start_id,\n                    dst_id=e.end_id,\n                    _id=e.id,\n                    type=e.type,\n                    **props,\n                )\n                edge_cache[e.id] = new_edge\n        else:\n            # edges are just the IDs\n            src_edges = [e[\"id\"] for e in r[\"edges\"] if e[\"start\"] == n.id]\n            dst_edges = [e[\"id\"] for e in r[\"edges\"] if e[\"end\"] == n.id]\n\n        node_cache = cls.get_cache()\n        if n.id in node_cache:\n            new_node = cast(Self, node_cache[n.id])\n        else:\n            mkcls = cls\n            cls_lbls = frozenset(n.labels)\n            if cls is Node and cls_lbls in node_label_registry:\n                mkcls = cast(type[Self], node_label_registry[cls_lbls])\n            new_node = mkcls(\n                _id=n.id,\n                _src_edges=EdgeList(src_edges),\n                _dst_edges=EdgeList(dst_edges),\n                labels=n.labels,\n                **n.properties,\n            )\n            node_cache[n.id] = new_node\n        ret_list.append(new_node)\n\n    return ret_list\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.find_one","title":"<code>find_one(where, src_node_name='src', src_labels=set(), edge_name='e', edge_type='', params=dict(), db=None, load_edges=False, params_to_str=True, exactly_one=False)</code>  <code>classmethod</code>","text":"<p>Finds a single Node.find results down to a single node. Raises an exception of the list contains more than one node.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>Sequence[NodeType]</code> <p>The list of nodes returned by Node.find</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>Raised if there is more than 1 node in the list</p> <p>Returns:</p> Type Description <code>Self | None</code> <p>NodeType | None: Returns None if the list is empty, or the node in the list.</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef find_one(\n    cls,\n    where: str,\n    src_node_name: str = \"src\",\n    src_labels: set[str] = set(),\n    edge_name: str = \"e\",\n    edge_type: str = \"\",\n    params: QueryParamType = dict(),\n    db: GraphDB | None = None,\n    load_edges: bool = False,\n    params_to_str: bool = True,\n    exactly_one: bool = False,\n) -&gt; Self | None:\n    \"\"\"Finds a single Node.find results down to a single node. Raises an\n    exception of the list contains more than one node.\n\n    Args:\n        nodes (Sequence[NodeType]): The list of nodes returned by Node.find\n\n    Raises:\n        Exception: Raised if there is more than 1 node in the list\n\n    Returns:\n        NodeType | None: Returns None if the list is empty, or the node in the list.\n    \"\"\"\n    nodes = cls.find(\n        where=where,\n        src_node_name=src_node_name,\n        src_labels=src_labels,\n        edge_name=edge_name,\n        edge_type=edge_type,\n        params=params,\n        db=db,\n        load_edges=load_edges,\n        params_to_str=params_to_str,\n    )\n\n    match len(nodes):\n        case 0:\n            if exactly_one:\n                raise Exception(\"expect exactly one node in find_one\")\n            return None\n        case 1:\n            return nodes[0]\n        case _:\n            raise Exception(\"expected zero or one node in find_one\")\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.get","title":"<code>get(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Returns a cached node with the specified id. If no node is cached, it is retrieved from the database.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>NodeId</code> <p>The unique identifier of the node to fetch</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the cached or newly retrieved node</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Returns a cached node with the specified id. If no node is cached, it is retrieved from\n    the database.\n\n\n    Args:\n        id (NodeId): The unique identifier of the node to fetch\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: the cached or newly retrieved node\n    \"\"\"\n    cache = Node.get_cache()\n    n = cache.get(id)\n    if n is None:\n        n = cls.load(id, db=db)\n\n    return cast(Self, n)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.get_cache","title":"<code>get_cache()</code>  <code>classmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get_cache(cls) -&gt; NodeCache:\n    global node_cache\n    if node_cache is None:\n        settings = Config.get()\n        node_cache = NodeCache(settings.node_cache_size)\n\n    return node_cache\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.get_many","title":"<code>get_many(node_ids, *, batch_size=128, db=None, load_edges=False, return_nodes=False, progress_callback=None)</code>  <code>classmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get_many(\n    cls,\n    node_ids: Collection[NodeId],\n    *,\n    batch_size: int = 128,\n    db: GraphDB | None = None,\n    load_edges: bool = False,\n    return_nodes: bool = False,\n    progress_callback: ProgressFn | None = None,\n) -&gt; list[Node]:\n    db = db or GraphDB.singleton()\n\n    if not isinstance(node_ids, set):\n        node_ids = set(node_ids)\n\n    c = Node.get_cache()\n    if len(node_ids) &gt; c.maxsize:\n        raise GraphDBInternalError(\n            f\"get_many attempting to load more nodes than cache size ({len(node_ids)} &gt; {c.maxsize})\"\n        )\n\n    cache_ids = set(c.keys())\n    fetch_ids = node_ids - cache_ids\n\n    start = 0\n    curr = batch_size\n    ret_list = [c[nid] for nid in c]\n    if progress_callback:\n        progress_callback(ret_list)\n    while start &lt; len(fetch_ids):\n        id_set = set(islice(fetch_ids, start, curr))\n\n        res = cls.load_many(id_set, db=db, load_edges=load_edges)\n        for n in res:\n            c[n.id] = n\n\n        if progress_callback:\n            progress_callback(res)\n\n        ret_list.extend(res)\n        # import pprint\n        # pprint.pp(list(res))\n        # print(f\"got {len(list(res))} nodes\")\n\n        start = curr\n        curr += batch_size\n\n    assert len(ret_list) == len(node_ids)\n    return ret_list\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.load","title":"<code>load(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Loads a node from the database. Use <code>Node.get</code> or other methods instead.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>NodeId</code> <p>The identifier of the node to fetch</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>NodeNotFound</code> <p>The node specified by the identifier does not exist in the database</p> <code>GraphDBInternalError</code> <p>If the requested ID returns multiple nodes</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The node from the database</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef load(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Loads a node from the database. Use `Node.get` or other methods instead.\n\n    Args:\n        id (NodeId): The identifier of the node to fetch\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        NodeNotFound: The node specified by the identifier does not exist in the database\n        GraphDBInternalError: If the requested ID returns multiple nodes\n\n    Returns:\n        Self: The node from the database\n    \"\"\"\n    res = cls.load_many({id}, db=db)\n\n    # print(\"RES\", res)\n\n    if len(res) &lt; 1:\n        raise NodeNotFound(f\"Couldn't find node ID: {id}\")\n\n    if len(res) &gt; 1:\n        raise GraphDBInternalError(\n            f\"Too many nodes returned while trying to load single node: {id}\"\n        )\n\n    return res[0]\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.load_many","title":"<code>load_many(node_set, db=None, load_edges=False)</code>  <code>classmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef load_many(\n    cls,\n    node_set: set[NodeId],\n    db: GraphDB | None = None,\n    load_edges: bool = False,\n) -&gt; list[Self]:\n    db = db or GraphDB.singleton()\n    node_ids = \",\".join(map(str, node_set))\n\n    ret = cls.find(\n        where=f\"id(src) IN [{node_ids}]\",  # TODO: use params?\n        db=db,\n        load_edges=load_edges,\n    )\n\n    if len(ret) != len(node_set):\n        id_set = {n.id for n in ret}\n        missing_ids = node_set - id_set\n        raise NodeNotFound(f\"Couldn't find node IDs: {', '.join(map(str, missing_ids))}\")\n\n    return ret\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.mklabels","title":"<code>mklabels(labels)</code>  <code>staticmethod</code>","text":"<p>Converts a list of strings into proper Cypher syntax for a graph database query</p> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef mklabels(labels: set[str]) -&gt; str:\n    \"\"\"Converts a list of strings into proper Cypher syntax for a graph database query\"\"\"\n    labels_list = [i for i in labels]\n    labels_list.sort()\n    label_str = \":\".join(labels_list)\n    if len(label_str) &gt; 0:\n        label_str = \":\" + label_str\n\n    return label_str\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.save","title":"<code>save(n, *, db=None)</code>  <code>classmethod</code>","text":"<p>Save a node to persistent storage</p> <p>Writes the specified node to the GraphDB for persistent storage. If the node does not already exist in storage, it is created via the <code>create</code> method. If the node does exist, it is updated via the <code>update</code> method.</p> <p>If the _no_save flag is True on the node, the save request will be silently ignored.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Self</code> <p>The Node to be saved</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>As a convenience, the node that was stored is returned. This may be useful</p> <code>Self</code> <p>since the the id of the node may change if it was created in the database.</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef save(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Save a node to persistent storage\n\n    Writes the specified node to the GraphDB for persistent storage. If the node does not\n    already exist in storage, it is created via the `create` method. If the node does exist, it\n    is updated via the `update` method.\n\n    If the _no_save flag is True on the node, the save request will be silently ignored.\n\n    Args:\n        n (Self): The Node to be saved\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: As a convenience, the node that was stored is returned. This may be useful\n        since the the id of the node may change if it was created in the database.\n    \"\"\"\n    if n._new:\n        return cls.create(n, db=db)\n    else:\n        return cls.update(n, db=db)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.to_dict","title":"<code>to_dict(n, include_labels=False)</code>  <code>staticmethod</code>","text":"<p>Convert a Node to a Python dictionary</p> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef to_dict(n: Node, include_labels: bool = False) -&gt; dict[str, Any]:\n    \"\"\"Convert a Node to a Python dictionary\"\"\"\n    # XXX: the excluded fields below shouldn't have been included in the\n    # first place because Pythonic should exclude fields with underscores\n    ret = n.model_dump(exclude={\"_id\", \"_src_edges\", \"_dst_edges\"})\n\n    if include_labels and hasattr(n, \"labels\"):\n        ret[\"labels\"] = n.labels\n\n    return ret\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.to_id","title":"<code>to_id(n)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef to_id(n: Node | NodeId) -&gt; NodeId:\n    if isinstance(n, Node):\n        return n.id\n    else:\n        return n\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.update","title":"<code>update(n, *, db=None)</code>  <code>classmethod</code>","text":"<p>Update an existing node in the GraphDB.</p> <p>Calling <code>save</code> is preferred to using this method so that the caller doesn't need to know the state of the node.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Self</code> <p>The node to be updated</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The node that was passed in, for convenience</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef update(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Update an existing node in the GraphDB.\n\n    Calling `save` is preferred to using this method so that the caller doesn't need to know the\n    state of the node.\n\n    Args:\n        n (Self): The node to be updated\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: The node that was passed in, for convenience\n    \"\"\"\n    if n._no_save:\n        return n\n\n    db = db or GraphDB.singleton()\n\n    orig_labels = n._orig_labels\n    curr_labels = set(n.labels)\n    new_labels = curr_labels - orig_labels\n    rm_labels = orig_labels - curr_labels\n    set_label_str = Node.mklabels(new_labels)\n    if set_label_str:\n        set_query = f\"SET n{set_label_str}, n = $props\"\n    else:\n        set_query = \"SET n = $props\"\n    rm_label_str = Node.mklabels(rm_labels)\n    if rm_label_str:\n        rm_query = f\"REMOVE n{rm_label_str}\"\n    else:\n        rm_query = \"\"\n\n    params = {\"props\": Node.to_dict(n)}\n\n    db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} {set_query} {rm_query}\", params=params)\n\n    return n\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.walk","title":"<code>walk(n, *, mode='both', edge_filter=None, node_filter=None, node_callback=None, _walk_history=None)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef walk(\n    n: Node,\n    *,\n    mode: WalkMode = \"both\",\n    edge_filter: EdgeFilterFn | None = None,\n    # edge_callback: EdgeCallbackFn | None = None,\n    node_filter: NodeFilterFn | None = None,\n    node_callback: NodeCallbackFn | None = None,\n    _walk_history: set[int] | None = None,\n) -&gt; None:\n    # if we have walked this node before, just return\n    _walk_history = _walk_history or set()\n    if n.id in _walk_history:\n        return\n    _walk_history.add(n.id)\n\n    edge_filter = edge_filter or cast(EdgeFilterFn, true_filter)\n    node_filter = node_filter or true_filter\n    # edge_callback = edge_callback or no_callback\n    node_callback = node_callback or no_callback\n\n    # callback for this node, if not filtered\n    if node_filter(n):\n        node_callback(n)\n    else:\n        return\n\n    if mode == \"src\" or mode == \"both\":\n        for e in n.src_edges:\n            if edge_filter(e):\n                Node.walk(\n                    e.dst,\n                    mode=mode,\n                    edge_filter=edge_filter,\n                    # edge_callback=edge_callback,\n                    node_filter=node_filter,\n                    node_callback=node_callback,\n                    _walk_history=_walk_history,\n                )\n\n    if mode == \"dst\" or mode == \"both\":\n        for e in n.dst_edges:\n            if edge_filter(e):\n                Node.walk(\n                    e.src,\n                    mode=mode,\n                    edge_filter=edge_filter,\n                    # edge_callback=edge_callback,\n                    node_filter=node_filter,\n                    node_callback=node_callback,\n                    _walk_history=_walk_history,\n                )\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeCreationFailed","title":"<code>NodeCreationFailed</code>","text":"<p>               Bases: <code>Exception</code></p> <p>An exception raised when trying to create a Node in the graph database fails</p> Source code in <code>roc/graphdb.py</code> <pre><code>class NodeCreationFailed(Exception):\n    \"\"\"An exception raised when trying to create a Node in the graph database fails\"\"\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeDescription","title":"<code>NodeDescription</code>","text":"<p>               Bases: <code>ModelDescription</code></p> Source code in <code>roc/graphdb.py</code> <pre><code>class NodeDescription(ModelDescription):\n    def __init__(self, node_cls: type[Node]) -&gt; None:\n        super().__init__(node_cls)\n\n        self.name = node_cls.__name__\n\n    def __str__(self) -&gt; str:\n        return f\"NodeDesc({self.name})\"\n\n    def to_mermaid(self, indent: int = 4) -&gt; str:\n        ret = f\"\"\"\\n{' ':&gt;{indent}}%% Node: {self.name}\\n\"\"\"\n\n        # add fields\n        for field in self.fields:\n            sym = \"+\" if is_local(self.model, field.name) else \"^\"\n            default_val = (\n                f\" = {field.default_val_str}\" if field.default_val is not PydanticUndefined else \"\"\n            )\n            ret += f\"\"\"{' ':&gt;{indent}}{self.name}: {sym}{field.type} {field.name}{default_val}\\n\"\"\"\n\n        # add methods\n        for method in self.methods:\n            sym = \"+\" if is_local(self.model, method.name) else \"^\"\n            params = \", \".join(method.uml_params)\n            ret += f\"\"\"{' ':&gt;{indent}}{self.name}: {sym}{method.name}({params}) {method.return_type}\\n\"\"\"\n\n        # add links to inherited nodes\n        for parent in self.parent_class_names:\n            ret += f\"\"\"{' ':&gt;{indent}}{self.name} ..|&gt; {parent}: inherits\\n\"\"\"\n\n        return ret\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeDescription.name","title":"<code>name = node_cls.__name__</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.NodeDescription.__init__","title":"<code>__init__(node_cls)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, node_cls: type[Node]) -&gt; None:\n    super().__init__(node_cls)\n\n    self.name = node_cls.__name__\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeDescription.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"NodeDesc({self.name})\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeDescription.to_mermaid","title":"<code>to_mermaid(indent=4)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def to_mermaid(self, indent: int = 4) -&gt; str:\n    ret = f\"\"\"\\n{' ':&gt;{indent}}%% Node: {self.name}\\n\"\"\"\n\n    # add fields\n    for field in self.fields:\n        sym = \"+\" if is_local(self.model, field.name) else \"^\"\n        default_val = (\n            f\" = {field.default_val_str}\" if field.default_val is not PydanticUndefined else \"\"\n        )\n        ret += f\"\"\"{' ':&gt;{indent}}{self.name}: {sym}{field.type} {field.name}{default_val}\\n\"\"\"\n\n    # add methods\n    for method in self.methods:\n        sym = \"+\" if is_local(self.model, method.name) else \"^\"\n        params = \", \".join(method.uml_params)\n        ret += f\"\"\"{' ':&gt;{indent}}{self.name}: {sym}{method.name}({params}) {method.return_type}\\n\"\"\"\n\n    # add links to inherited nodes\n    for parent in self.parent_class_names:\n        ret += f\"\"\"{' ':&gt;{indent}}{self.name} ..|&gt; {parent}: inherits\\n\"\"\"\n\n    return ret\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeFetchIterator","title":"<code>NodeFetchIterator</code>","text":"<p>The implementation of an iterator for an NodeList. Only intended to be used internally by NodeList.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class NodeFetchIterator:\n    \"\"\"The implementation of an iterator for an NodeList. Only intended to be used internally by\n    NodeList.\n    \"\"\"\n\n    def __init__(self, node_list: list[NodeId]):\n        self._node_list = node_list\n        self.cur = 0\n\n    def __iter__(self) -&gt; NodeFetchIterator:\n        return self\n\n    def __next__(self) -&gt; Node:\n        if self.cur &gt;= len(self._node_list):\n            raise StopIteration\n\n        id = self._node_list[self.cur]\n        self.cur = self.cur + 1\n        return Node.get(id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeFetchIterator.cur","title":"<code>cur = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.NodeFetchIterator.__init__","title":"<code>__init__(node_list)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, node_list: list[NodeId]):\n    self._node_list = node_list\n    self.cur = 0\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeFetchIterator.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __iter__(self) -&gt; NodeFetchIterator:\n    return self\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeFetchIterator.__next__","title":"<code>__next__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __next__(self) -&gt; Node:\n    if self.cur &gt;= len(self._node_list):\n        raise StopIteration\n\n    id = self._node_list[self.cur]\n    self.cur = self.cur + 1\n    return Node.get(id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeList","title":"<code>NodeList</code>","text":"<p>               Bases: <code>MutableSet[Node | NodeId]</code>, <code>Mapping[int, Node]</code></p> <p>A list of Nodes. Implements interfaces for both a MutableSet (i.e. set()) and a Mapping (i.e. read-only dict())</p> Source code in <code>roc/graphdb.py</code> <pre><code>class NodeList(MutableSet[Node | NodeId], Mapping[int, Node]):\n    \"\"\"A list of Nodes. Implements interfaces for both a MutableSet (i.e. set())\n    and a Mapping (i.e. read-only dict())\n    \"\"\"\n\n    def __init__(self, ids: Iterable[NodeId]):\n        self._nodes: list[NodeId] = list(ids)\n\n    def __iter__(self) -&gt; NodeFetchIterator:\n        return NodeFetchIterator(self._nodes)\n\n    def __getitem__(self, key: int) -&gt; Node:\n        return Node.get(self._nodes[key])\n\n    def __len__(self) -&gt; int:\n        return len(self._nodes)\n\n    def __contains__(self, n: Any) -&gt; bool:\n        if isinstance(n, Node) or isinstance(n, int):\n            n_id = Node.to_id(n)  # type: ignore\n        else:\n            return False\n\n        return n_id in self._nodes\n\n    def __add__(self, l2: NodeList) -&gt; NodeList:\n        return NodeList(self._nodes + l2._nodes)\n\n    def add(self, n: Node | NodeId) -&gt; None:\n        \"\"\"Adds a new Node to the list\"\"\"\n        n_id = Node.to_id(n)\n\n        if n_id in self._nodes:\n            return\n\n        self._nodes.append(n_id)\n\n    def discard(self, n: Node | NodeId) -&gt; None:\n        \"\"\"Removes an Node from the list\"\"\"\n        n_id = Node.to_id(n)\n\n        self._nodes.remove(n_id)\n\n    def select(\n        self,\n        *,\n        filter_fn: NodeFilterFn | None = None,\n        labels: set[str] | str | None = None,\n    ) -&gt; NodeList:\n        node_ids = self._nodes\n        if filter_fn is not None:\n            Node.get_many(node_ids)\n            node_ids = [n for n in node_ids if filter_fn(Node.get(n))]\n\n        if labels is not None:\n            labels = set(labels) if isinstance(labels, str) else labels\n            node_ids = [n for n in node_ids if Node.get(n).labels == labels]\n\n        return NodeList(node_ids)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeList.__add__","title":"<code>__add__(l2)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __add__(self, l2: NodeList) -&gt; NodeList:\n    return NodeList(self._nodes + l2._nodes)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeList.__contains__","title":"<code>__contains__(n)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __contains__(self, n: Any) -&gt; bool:\n    if isinstance(n, Node) or isinstance(n, int):\n        n_id = Node.to_id(n)  # type: ignore\n    else:\n        return False\n\n    return n_id in self._nodes\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeList.__getitem__","title":"<code>__getitem__(key)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __getitem__(self, key: int) -&gt; Node:\n    return Node.get(self._nodes[key])\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeList.__init__","title":"<code>__init__(ids)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, ids: Iterable[NodeId]):\n    self._nodes: list[NodeId] = list(ids)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeList.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __iter__(self) -&gt; NodeFetchIterator:\n    return NodeFetchIterator(self._nodes)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeList.__len__","title":"<code>__len__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self._nodes)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeList.add","title":"<code>add(n)</code>","text":"<p>Adds a new Node to the list</p> Source code in <code>roc/graphdb.py</code> <pre><code>def add(self, n: Node | NodeId) -&gt; None:\n    \"\"\"Adds a new Node to the list\"\"\"\n    n_id = Node.to_id(n)\n\n    if n_id in self._nodes:\n        return\n\n    self._nodes.append(n_id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeList.discard","title":"<code>discard(n)</code>","text":"<p>Removes an Node from the list</p> Source code in <code>roc/graphdb.py</code> <pre><code>def discard(self, n: Node | NodeId) -&gt; None:\n    \"\"\"Removes an Node from the list\"\"\"\n    n_id = Node.to_id(n)\n\n    self._nodes.remove(n_id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeList.select","title":"<code>select(*, filter_fn=None, labels=None)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def select(\n    self,\n    *,\n    filter_fn: NodeFilterFn | None = None,\n    labels: set[str] | str | None = None,\n) -&gt; NodeList:\n    node_ids = self._nodes\n    if filter_fn is not None:\n        Node.get_many(node_ids)\n        node_ids = [n for n in node_ids if filter_fn(Node.get(n))]\n\n    if labels is not None:\n        labels = set(labels) if isinstance(labels, str) else labels\n        node_ids = [n for n in node_ids if Node.get(n).labels == labels]\n\n    return NodeList(node_ids)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeNotFound","title":"<code>NodeNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>An exception raised when trying to retreive a Node that doesn't exist.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class NodeNotFound(Exception):\n    \"\"\"An exception raised when trying to retreive a Node that doesn't exist.\"\"\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Schema","title":"<code>Schema</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>class Schema:\n    def __init__(self, skip_validation: bool = False) -&gt; None:\n        if not skip_validation:\n            self.validate()\n\n        # edges\n        self.edge_names = set(edge_registry.keys())\n        self.edges = [EdgeDescription(edge_cls) for edge_cls in edge_registry.values()]\n        self.edges.sort(key=lambda e: e.name)\n\n        # nodes\n        self.node_names = set(node_registry.keys())\n        self.nodes = [NodeDescription(node_cls) for node_cls in node_registry.values()]\n        self.nodes.sort(key=lambda n: n.name)\n\n    @classmethod\n    def validate(cls) -&gt; None:\n        errors: list[str] = []\n        for edge_name, edge_cls in edge_registry.items():\n            allowed_connections = pydantic_get_default(edge_cls, \"allowed_connections\")\n\n            if allowed_connections is None:\n                continue\n\n            for src, dst in allowed_connections:\n                if src not in node_registry:\n                    errors.append(\n                        f\"Edge '{edge_name}' requires src Node '{src}', which is not registered\"\n                    )\n\n                if dst not in node_registry:\n                    errors.append(\n                        f\"Edge '{edge_name}' requires dst Node '{dst}', which is not registered\"\n                    )\n\n        if len(errors) &gt; 0:\n            raise SchemaValidationError(errors)\n\n    def to_mermaid(self) -&gt; str:\n        ret = \"classDiagram\\n\"\n\n        # nodes\n        for n in self.nodes:\n            ret += n.to_mermaid()\n\n        # edges\n        for e in self.edges:\n            ret += e.to_mermaid()\n\n        return ret\n\n    @classmethod\n    def _repr_markdown_(cls) -&gt; str:\n        return f\"``` mermaid\\n{Schema().to_mermaid()}\\n```\\n\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Schema.edge_names","title":"<code>edge_names = set(edge_registry.keys())</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Schema.edges","title":"<code>edges = [EdgeDescription(edge_cls) for edge_cls in edge_registry.values()]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Schema.node_names","title":"<code>node_names = set(node_registry.keys())</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Schema.nodes","title":"<code>nodes = [NodeDescription(node_cls) for node_cls in node_registry.values()]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Schema.__init__","title":"<code>__init__(skip_validation=False)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, skip_validation: bool = False) -&gt; None:\n    if not skip_validation:\n        self.validate()\n\n    # edges\n    self.edge_names = set(edge_registry.keys())\n    self.edges = [EdgeDescription(edge_cls) for edge_cls in edge_registry.values()]\n    self.edges.sort(key=lambda e: e.name)\n\n    # nodes\n    self.node_names = set(node_registry.keys())\n    self.nodes = [NodeDescription(node_cls) for node_cls in node_registry.values()]\n    self.nodes.sort(key=lambda n: n.name)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Schema.to_mermaid","title":"<code>to_mermaid()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def to_mermaid(self) -&gt; str:\n    ret = \"classDiagram\\n\"\n\n    # nodes\n    for n in self.nodes:\n        ret += n.to_mermaid()\n\n    # edges\n    for e in self.edges:\n        ret += e.to_mermaid()\n\n    return ret\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Schema.validate","title":"<code>validate()</code>  <code>classmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef validate(cls) -&gt; None:\n    errors: list[str] = []\n    for edge_name, edge_cls in edge_registry.items():\n        allowed_connections = pydantic_get_default(edge_cls, \"allowed_connections\")\n\n        if allowed_connections is None:\n            continue\n\n        for src, dst in allowed_connections:\n            if src not in node_registry:\n                errors.append(\n                    f\"Edge '{edge_name}' requires src Node '{src}', which is not registered\"\n                )\n\n            if dst not in node_registry:\n                errors.append(\n                    f\"Edge '{edge_name}' requires dst Node '{dst}', which is not registered\"\n                )\n\n    if len(errors) &gt; 0:\n        raise SchemaValidationError(errors)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.SchemaValidationError","title":"<code>SchemaValidationError</code>","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>roc/graphdb.py</code> <pre><code>class SchemaValidationError(Exception):\n    def __init__(self, errors: list[str]) -&gt; None:\n        err_str = \"\"\n        self.errors = errors\n\n        for errno in range(len(errors)):\n            err = errors[errno]\n            err_str += f\"\\t{errno}: {err}\\n\"\n\n        super().__init__(f\"Error validating schema:\\n{err_str}\")\n</code></pre>"},{"location":"reference/graphdb/#graphdb.SchemaValidationError.errors","title":"<code>errors = errors</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.SchemaValidationError.__init__","title":"<code>__init__(errors)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, errors: list[str]) -&gt; None:\n    err_str = \"\"\n    self.errors = errors\n\n    for errno in range(len(errors)):\n        err = errors[errno]\n        err_str += f\"\\t{errno}: {err}\\n\"\n\n    super().__init__(f\"Error validating schema:\\n{err_str}\")\n</code></pre>"},{"location":"reference/graphdb/#graphdb.StrictSchemaWarning","title":"<code>StrictSchemaWarning</code>","text":"<p>               Bases: <code>Warning</code></p> <p>A warning that strict schema mode is enabled, but there was a violation</p> Source code in <code>roc/graphdb.py</code> <pre><code>class StrictSchemaWarning(Warning):\n    \"\"\"A warning that strict schema mode is enabled, but there was a violation\"\"\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.check_schema","title":"<code>check_schema(edge_cls, clstype, src, dst, db)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def check_schema(\n    edge_cls: type[Edge],\n    clstype: str,\n    src: Node,\n    dst: Node,\n    db: GraphDB,\n) -&gt; None:\n    allowed_connections = pydantic_get_default(edge_cls, \"allowed_connections\")\n    src_name = src.__class__.__name__\n    src_names = get_node_parent_names(src.__class__)\n    src_names.add(src_name)\n\n    dst_name = dst.__class__.__name__\n    dst_names = get_node_parent_names(dst.__class__)\n    dst_names.add(dst_name)\n\n    # check if the src (or it's parents) are allowed to connect to dst (or it's parents)\n    if allowed_connections is not None:\n        found = False\n        for conn in allowed_connections:\n            if conn[0] in src_names and conn[1] in dst_names:\n                found = True\n                break\n\n        if not found:\n            raise Exception(\n                f\"attempting to connect edge '{clstype}' from '{src_name}' to '{dst_name}' not in allowed connections list\"\n            )\n    # no allowed_connections set, which is a no-no for strict mode\n    elif db.strict_schema:\n        err_msg = f\"allowed_connections missing in '{edge_cls.__name__}' and strict_schema is set\"\n        if db.strict_schema_warns:\n            warnings.warn(err_msg, StrictSchemaWarning)\n        else:\n            raise Exception(err_msg)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.clean_annotation","title":"<code>clean_annotation(annotation)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def clean_annotation(annotation: Any) -&gt; str:\n    import typing\n\n    if isinstance(annotation, str):\n        return annotation\n    elif annotation is None:\n        return \"None\"\n    elif isinstance(annotation, typing._GenericAlias):  # type: ignore\n        # Handle generics like List, Dict, etc.\n        origin = annotation.__origin__\n        args = [clean_annotation(arg) for arg in annotation.__args__]\n        return f\"{origin.__name__}[{', '.join(args)}]\"\n    elif isinstance(annotation, _SpecialForm):\n        # Handle special forms like Any, Union, etc.\n        return annotation._name  # type: ignore\n    else:\n        return annotation.__name__  # type: ignore\n</code></pre>"},{"location":"reference/graphdb/#graphdb.get_methods","title":"<code>get_methods(c)</code>  <code>cached</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@functools.cache\ndef get_methods(c: type[object]) -&gt; set[str]:\n    return {name for name, member in inspect.getmembers(c) if inspect.isfunction(member)}\n</code></pre>"},{"location":"reference/graphdb/#graphdb.get_next_new_edge_id","title":"<code>get_next_new_edge_id()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def get_next_new_edge_id() -&gt; EdgeId:\n    global next_new_edge\n    id = next_new_edge\n    next_new_edge = cast(EdgeId, next_new_edge - 1)\n\n    return id\n</code></pre>"},{"location":"reference/graphdb/#graphdb.get_next_new_node_id","title":"<code>get_next_new_node_id()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def get_next_new_node_id() -&gt; NodeId:\n    global next_new_node\n    id = next_new_node\n    next_new_node = cast(NodeId, next_new_node - 1)\n    return id\n</code></pre>"},{"location":"reference/graphdb/#graphdb.get_node_parent_names","title":"<code>get_node_parent_names(model)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def get_node_parent_names(model: type[BaseModel]) -&gt; set[str]:\n    ret = {c.__name__ for c in model.__mro__ if Node in c.__mro__}\n    if model.__name__ in ret:\n        ret.remove(model.__name__)\n    if \"Node\" in ret:\n        ret.remove(\"Node\")\n\n    return ret\n</code></pre>"},{"location":"reference/graphdb/#graphdb.is_local","title":"<code>is_local(c, attr)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def is_local(c: type[object], attr: str) -&gt; bool:\n    if attr in c.__dict__:\n        return True\n\n    if hasattr(c, \"__wrapped__\"):\n        return is_local(c.__wrapped__, attr)\n\n    return False\n</code></pre>"},{"location":"reference/graphdb/#graphdb.no_callback","title":"<code>no_callback(_)</code>","text":"<p>Helper function that accepts any value and returns None. Great for default callback functions.</p> Source code in <code>roc/graphdb.py</code> <pre><code>def no_callback(_: Any) -&gt; None:\n    \"\"\"Helper function that accepts any value and returns None. Great for\n    default callback functions.\n    \"\"\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.pydantic_get_default","title":"<code>pydantic_get_default(m, f)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def pydantic_get_default(m: type[BaseModel], f: str) -&gt; Any:\n    return m.model_fields[f].get_default(call_default_factory=True)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.pydantic_get_field","title":"<code>pydantic_get_field(m, f)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def pydantic_get_field(m: type[BaseModel], f: str) -&gt; FieldInfo:\n    return m.model_fields[f]\n</code></pre>"},{"location":"reference/graphdb/#graphdb.pydantic_get_fields","title":"<code>pydantic_get_fields(m)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def pydantic_get_fields(m: type[BaseModel]) -&gt; set[str]:\n    return set(m.model_fields.keys())\n</code></pre>"},{"location":"reference/graphdb/#graphdb.true_filter","title":"<code>true_filter(_)</code>","text":"<p>Helper function that accepts any value and returns True. Great for default filters.</p> Source code in <code>roc/graphdb.py</code> <pre><code>def true_filter(_: Any) -&gt; bool:\n    \"\"\"Helper function that accepts any value and returns True. Great for\n    default filters.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"reference/gymnasium/","title":"gymnasium","text":"<p>This module is a wrapper around the Gym / Gymnasium interfaces and drives all the interactions between the agent and the system, including the main event loop.</p>"},{"location":"reference/gymnasium/#gymnasium.count","title":"<code>count = 0</code>  <code>module-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.dump_env_file","title":"<code>dump_env_file: Any = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats","title":"<code>BottomlineStats</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A Pydantic model representing the Nethack bottom line statistics.</p> Source code in <code>roc/gymnasium.py</code> <pre><code>class BottomlineStats(BaseModel):\n    \"\"\"A Pydantic model representing the Nethack bottom line statistics.\"\"\"\n\n    x: int\n    y: int\n    str25: int\n    str125: int\n    dex: int\n    con: int\n    intel: int = Field(alias=\"int\")\n    wis: int\n    cha: int\n    score: int\n    hp: int\n    hpmax: int\n    depth: int\n    gold: int\n    ene: int\n    enemax: int\n    ac: int\n    hd: int\n    xp: int\n    exp: int\n    time: int\n    hunger: int\n    cap: int\n    dnum: int\n    dlevel: int\n    condition: int\n    align: int\n    stone: bool\n    slime: bool\n    stringl: bool\n    foodpois: bool\n    termill: bool\n    blind: bool\n    deaf: bool\n    stun: bool\n    conf: bool\n    hallu: bool\n    lev: bool\n    fly: bool\n    ride: bool\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.ac","title":"<code>ac: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.align","title":"<code>align: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.blind","title":"<code>blind: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.cap","title":"<code>cap: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.cha","title":"<code>cha: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.con","title":"<code>con: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.condition","title":"<code>condition: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.conf","title":"<code>conf: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.deaf","title":"<code>deaf: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.depth","title":"<code>depth: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.dex","title":"<code>dex: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.dlevel","title":"<code>dlevel: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.dnum","title":"<code>dnum: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.ene","title":"<code>ene: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.enemax","title":"<code>enemax: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.exp","title":"<code>exp: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.fly","title":"<code>fly: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.foodpois","title":"<code>foodpois: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.gold","title":"<code>gold: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.hallu","title":"<code>hallu: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.hd","title":"<code>hd: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.hp","title":"<code>hp: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.hpmax","title":"<code>hpmax: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.hunger","title":"<code>hunger: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.intel","title":"<code>intel: int = Field(alias='int')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.lev","title":"<code>lev: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.ride","title":"<code>ride: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.score","title":"<code>score: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.slime","title":"<code>slime: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.stone","title":"<code>stone: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.str125","title":"<code>str125: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.str25","title":"<code>str25: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.stringl","title":"<code>stringl: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.stun","title":"<code>stun: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.termill","title":"<code>termill: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.time","title":"<code>time: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.wis","title":"<code>wis: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.x","title":"<code>x: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.xp","title":"<code>xp: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.y","title":"<code>y: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym","title":"<code>Gym</code>","text":"<p>               Bases: <code>Component</code>, <code>ABC</code></p> <p>A wrapper around an OpenAI Gym / Farama Gymnasium that drives the event loop and interfaces to the ROC agent.</p> Source code in <code>roc/gymnasium.py</code> <pre><code>class Gym(Component, ABC):\n    \"\"\"A wrapper around an OpenAI Gym / Farama Gymnasium that drives the event\n    loop and interfaces to the ROC agent.\n    \"\"\"\n\n    def __init__(self, gym_id: str, *, gym_opts: dict[str, Any] | None = None) -&gt; None:\n        super().__init__()\n        gym_opts = gym_opts or {}\n        logger.info(f\"Gym options: {gym_opts}\")\n        self.env = gym.make(gym_id, **gym_opts)\n\n        # setup communications\n        self.env_bus_conn = Perception.bus.connect(self)\n        self.action_bus_conn = Action.bus.connect(self)\n        self.intrinsic_bus_conn = Intrinsic.bus.connect(self)\n\n        # config\n        self.config(self.env)\n\n        # TODO: config environment\n        # setup which features detectors to use on each bus\n\n    @abstractmethod\n    def send_obs(self, obs: Any) -&gt; None: ...\n\n    @abstractmethod\n    def config(self, env: gym.core.Env[Any, Any]) -&gt; None: ...\n\n    @abstractmethod\n    def get_action(self) -&gt; Any: ...\n\n    @logger.catch\n    def start(self) -&gt; None:\n        obs, reset_info = self.env.reset()\n        settings = Config.get()\n\n        done = False\n        truncated = False\n        _dump_env_start()\n\n        logger.info(\"Starting NLE loop...\")\n        loop_num = 0\n        game_num = 0\n\n        # main environment loop\n        while game_num &lt; settings.num_games:\n            logger.trace(f\"Sending observation: {obs}\")\n            breakpoints.check()\n\n            # save the current screen\n            screen = nle.nethack.tty_render(obs[\"tty_chars\"], obs[\"tty_colors\"], obs[\"tty_cursor\"])\n            states.screen.set(screen)\n\n            # do all the real work\n            self.send_obs(obs)\n\n            # get an action\n            action = self.get_action()\n            logger.trace(f\"Doing action: {action}\")\n\n            # perform the action and get the next observation\n            obs, reward, done, truncated, info = self.env.step(action)\n\n            # optionally save the screen to file\n            _dump_env_record(obs, loop_num)\n\n            logger.trace(f\"Main loop done: {done}, {truncated}\")\n\n            # set and save the loop number\n            loop_num += 1\n            states.loop.set(loop_num)\n            if (loop_num % settings.status_update) == 0:\n                print_state()\n\n            if done or truncated:\n                logger.info(f\"Game {game_num} completed, starting next game\")\n                self.env.reset()\n                game_num += 1\n\n        logger.info(\"NLE loop done, exiting.\")\n        _dump_env_end()\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.action_bus_conn","title":"<code>action_bus_conn = Action.bus.connect(self)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.env","title":"<code>env = gym.make(gym_id, **gym_opts)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.env_bus_conn","title":"<code>env_bus_conn = Perception.bus.connect(self)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.intrinsic_bus_conn","title":"<code>intrinsic_bus_conn = Intrinsic.bus.connect(self)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.__init__","title":"<code>__init__(gym_id, *, gym_opts=None)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def __init__(self, gym_id: str, *, gym_opts: dict[str, Any] | None = None) -&gt; None:\n    super().__init__()\n    gym_opts = gym_opts or {}\n    logger.info(f\"Gym options: {gym_opts}\")\n    self.env = gym.make(gym_id, **gym_opts)\n\n    # setup communications\n    self.env_bus_conn = Perception.bus.connect(self)\n    self.action_bus_conn = Action.bus.connect(self)\n    self.intrinsic_bus_conn = Intrinsic.bus.connect(self)\n\n    # config\n    self.config(self.env)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.config","title":"<code>config(env)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>@abstractmethod\ndef config(self, env: gym.core.Env[Any, Any]) -&gt; None: ...\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.get_action","title":"<code>get_action()</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>@abstractmethod\ndef get_action(self) -&gt; Any: ...\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.send_obs","title":"<code>send_obs(obs)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>@abstractmethod\ndef send_obs(self, obs: Any) -&gt; None: ...\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.start","title":"<code>start()</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>@logger.catch\ndef start(self) -&gt; None:\n    obs, reset_info = self.env.reset()\n    settings = Config.get()\n\n    done = False\n    truncated = False\n    _dump_env_start()\n\n    logger.info(\"Starting NLE loop...\")\n    loop_num = 0\n    game_num = 0\n\n    # main environment loop\n    while game_num &lt; settings.num_games:\n        logger.trace(f\"Sending observation: {obs}\")\n        breakpoints.check()\n\n        # save the current screen\n        screen = nle.nethack.tty_render(obs[\"tty_chars\"], obs[\"tty_colors\"], obs[\"tty_cursor\"])\n        states.screen.set(screen)\n\n        # do all the real work\n        self.send_obs(obs)\n\n        # get an action\n        action = self.get_action()\n        logger.trace(f\"Doing action: {action}\")\n\n        # perform the action and get the next observation\n        obs, reward, done, truncated, info = self.env.step(action)\n\n        # optionally save the screen to file\n        _dump_env_record(obs, loop_num)\n\n        logger.trace(f\"Main loop done: {done}, {truncated}\")\n\n        # set and save the loop number\n        loop_num += 1\n        states.loop.set(loop_num)\n        if (loop_num % settings.status_update) == 0:\n            print_state()\n\n        if done or truncated:\n            logger.info(f\"Game {game_num} completed, starting next game\")\n            self.env.reset()\n            game_num += 1\n\n    logger.info(\"NLE loop done, exiting.\")\n    _dump_env_end()\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym","title":"<code>NethackGym</code>","text":"<p>               Bases: <code>Gym</code></p> <p>Wrapper around the Gym class for driving the Nethack interface to the ROC agent. Decodes Nethack specific data and sends it to the agent as Events.</p> Source code in <code>roc/gymnasium.py</code> <pre><code>class NethackGym(Gym):\n    \"\"\"Wrapper around the Gym class for driving the Nethack interface to the ROC\n    agent. Decodes Nethack specific data and sends it to the agent as Events.\n    \"\"\"\n\n    def __init__(self, *, gym_opts: dict[str, Any] | None = None) -&gt; None:\n        gym_opts = gym_opts or {}\n        settings = Config.get()\n        gym_opts[\"options\"] = list(nle.nethack.NETHACKOPTIONS) + settings.nethack_extra_options\n        gym_opts[\"max_episode_steps\"] = settings.nethack_max_turns\n        # XXX: note that 'gym_opts[\"character\"]' sets the character type, not\n        # the player name... player name is forced to be \"Agent\" by NLE\n\n        # XXX: env name options include: \"NetHack\", \"NetHackScore\", \"NetHackStaircase\", \"NetHackStaircasePet\", \"NetHackOracle\", \"NetHackGold\", \"NetHackEat\", \"NetHackScout\", \"NetHackChallenge\"\n        # see: https://github.com/heiner/nle/blob/731f2aaa94f6d67838228f9c9b5b04faa31cb862/nle/env/__init__.py#L9\n        # and: https://github.com/heiner/nle/blob/731f2aaa94f6d67838228f9c9b5b04faa31cb862/nle/env/tasks.py\n        # \"NetHack\" is the vanilla environment\n        # \"NetHackScore\" and \"NetHackChallenge\" also appear to be interesting\n        super().__init__(\"NetHack-v0\", gym_opts=gym_opts)\n\n    def config(self, env: gym.core.Env[Any, Any]) -&gt; None:\n        settings = Config.get()\n        assert isinstance(self.env.action_space, gym.spaces.Discrete)\n        self.action_count = int(self.env.action_space.n)\n\n        settings.gym_actions = tuple(self.env.unwrapped.actions)  # type: ignore\n        settings.observation_shape = nle.nethack.DUNGEON_SHAPE\n\n    def send_obs(self, obs: Any) -&gt; None:\n        self.send_vision(obs)\n        self.send_intrinsics(obs)\n        self.send_auditory(obs)\n\n    def get_action(self) -&gt; Any:\n        self.action_bus_conn.send(ActionRequest())\n\n        # get result using cache\n        assert self.action_bus_conn.attached_bus.cache is not None\n        cache = self.action_bus_conn.attached_bus.cache\n        a = list(filter(lambda e: isinstance(e.data, TakeAction), cache))[-1]\n        assert isinstance(a.data, TakeAction)\n\n        return a.data.action\n\n    def send_vision(self, obs: Any) -&gt; None:\n        vd = VisionData.from_dict(obs)\n        self.env_bus_conn.send(vd)\n\n    def send_auditory(self, obs: Any) -&gt; None:\n        # msg = \"\".join(chr(ch) for ch in obs[\"message\"])\n        # print(\"message\", msg)\n        pass\n\n    def send_proprioceptive(self) -&gt; None:\n        pass\n\n    def send_intrinsics(self, obs: Any) -&gt; None:\n        blstats = obs[\"blstats\"]\n        blstats_vals = {e.name.lower(): blstats[e.value] for e in blstat_offsets}\n        for bit in condition_bits:\n            blstats_vals[bit.name.lower()] = (\n                True if blstats_vals[\"condition\"] &amp; bit.value else False\n            )\n\n        bl = BottomlineStats(**blstats_vals)\n        self.intrinsic_bus_conn.send(bl.dict())\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.__init__","title":"<code>__init__(*, gym_opts=None)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def __init__(self, *, gym_opts: dict[str, Any] | None = None) -&gt; None:\n    gym_opts = gym_opts or {}\n    settings = Config.get()\n    gym_opts[\"options\"] = list(nle.nethack.NETHACKOPTIONS) + settings.nethack_extra_options\n    gym_opts[\"max_episode_steps\"] = settings.nethack_max_turns\n    # XXX: note that 'gym_opts[\"character\"]' sets the character type, not\n    # the player name... player name is forced to be \"Agent\" by NLE\n\n    # XXX: env name options include: \"NetHack\", \"NetHackScore\", \"NetHackStaircase\", \"NetHackStaircasePet\", \"NetHackOracle\", \"NetHackGold\", \"NetHackEat\", \"NetHackScout\", \"NetHackChallenge\"\n    # see: https://github.com/heiner/nle/blob/731f2aaa94f6d67838228f9c9b5b04faa31cb862/nle/env/__init__.py#L9\n    # and: https://github.com/heiner/nle/blob/731f2aaa94f6d67838228f9c9b5b04faa31cb862/nle/env/tasks.py\n    # \"NetHack\" is the vanilla environment\n    # \"NetHackScore\" and \"NetHackChallenge\" also appear to be interesting\n    super().__init__(\"NetHack-v0\", gym_opts=gym_opts)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.config","title":"<code>config(env)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def config(self, env: gym.core.Env[Any, Any]) -&gt; None:\n    settings = Config.get()\n    assert isinstance(self.env.action_space, gym.spaces.Discrete)\n    self.action_count = int(self.env.action_space.n)\n\n    settings.gym_actions = tuple(self.env.unwrapped.actions)  # type: ignore\n    settings.observation_shape = nle.nethack.DUNGEON_SHAPE\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.get_action","title":"<code>get_action()</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def get_action(self) -&gt; Any:\n    self.action_bus_conn.send(ActionRequest())\n\n    # get result using cache\n    assert self.action_bus_conn.attached_bus.cache is not None\n    cache = self.action_bus_conn.attached_bus.cache\n    a = list(filter(lambda e: isinstance(e.data, TakeAction), cache))[-1]\n    assert isinstance(a.data, TakeAction)\n\n    return a.data.action\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.send_auditory","title":"<code>send_auditory(obs)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def send_auditory(self, obs: Any) -&gt; None:\n    # msg = \"\".join(chr(ch) for ch in obs[\"message\"])\n    # print(\"message\", msg)\n    pass\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.send_intrinsics","title":"<code>send_intrinsics(obs)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def send_intrinsics(self, obs: Any) -&gt; None:\n    blstats = obs[\"blstats\"]\n    blstats_vals = {e.name.lower(): blstats[e.value] for e in blstat_offsets}\n    for bit in condition_bits:\n        blstats_vals[bit.name.lower()] = (\n            True if blstats_vals[\"condition\"] &amp; bit.value else False\n        )\n\n    bl = BottomlineStats(**blstats_vals)\n    self.intrinsic_bus_conn.send(bl.dict())\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.send_obs","title":"<code>send_obs(obs)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def send_obs(self, obs: Any) -&gt; None:\n    self.send_vision(obs)\n    self.send_intrinsics(obs)\n    self.send_auditory(obs)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.send_proprioceptive","title":"<code>send_proprioceptive()</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def send_proprioceptive(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.send_vision","title":"<code>send_vision(obs)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def send_vision(self, obs: Any) -&gt; None:\n    vd = VisionData.from_dict(obs)\n    self.env_bus_conn.send(vd)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.blstat_offsets","title":"<code>blstat_offsets</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>An enumeration of Nethack bottom line statistics (intelligence, strength, charisma, position, hit points, etc.)</p> Source code in <code>roc/gymnasium.py</code> <pre><code>class blstat_offsets(IntEnum):\n    \"\"\"An enumeration of Nethack bottom line statistics (intelligence, strength,\n    charisma, position, hit points, etc.)\n    \"\"\"\n\n    # fmt: off\n    X =         0\n    Y =         1\n    STR25 =     2\n    STR125 =    3\n    DEX =       4\n    CON =       5\n    INT =       6\n    WIS =       7\n    CHA =       8\n    SCORE =     9\n    HP =        10\n    HPMAX =     11\n    DEPTH =     12\n    GOLD =      13\n    ENE =       14\n    ENEMAX =    15\n    AC =        16\n    HD =        17\n    XP =        18\n    EXP =       19\n    TIME =      20\n    HUNGER =    21\n    CAP =       22\n    DNUM =      23\n    DLEVEL =    24\n    CONDITION = 25\n    ALIGN =     26\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.AC","title":"<code>AC = 16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.ALIGN","title":"<code>ALIGN = 26</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.CAP","title":"<code>CAP = 22</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.CHA","title":"<code>CHA = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.CON","title":"<code>CON = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.CONDITION","title":"<code>CONDITION = 25</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.DEPTH","title":"<code>DEPTH = 12</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.DEX","title":"<code>DEX = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.DLEVEL","title":"<code>DLEVEL = 24</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.DNUM","title":"<code>DNUM = 23</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.ENE","title":"<code>ENE = 14</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.ENEMAX","title":"<code>ENEMAX = 15</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.EXP","title":"<code>EXP = 19</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.GOLD","title":"<code>GOLD = 13</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.HD","title":"<code>HD = 17</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.HP","title":"<code>HP = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.HPMAX","title":"<code>HPMAX = 11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.HUNGER","title":"<code>HUNGER = 21</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.INT","title":"<code>INT = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.SCORE","title":"<code>SCORE = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.STR125","title":"<code>STR125 = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.STR25","title":"<code>STR25 = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.TIME","title":"<code>TIME = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.WIS","title":"<code>WIS = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.X","title":"<code>X = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.XP","title":"<code>XP = 18</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.Y","title":"<code>Y = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits","title":"<code>condition_bits</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Bits for decoding the <code>CONDITION</code> bottomline stat to determin if the player is flying, deaf, food poisoned, etc.</p> Source code in <code>roc/gymnasium.py</code> <pre><code>class condition_bits(IntEnum):\n    \"\"\"Bits for decoding the `CONDITION` bottomline stat to determin if the\n    player is flying, deaf, food poisoned, etc.\n    \"\"\"\n\n    # fmt: off\n    STONE =    nle.nethack.BL_MASK_STONE\n    SLIME =    nle.nethack.BL_MASK_SLIME\n    STRINGL =  nle.nethack.BL_MASK_STRNGL\n    FOODPOIS = nle.nethack.BL_MASK_FOODPOIS\n    TERMILL =  nle.nethack.BL_MASK_TERMILL\n    BLIND =    nle.nethack.BL_MASK_BLIND\n    DEAF =     nle.nethack.BL_MASK_DEAF\n    STUN =     nle.nethack.BL_MASK_STUN\n    CONF =     nle.nethack.BL_MASK_CONF\n    HALLU =    nle.nethack.BL_MASK_HALLU\n    LEV =      nle.nethack.BL_MASK_LEV\n    FLY =      nle.nethack.BL_MASK_FLY\n    RIDE =     nle.nethack.BL_MASK_RIDE\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.condition_bits.BLIND","title":"<code>BLIND = nle.nethack.BL_MASK_BLIND</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.CONF","title":"<code>CONF = nle.nethack.BL_MASK_CONF</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.DEAF","title":"<code>DEAF = nle.nethack.BL_MASK_DEAF</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.FLY","title":"<code>FLY = nle.nethack.BL_MASK_FLY</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.FOODPOIS","title":"<code>FOODPOIS = nle.nethack.BL_MASK_FOODPOIS</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.HALLU","title":"<code>HALLU = nle.nethack.BL_MASK_HALLU</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.LEV","title":"<code>LEV = nle.nethack.BL_MASK_LEV</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.RIDE","title":"<code>RIDE = nle.nethack.BL_MASK_RIDE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.SLIME","title":"<code>SLIME = nle.nethack.BL_MASK_SLIME</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.STONE","title":"<code>STONE = nle.nethack.BL_MASK_STONE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.STRINGL","title":"<code>STRINGL = nle.nethack.BL_MASK_STRNGL</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.STUN","title":"<code>STUN = nle.nethack.BL_MASK_STUN</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.TERMILL","title":"<code>TERMILL = nle.nethack.BL_MASK_TERMILL</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/intrinsic/","title":"intrinsic","text":""},{"location":"reference/intrinsic/#intrinsic.IntrinsicData","title":"<code>IntrinsicData = dict[str, Any]</code>  <code>module-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.IntrinsicEvent","title":"<code>IntrinsicEvent = Event[IntrinsicData]</code>  <code>module-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.IntrinsicType","title":"<code>IntrinsicType = TypeVar('IntrinsicType')</code>  <code>module-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.Intrinsic","title":"<code>Intrinsic</code>","text":"<p>               Bases: <code>Component</code></p> Source code in <code>roc/intrinsic.py</code> <pre><code>@register_component(\"intrinsic\", \"intrinsic\", auto=True)\nclass Intrinsic(Component):\n    bus = EventBus[IntrinsicData](\"intrinsic\")\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.int_conn = self.connect_bus(Intrinsic.bus)\n        self.int_conn.listen(self.do_intrinsic)\n\n    def event_filter(self, e: IntrinsicEvent) -&gt; bool:\n        return True\n\n    def do_intrinsic(self, e: IntrinsicEvent) -&gt; None:\n        return None\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.Intrinsic.bus","title":"<code>bus = EventBus[IntrinsicData]('intrinsic')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.Intrinsic.int_conn","title":"<code>int_conn = self.connect_bus(Intrinsic.bus)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.Intrinsic.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.int_conn = self.connect_bus(Intrinsic.bus)\n    self.int_conn.listen(self.do_intrinsic)\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.Intrinsic.do_intrinsic","title":"<code>do_intrinsic(e)</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>def do_intrinsic(self, e: IntrinsicEvent) -&gt; None:\n    return None\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.Intrinsic.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>def event_filter(self, e: IntrinsicEvent) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.IntrinsicBoolOp","title":"<code>IntrinsicBoolOp</code>","text":"<p>               Bases: <code>IntrinsicOp[bool]</code></p> Source code in <code>roc/intrinsic.py</code> <pre><code>class IntrinsicBoolOp(IntrinsicOp[bool]):\n    def validate(self, val: bool) -&gt; bool:\n        return True\n\n    def normalize(self, val: bool) -&gt; float:\n        if val:\n            return 1.0\n\n        return 0.0\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.IntrinsicBoolOp.normalize","title":"<code>normalize(val)</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>def normalize(self, val: bool) -&gt; float:\n    if val:\n        return 1.0\n\n    return 0.0\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.IntrinsicBoolOp.validate","title":"<code>validate(val)</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>def validate(self, val: bool) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.IntrinsicIntOp","title":"<code>IntrinsicIntOp</code>","text":"<p>               Bases: <code>IntrinsicOp[int]</code></p> Source code in <code>roc/intrinsic.py</code> <pre><code>class IntrinsicIntOp(IntrinsicOp[int]):\n    def __init__(self, name: str, min: int, max: int) -&gt; None:\n        super().__init__(name)\n        self.min = min\n        self.max = max\n        self.range = abs(min) + abs(max)\n\n    def validate(self, val: int) -&gt; bool:\n        if (val &lt; self.min) or (val &gt; self.max):\n            return False\n\n        return True\n\n    def normalize(self, val: int) -&gt; float:\n        return (val + abs(self.min)) / self.range\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.IntrinsicIntOp.max","title":"<code>max = max</code>  <code>instance-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.IntrinsicIntOp.min","title":"<code>min = min</code>  <code>instance-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.IntrinsicIntOp.range","title":"<code>range = abs(min) + abs(max)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.IntrinsicIntOp.__init__","title":"<code>__init__(name, min, max)</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>def __init__(self, name: str, min: int, max: int) -&gt; None:\n    super().__init__(name)\n    self.min = min\n    self.max = max\n    self.range = abs(min) + abs(max)\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.IntrinsicIntOp.normalize","title":"<code>normalize(val)</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>def normalize(self, val: int) -&gt; float:\n    return (val + abs(self.min)) / self.range\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.IntrinsicIntOp.validate","title":"<code>validate(val)</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>def validate(self, val: int) -&gt; bool:\n    if (val &lt; self.min) or (val &gt; self.max):\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.IntrinsicOp","title":"<code>IntrinsicOp</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[IntrinsicType]</code></p> Source code in <code>roc/intrinsic.py</code> <pre><code>class IntrinsicOp(ABC, Generic[IntrinsicType]):\n    def __init__(self, name: str) -&gt; None:\n        self.name = name\n\n    @abstractmethod\n    def validate(self, val: IntrinsicType) -&gt; bool: ...\n\n    @abstractmethod\n    def normalize(self, val: IntrinsicType) -&gt; float: ...\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.IntrinsicOp.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.IntrinsicOp.__init__","title":"<code>__init__(name)</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    self.name = name\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.IntrinsicOp.normalize","title":"<code>normalize(val)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>@abstractmethod\ndef normalize(self, val: IntrinsicType) -&gt; float: ...\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.IntrinsicOp.validate","title":"<code>validate(val)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>@abstractmethod\ndef validate(self, val: IntrinsicType) -&gt; bool: ...\n</code></pre>"},{"location":"reference/location/","title":"location","text":""},{"location":"reference/location/#location.GridType","title":"<code>GridType = TypeVar('GridType')</code>  <code>module-attribute</code>","text":""},{"location":"reference/location/#location.LocationTuple","title":"<code>LocationTuple = tuple[XLoc, YLoc]</code>  <code>module-attribute</code>","text":""},{"location":"reference/location/#location.PointList","title":"<code>PointList = list[Point]</code>  <code>module-attribute</code>","text":""},{"location":"reference/location/#location.ValLocTuple","title":"<code>ValLocTuple = tuple[XLoc, YLoc, GridType]</code>  <code>module-attribute</code>","text":""},{"location":"reference/location/#location.XLoc","title":"<code>XLoc = NewType('XLoc', int)</code>  <code>module-attribute</code>","text":""},{"location":"reference/location/#location.YLoc","title":"<code>YLoc = NewType('YLoc', int)</code>  <code>module-attribute</code>","text":""},{"location":"reference/location/#location.ChangedPoint","title":"<code>ChangedPoint</code>","text":"<p>               Bases: <code>Point</code></p> <p>Represents a value changing from <code>old_val</code> to <code>val</code> at a given (x, y) location.</p> Source code in <code>roc/location.py</code> <pre><code>class ChangedPoint(Point):\n    \"\"\"Represents a value changing from `old_val` to `val` at a given (x, y) location.\"\"\"\n\n    def __init_(self, x: XLoc, y: YLoc, val: int, old_val: int) -&gt; None:\n        super().__init__(x, y, val)\n        self.old_val = old_val\n\n    def __repr__(self) -&gt; str:\n        return f\"({self.x}, {self.y}): {self.old_val} '{chr(self.old_val)}' -&gt; {self.val} '{chr(self.val)}'\"\n</code></pre>"},{"location":"reference/location/#location.ChangedPoint.__init_","title":"<code>__init_(x, y, val, old_val)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __init_(self, x: XLoc, y: YLoc, val: int, old_val: int) -&gt; None:\n    super().__init__(x, y, val)\n    self.old_val = old_val\n</code></pre>"},{"location":"reference/location/#location.ChangedPoint.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"({self.x}, {self.y}): {self.old_val} '{chr(self.old_val)}' -&gt; {self.val} '{chr(self.val)}'\"\n</code></pre>"},{"location":"reference/location/#location.DebugGrid","title":"<code>DebugGrid</code>","text":"<p>               Bases: <code>Grid[GridStyle]</code></p> Source code in <code>roc/location.py</code> <pre><code>class DebugGrid(Grid[GridStyle]):\n    def __new__(cls, grid: IntGrid) -&gt; DebugGrid:\n        # obj = np.ndarray((grid.height, grid.width), dtype=object).view(DebugGrid)\n        obj = np.array(\n            [\n                [\n                    GridStyle(\n                        front_hue=0,\n                        front_saturation=0,\n                        front_brightness=1,\n                        back_hue=0,\n                        back_saturation=1,\n                        back_brightness=0,\n                        val=chr(grid[row, col]),\n                        style=\"none\",\n                    )\n                    for col in range(grid.width)\n                ]\n                for row in range(grid.height)\n            ]\n        ).view(DebugGrid)\n        return obj\n\n    def __array_finalize__(self, obj: npt.NDArray[Any] | None) -&gt; None:\n        if obj is None:\n            return\n\n    # def __init__(self, grid: Grid[Any]) -&gt; None:\n    #     width = grid.width\n    #     height = grid.height\n    #     map: list[list[GridStyle]] = [\n    #         [\n    #             GridStyle(\n    #                 front_hue=0,\n    #                 front_saturation=0,\n    #                 front_brightness=1,\n    #                 back_hue=0,\n    #                 back_saturation=1,\n    #                 back_brightness=0,\n    #                 val=\" \",\n    #                 style=\"none\",\n    #             )\n    #             for col in range(width)\n    #         ]\n    #         for row in range(height)\n    #     ]\n    #     super().__init__(map)\n\n    #     # copy over all the values from the grid\n    #     for p in grid.points():\n    #         s = self.get_val(p.x, p.y)\n    #         s.val = chr(p.val)\n\n    def set_style(self, x: int, y: int, *, style: str | None = None, **kwargs: float) -&gt; None:\n        s = self.get_val(x, y)\n\n        if style:\n            s.style = style\n\n        for key, value in kwargs.items():\n            if value &lt; 0 or value &gt; 1:\n                raise Exception(\n                    f\"set_style expects values to be floats between 0 and 1, '{key}' was '{value}'\"\n                )\n\n            match key:\n                case \"front_hue\":\n                    s.front_hue = value\n                case \"front_brightness\":\n                    s.front_brightness = value\n                case \"front_saturation\":\n                    s.front_saturation = value\n                case \"back_hue\":\n                    s.back_hue = value\n                case \"back_brightness\":\n                    s.back_brightness = value\n                case \"back_saturation\":\n                    s.back_saturation = value\n                case _:\n                    raise Exception(f\"unknown key '{key}' in set_style\")\n\n    def get_front_rgb(self, x: int, y: int) -&gt; tuple[int, int, int]:\n        s = self.get_val(x, y)\n        rgb = hsv_to_rgb(s.front_hue, s.front_saturation, s.front_brightness)\n        ret = tuple(map(lambda c: round(c * 255), rgb))\n        assert len(ret) == 3\n        return ret\n\n    def get_back_rgb(self, x: int, y: int) -&gt; tuple[int, int, int]:\n        s = self.get_val(x, y)\n        rgb = hsv_to_rgb(s.back_hue, s.back_saturation, s.back_brightness)\n        ret = tuple(map(lambda c: round(c * 255), rgb))\n        assert len(ret) == 3\n        return ret\n\n    def __str__(self) -&gt; str:\n        ret = \"\"\n        for y in range(self.height):\n            for x in range(self.width):\n                s = self.get_val(x, y)\n                fr, fg, fb = self.get_front_rgb(x, y)\n                br, bg, bb = self.get_back_rgb(x, y)\n                ret += f\"{Fore.rgb(fr,fg,fb)}{Back.rgb(br,bg,bb)}{s.val}{Style.reset}\"\n            ret += \"\\n\"\n        return ret\n\n    @classmethod\n    def blue_to_red_hue(cls, val: float) -&gt; float:\n        \"\"\"Converts a floating point value to a point in a red-to-blue gradient,\n        where high values are red and lower values are blue. Good for\n        representing values in a range as a heat map for easy visualization of\n        higher values.\n\n        Args:\n            val (float): The value to convert.\n\n        Returns:\n            float: The hue in the red-to-blue gradient.\n        \"\"\"\n        # blue = 2/3\n        # blue to red spectrum = 2/3 through 3/3\n        # return value is a portion of the blue-to-red spectrum\n        return (2 / 3) + ((1 / 3) * val)\n\n    @classmethod\n    def five_color_hue(cls, val: float) -&gt; float:\n        \"\"\"Converts a value to a hue along a red-orange-yellow-green-blue\n        spectrum. Higher values are red, lower values are blue. Good for\n        visually differentiating a range of values.\n\n        Args:\n            val (float): The value to convert.\n\n        Returns:\n            float: The hue in the red-orange-yellow-green-blue gradient.\n        \"\"\"\n        # red = 0\n        # blue = 2/3\n        # red to blue spectrum = 0 through 2/3\n        # five colors = red, orange, yellow, green, blue\n        # return value is a portion of the red-to-blue spectrum\n        return (2 / 3) * (1 - val)\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.__array_finalize__","title":"<code>__array_finalize__(obj)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __array_finalize__(self, obj: npt.NDArray[Any] | None) -&gt; None:\n    if obj is None:\n        return\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.__new__","title":"<code>__new__(grid)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __new__(cls, grid: IntGrid) -&gt; DebugGrid:\n    # obj = np.ndarray((grid.height, grid.width), dtype=object).view(DebugGrid)\n    obj = np.array(\n        [\n            [\n                GridStyle(\n                    front_hue=0,\n                    front_saturation=0,\n                    front_brightness=1,\n                    back_hue=0,\n                    back_saturation=1,\n                    back_brightness=0,\n                    val=chr(grid[row, col]),\n                    style=\"none\",\n                )\n                for col in range(grid.width)\n            ]\n            for row in range(grid.height)\n        ]\n    ).view(DebugGrid)\n    return obj\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __str__(self) -&gt; str:\n    ret = \"\"\n    for y in range(self.height):\n        for x in range(self.width):\n            s = self.get_val(x, y)\n            fr, fg, fb = self.get_front_rgb(x, y)\n            br, bg, bb = self.get_back_rgb(x, y)\n            ret += f\"{Fore.rgb(fr,fg,fb)}{Back.rgb(br,bg,bb)}{s.val}{Style.reset}\"\n        ret += \"\\n\"\n    return ret\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.blue_to_red_hue","title":"<code>blue_to_red_hue(val)</code>  <code>classmethod</code>","text":"<p>Converts a floating point value to a point in a red-to-blue gradient, where high values are red and lower values are blue. Good for representing values in a range as a heat map for easy visualization of higher values.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>float</code> <p>The value to convert.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The hue in the red-to-blue gradient.</p> Source code in <code>roc/location.py</code> <pre><code>@classmethod\ndef blue_to_red_hue(cls, val: float) -&gt; float:\n    \"\"\"Converts a floating point value to a point in a red-to-blue gradient,\n    where high values are red and lower values are blue. Good for\n    representing values in a range as a heat map for easy visualization of\n    higher values.\n\n    Args:\n        val (float): The value to convert.\n\n    Returns:\n        float: The hue in the red-to-blue gradient.\n    \"\"\"\n    # blue = 2/3\n    # blue to red spectrum = 2/3 through 3/3\n    # return value is a portion of the blue-to-red spectrum\n    return (2 / 3) + ((1 / 3) * val)\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.five_color_hue","title":"<code>five_color_hue(val)</code>  <code>classmethod</code>","text":"<p>Converts a value to a hue along a red-orange-yellow-green-blue spectrum. Higher values are red, lower values are blue. Good for visually differentiating a range of values.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>float</code> <p>The value to convert.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The hue in the red-orange-yellow-green-blue gradient.</p> Source code in <code>roc/location.py</code> <pre><code>@classmethod\ndef five_color_hue(cls, val: float) -&gt; float:\n    \"\"\"Converts a value to a hue along a red-orange-yellow-green-blue\n    spectrum. Higher values are red, lower values are blue. Good for\n    visually differentiating a range of values.\n\n    Args:\n        val (float): The value to convert.\n\n    Returns:\n        float: The hue in the red-orange-yellow-green-blue gradient.\n    \"\"\"\n    # red = 0\n    # blue = 2/3\n    # red to blue spectrum = 0 through 2/3\n    # five colors = red, orange, yellow, green, blue\n    # return value is a portion of the red-to-blue spectrum\n    return (2 / 3) * (1 - val)\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.get_back_rgb","title":"<code>get_back_rgb(x, y)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def get_back_rgb(self, x: int, y: int) -&gt; tuple[int, int, int]:\n    s = self.get_val(x, y)\n    rgb = hsv_to_rgb(s.back_hue, s.back_saturation, s.back_brightness)\n    ret = tuple(map(lambda c: round(c * 255), rgb))\n    assert len(ret) == 3\n    return ret\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.get_front_rgb","title":"<code>get_front_rgb(x, y)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def get_front_rgb(self, x: int, y: int) -&gt; tuple[int, int, int]:\n    s = self.get_val(x, y)\n    rgb = hsv_to_rgb(s.front_hue, s.front_saturation, s.front_brightness)\n    ret = tuple(map(lambda c: round(c * 255), rgb))\n    assert len(ret) == 3\n    return ret\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.set_style","title":"<code>set_style(x, y, *, style=None, **kwargs)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def set_style(self, x: int, y: int, *, style: str | None = None, **kwargs: float) -&gt; None:\n    s = self.get_val(x, y)\n\n    if style:\n        s.style = style\n\n    for key, value in kwargs.items():\n        if value &lt; 0 or value &gt; 1:\n            raise Exception(\n                f\"set_style expects values to be floats between 0 and 1, '{key}' was '{value}'\"\n            )\n\n        match key:\n            case \"front_hue\":\n                s.front_hue = value\n            case \"front_brightness\":\n                s.front_brightness = value\n            case \"front_saturation\":\n                s.front_saturation = value\n            case \"back_hue\":\n                s.back_hue = value\n            case \"back_brightness\":\n                s.back_brightness = value\n            case \"back_saturation\":\n                s.back_saturation = value\n            case _:\n                raise Exception(f\"unknown key '{key}' in set_style\")\n</code></pre>"},{"location":"reference/location/#location.Grid","title":"<code>Grid</code>","text":"<p>               Bases: <code>NDArray[Any]</code>, <code>Generic[GridType]</code></p> Source code in <code>roc/location.py</code> <pre><code>class Grid(npt.NDArray[Any], Generic[GridType]):\n    def __new__(cls, input_array: npt.ArrayLike) -&gt; Self:\n        obj = np.asarray(input_array).view(cls)\n        assert obj.ndim == 2\n        return obj\n\n    # def __array_finalize__(self, obj: npt.NDArray[Any] | None) -&gt; None:\n    #     if obj is None:\n    #         return\n\n    def __iter__(self) -&gt; Iterator[ValLocTuple[GridType]]:\n        for y, x in np.ndindex(self.shape):\n            yield cast(ValLocTuple[GridType], (x, y, self[y, x]))\n        # yield from np.nditer(self)\n\n    # def __init__(self, val_list: list[list[Any]] | np.ndarray) -&gt; None:\n    #     if not isinstance(val_list, np.ndarray):\n    #         val_list = np.array(val_list)\n    #     assert val_list.ndim == 2\n    #     self.val_list = val_list\n\n    def get_val(self, x: int, y: int) -&gt; GridType:\n        # XXX: not sure why I need to cast here, should this already be typed?\n        return cast(GridType, self[y, x])\n\n    def set_val(self, x: int, y: int, v: GridType) -&gt; None:\n        self[y, x] = v\n\n    @property\n    def width(self) -&gt; int:\n        return self.shape[1]\n\n    @property\n    def height(self) -&gt; int:\n        return self.shape[0]\n</code></pre>"},{"location":"reference/location/#location.Grid.height","title":"<code>height: int</code>  <code>property</code>","text":""},{"location":"reference/location/#location.Grid.width","title":"<code>width: int</code>  <code>property</code>","text":""},{"location":"reference/location/#location.Grid.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __iter__(self) -&gt; Iterator[ValLocTuple[GridType]]:\n    for y, x in np.ndindex(self.shape):\n        yield cast(ValLocTuple[GridType], (x, y, self[y, x]))\n</code></pre>"},{"location":"reference/location/#location.Grid.__new__","title":"<code>__new__(input_array)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __new__(cls, input_array: npt.ArrayLike) -&gt; Self:\n    obj = np.asarray(input_array).view(cls)\n    assert obj.ndim == 2\n    return obj\n</code></pre>"},{"location":"reference/location/#location.Grid.get_val","title":"<code>get_val(x, y)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def get_val(self, x: int, y: int) -&gt; GridType:\n    # XXX: not sure why I need to cast here, should this already be typed?\n    return cast(GridType, self[y, x])\n</code></pre>"},{"location":"reference/location/#location.Grid.set_val","title":"<code>set_val(x, y, v)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def set_val(self, x: int, y: int, v: GridType) -&gt; None:\n    self[y, x] = v\n</code></pre>"},{"location":"reference/location/#location.GridStyle","title":"<code>GridStyle</code>  <code>dataclass</code>","text":"<p>A stylized point on a text grid, where the text can be printed in any foreground or background color or style. Colors can be set using hue, saturation, and brightness (HSV) so that independent variables can control what color, how saturated the color is, and how bright the color is. This gives at least six debugging degrees of freedom for each point in the grid (in addition to value and style).</p> Source code in <code>roc/location.py</code> <pre><code>@dataclass\nclass GridStyle:\n    \"\"\"A stylized point on a text grid, where the text can be printed in any\n    foreground or background color or style. Colors can be set using hue,\n    saturation, and brightness (HSV) so that independent variables can control\n    what color, how saturated the color is, and how bright the color is. This\n    gives at least six debugging degrees of freedom for each point in the grid\n    (in addition to value and style).\n    \"\"\"\n\n    front_hue: float\n    front_saturation: float\n    front_brightness: float\n    back_hue: float\n    back_saturation: float\n    back_brightness: float\n    style: str\n    val: str\n</code></pre>"},{"location":"reference/location/#location.GridStyle.back_brightness","title":"<code>back_brightness: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.back_hue","title":"<code>back_hue: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.back_saturation","title":"<code>back_saturation: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.front_brightness","title":"<code>front_brightness: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.front_hue","title":"<code>front_hue: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.front_saturation","title":"<code>front_saturation: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.style","title":"<code>style: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.val","title":"<code>val: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.__init__","title":"<code>__init__(front_hue, front_saturation, front_brightness, back_hue, back_saturation, back_brightness, style, val)</code>","text":""},{"location":"reference/location/#location.IntGrid","title":"<code>IntGrid</code>","text":"<p>               Bases: <code>Grid[int]</code></p> Source code in <code>roc/location.py</code> <pre><code>class IntGrid(Grid[int]):\n    def get_point(self, x: XLoc, y: YLoc) -&gt; Point:\n        return Point(x, y, self[y, x])\n\n    def points(self) -&gt; Iterator[Point]:\n        \"\"\"Iterate over all the points in the grid\"\"\"\n        for x, y, v in self:\n            yield Point(x, y, v)\n</code></pre>"},{"location":"reference/location/#location.IntGrid.get_point","title":"<code>get_point(x, y)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def get_point(self, x: XLoc, y: YLoc) -&gt; Point:\n    return Point(x, y, self[y, x])\n</code></pre>"},{"location":"reference/location/#location.IntGrid.points","title":"<code>points()</code>","text":"<p>Iterate over all the points in the grid</p> Source code in <code>roc/location.py</code> <pre><code>def points(self) -&gt; Iterator[Point]:\n    \"\"\"Iterate over all the points in the grid\"\"\"\n    for x, y, v in self:\n        yield Point(x, y, v)\n</code></pre>"},{"location":"reference/location/#location.Point","title":"<code>Point</code>","text":"<p>Represents a int value at a 2D location (x, y)</p> Source code in <code>roc/location.py</code> <pre><code>class Point:\n    \"\"\"Represents a int value at a 2D location (x, y)\"\"\"\n\n    def __init__(self, x: XLoc, y: YLoc, val: int) -&gt; None:\n        self.x = x\n        self.y = y\n        self.val = val\n\n    def __hash__(self) -&gt; int:\n        return hash((self.x, self.y))\n\n    def __repr__(self) -&gt; str:\n        return f\"({self.x}, {self.y}): {self.val} '{chr(self.val)}'\"\n\n    def __eq__(self, p: Any) -&gt; bool:\n        if not isinstance(p, Point):\n            return False\n        return self.x == p.x and self.y == p.y and self.val == p.val\n\n    @staticmethod\n    def from_valloc(t: ValLocTuple[int]) -&gt; Point:\n        \"\"\"Converts a value / location tuple (value, x, y) to a Point.\n\n        Args:\n            t (ValLocTuple[int]): The tuple to convert\n\n        Returns:\n            Point: The new point that was created\n        \"\"\"\n        x, y, v = t\n        return Point(x, y, v)\n\n    @overload\n    @staticmethod\n    def isadjacent(*, x1: XLoc, y1: YLoc, x2: XLoc, y2: YLoc) -&gt; bool: ...\n\n    @overload\n    @staticmethod\n    def isadjacent(*, p1: Point, x2: XLoc, y2: YLoc) -&gt; bool: ...\n\n    @overload\n    @staticmethod\n    def isadjacent(*, p1: Point, p2: Point) -&gt; bool: ...\n\n    @staticmethod\n    def isadjacent(\n        # o1: int | Point, o2: int | Point, o3: int | None = None, o4: int | None = None\n        *,\n        x1: XLoc | None = None,\n        y1: YLoc | None = None,\n        x2: XLoc | None = None,\n        y2: YLoc | None = None,\n        p1: Point | None = None,\n        p2: Point | None = None,\n    ) -&gt; bool:\n        if isinstance(p1, Point):\n            x1 = p1.x\n            y1 = p1.y\n        elif not isinstance(x1, int) or not isinstance(y1, int):\n            raise TypeError(\"bad p1 arguments in isadjacent()\")\n\n        if isinstance(p2, Point):\n            x2 = p2.x\n            y2 = p2.y\n        elif not isinstance(x2, int) or not isinstance(y2, int):\n            raise TypeError(\"bad p2 arguments in isadjacent()\")\n\n        dx = abs(x1 - x2)\n        dy = abs(y1 - y2)\n        if dx == 0 and dy == 0:\n            return False\n\n        return dx &lt;= 1 and dy &lt;= 1\n</code></pre>"},{"location":"reference/location/#location.Point.val","title":"<code>val = val</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.Point.x","title":"<code>x = x</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.Point.y","title":"<code>y = y</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.Point.__eq__","title":"<code>__eq__(p)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __eq__(self, p: Any) -&gt; bool:\n    if not isinstance(p, Point):\n        return False\n    return self.x == p.x and self.y == p.y and self.val == p.val\n</code></pre>"},{"location":"reference/location/#location.Point.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __hash__(self) -&gt; int:\n    return hash((self.x, self.y))\n</code></pre>"},{"location":"reference/location/#location.Point.__init__","title":"<code>__init__(x, y, val)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __init__(self, x: XLoc, y: YLoc, val: int) -&gt; None:\n    self.x = x\n    self.y = y\n    self.val = val\n</code></pre>"},{"location":"reference/location/#location.Point.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"({self.x}, {self.y}): {self.val} '{chr(self.val)}'\"\n</code></pre>"},{"location":"reference/location/#location.Point.from_valloc","title":"<code>from_valloc(t)</code>  <code>staticmethod</code>","text":"<p>Converts a value / location tuple (value, x, y) to a Point.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ValLocTuple[int]</code> <p>The tuple to convert</p> required <p>Returns:</p> Name Type Description <code>Point</code> <code>Point</code> <p>The new point that was created</p> Source code in <code>roc/location.py</code> <pre><code>@staticmethod\ndef from_valloc(t: ValLocTuple[int]) -&gt; Point:\n    \"\"\"Converts a value / location tuple (value, x, y) to a Point.\n\n    Args:\n        t (ValLocTuple[int]): The tuple to convert\n\n    Returns:\n        Point: The new point that was created\n    \"\"\"\n    x, y, v = t\n    return Point(x, y, v)\n</code></pre>"},{"location":"reference/location/#location.Point.isadjacent","title":"<code>isadjacent(*, x1=None, y1=None, x2=None, y2=None, p1=None, p2=None)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/location.py</code> <pre><code>@staticmethod\ndef isadjacent(\n    # o1: int | Point, o2: int | Point, o3: int | None = None, o4: int | None = None\n    *,\n    x1: XLoc | None = None,\n    y1: YLoc | None = None,\n    x2: XLoc | None = None,\n    y2: YLoc | None = None,\n    p1: Point | None = None,\n    p2: Point | None = None,\n) -&gt; bool:\n    if isinstance(p1, Point):\n        x1 = p1.x\n        y1 = p1.y\n    elif not isinstance(x1, int) or not isinstance(y1, int):\n        raise TypeError(\"bad p1 arguments in isadjacent()\")\n\n    if isinstance(p2, Point):\n        x2 = p2.x\n        y2 = p2.y\n    elif not isinstance(x2, int) or not isinstance(y2, int):\n        raise TypeError(\"bad p2 arguments in isadjacent()\")\n\n    dx = abs(x1 - x2)\n    dy = abs(y1 - y2)\n    if dx == 0 and dy == 0:\n        return False\n\n    return dx &lt;= 1 and dy &lt;= 1\n</code></pre>"},{"location":"reference/location/#location.PointCollection","title":"<code>PointCollection</code>","text":"<p>A collection of abitrary points</p> Source code in <code>roc/location.py</code> <pre><code>class PointCollection:\n    \"\"\"A collection of abitrary points\"\"\"\n\n    def __init__(self, point_list: PointList) -&gt; None:\n        self._point_hash: dict[int, Point] = {}\n        for p in point_list:\n            self.add(p)\n\n    def add(self, p: Point) -&gt; None:\n        \"\"\"Adds a new point to the collection\"\"\"\n        hash_val = self.do_hash(p)\n        self._point_hash[hash_val] = p\n\n    def contains(self, p: Point) -&gt; bool:\n        \"\"\"Verifies if a point is already in the collection or not\"\"\"\n        hash_val = self.do_hash(p)\n        return hash_val in self._point_hash\n\n    def do_hash(self, p: Point) -&gt; int:\n        \"\"\"Returns the hash value of a point. Mostly for internal use.\"\"\"\n        return hash((p.x, p.y))\n\n    @property\n    def size(self) -&gt; int:\n        return len(self._point_hash)\n\n    @property\n    def points(self) -&gt; PointList:\n        return list(self._point_hash.values())\n</code></pre>"},{"location":"reference/location/#location.PointCollection.points","title":"<code>points: PointList</code>  <code>property</code>","text":""},{"location":"reference/location/#location.PointCollection.size","title":"<code>size: int</code>  <code>property</code>","text":""},{"location":"reference/location/#location.PointCollection.__init__","title":"<code>__init__(point_list)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __init__(self, point_list: PointList) -&gt; None:\n    self._point_hash: dict[int, Point] = {}\n    for p in point_list:\n        self.add(p)\n</code></pre>"},{"location":"reference/location/#location.PointCollection.add","title":"<code>add(p)</code>","text":"<p>Adds a new point to the collection</p> Source code in <code>roc/location.py</code> <pre><code>def add(self, p: Point) -&gt; None:\n    \"\"\"Adds a new point to the collection\"\"\"\n    hash_val = self.do_hash(p)\n    self._point_hash[hash_val] = p\n</code></pre>"},{"location":"reference/location/#location.PointCollection.contains","title":"<code>contains(p)</code>","text":"<p>Verifies if a point is already in the collection or not</p> Source code in <code>roc/location.py</code> <pre><code>def contains(self, p: Point) -&gt; bool:\n    \"\"\"Verifies if a point is already in the collection or not\"\"\"\n    hash_val = self.do_hash(p)\n    return hash_val in self._point_hash\n</code></pre>"},{"location":"reference/location/#location.PointCollection.do_hash","title":"<code>do_hash(p)</code>","text":"<p>Returns the hash value of a point. Mostly for internal use.</p> Source code in <code>roc/location.py</code> <pre><code>def do_hash(self, p: Point) -&gt; int:\n    \"\"\"Returns the hash value of a point. Mostly for internal use.\"\"\"\n    return hash((p.x, p.y))\n</code></pre>"},{"location":"reference/location/#location.TextGrid","title":"<code>TextGrid</code>","text":"<p>               Bases: <code>IntGrid</code></p> Source code in <code>roc/location.py</code> <pre><code>class TextGrid(IntGrid):\n    def __str__(self) -&gt; str:\n        ret = \"\"\n        last_y = 0\n        for x, y, v in self:\n            if y != last_y:\n                ret += \"\\n\"\n                last_y = y\n\n            ret += chr(v)\n\n        ret += \"\\n\"\n        return ret\n</code></pre>"},{"location":"reference/location/#location.TextGrid.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __str__(self) -&gt; str:\n    ret = \"\"\n    last_y = 0\n    for x, y, v in self:\n        if y != last_y:\n            ret += \"\\n\"\n            last_y = y\n\n        ret += chr(v)\n\n    ret += \"\\n\"\n    return ret\n</code></pre>"},{"location":"reference/location/#location.TypedPointCollection","title":"<code>TypedPointCollection</code>","text":"<p>               Bases: <code>PointCollection</code></p> <p>A collection of points that all have the same type</p> Source code in <code>roc/location.py</code> <pre><code>class TypedPointCollection(PointCollection):\n    \"\"\"A collection of points that all have the same type\"\"\"\n\n    def __init__(self, type: int, point_list: PointList) -&gt; None:\n        self.type = type\n        super().__init__(point_list)\n\n    def __repr__(self) -&gt; str:\n        return f\"{len(self._point_hash)} Points: {self.type} ({chr(self.type)})\"\n\n    def do_hash(self, p: Point) -&gt; int:\n        return hash(p)\n\n    def add(self, p: Point) -&gt; None:\n        \"\"\"Add a new point to the collection and enforce that it is the same\n        type as the collection\n        \"\"\"\n        if p.val != self.type:\n            raise TypeError(\n                f\"Trying to add '{p.val}' to TypedPointCollection with type '{self.type}\"\n            )\n\n        super().add(p)\n</code></pre>"},{"location":"reference/location/#location.TypedPointCollection.type","title":"<code>type = type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.TypedPointCollection.__init__","title":"<code>__init__(type, point_list)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __init__(self, type: int, point_list: PointList) -&gt; None:\n    self.type = type\n    super().__init__(point_list)\n</code></pre>"},{"location":"reference/location/#location.TypedPointCollection.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"{len(self._point_hash)} Points: {self.type} ({chr(self.type)})\"\n</code></pre>"},{"location":"reference/location/#location.TypedPointCollection.add","title":"<code>add(p)</code>","text":"<p>Add a new point to the collection and enforce that it is the same type as the collection</p> Source code in <code>roc/location.py</code> <pre><code>def add(self, p: Point) -&gt; None:\n    \"\"\"Add a new point to the collection and enforce that it is the same\n    type as the collection\n    \"\"\"\n    if p.val != self.type:\n        raise TypeError(\n            f\"Trying to add '{p.val}' to TypedPointCollection with type '{self.type}\"\n        )\n\n    super().add(p)\n</code></pre>"},{"location":"reference/location/#location.TypedPointCollection.do_hash","title":"<code>do_hash(p)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def do_hash(self, p: Point) -&gt; int:\n    return hash(p)\n</code></pre>"},{"location":"reference/logger/","title":"logger","text":"<p>This module defines the logging interface for storing system logs.</p>"},{"location":"reference/logger/#logger.__all__","title":"<code>__all__ = ['logger', 'init', 'default_log_filter']</code>  <code>module-attribute</code>","text":""},{"location":"reference/logger/#logger.default_log_filter","title":"<code>default_log_filter = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/logger/#logger.module_names","title":"<code>module_names = [name for (_, name, _) in pkgutil.iter_modules(['roc'])]</code>  <code>module-attribute</code>","text":""},{"location":"reference/logger/#logger.DebugModuleLevel","title":"<code>DebugModuleLevel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A Pydantic model for storing the logging level. Used primarily for setting per-module logging levels.</p> Source code in <code>roc/logger.py</code> <pre><code>class DebugModuleLevel(BaseModel):\n    \"\"\"A Pydantic model for storing the logging level. Used primarily for\n    setting per-module logging levels.\n    \"\"\"\n\n    module_name: str\n    log_level: str = Field(pattern=r\"TRACE|DEBUG|INFO|SUCCESS|WARNING|ERROR|CRITICAL\")\n\n    @field_validator(\"module_name\", mode=\"before\")\n    @classmethod\n    def validate_module_name(cls, name: str) -&gt; str:\n        assert (\n            name in module_names\n        ), f\"Module name '{name}' not a valid module name. Must be one of {module_names}\"\n\n        return name\n</code></pre>"},{"location":"reference/logger/#logger.DebugModuleLevel.log_level","title":"<code>log_level: str = Field(pattern='TRACE|DEBUG|INFO|SUCCESS|WARNING|ERROR|CRITICAL')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/logger/#logger.DebugModuleLevel.module_name","title":"<code>module_name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/logger/#logger.DebugModuleLevel.validate_module_name","title":"<code>validate_module_name(name)</code>  <code>classmethod</code>","text":"Source code in <code>roc/logger.py</code> <pre><code>@field_validator(\"module_name\", mode=\"before\")\n@classmethod\ndef validate_module_name(cls, name: str) -&gt; str:\n    assert (\n        name in module_names\n    ), f\"Module name '{name}' not a valid module name. Must be one of {module_names}\"\n\n    return name\n</code></pre>"},{"location":"reference/logger/#logger.LogFilter","title":"<code>LogFilter</code>","text":"<p>A Callable filter that determines if the loguru record should be logged or not.</p> Source code in <code>roc/logger.py</code> <pre><code>class LogFilter:\n    \"\"\"A Callable filter that determines if the loguru record should be logged\n    or not.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        level: str | None = None,\n        log_modules: str | None = None,\n        enabled: bool = True,\n        use_module_settings: bool = True,\n    ):\n        settings = Config.get()\n        self.level = level or settings.log_level\n        self.level_num = logger.level(self.level).no\n        if not isinstance(log_modules, str):\n            if use_module_settings:\n                log_modules = settings.log_modules\n            else:\n                log_modules = \"\"\n        mod_list = self.parse_module_str(log_modules)\n        self.module_levels = {mod_lvl.module_name: mod_lvl.log_level for mod_lvl in mod_list}\n\n    def __call__(self, record: Any) -&gt; bool:\n        # TODO: this would be more effecient as a dict rather than a loop (O(1) rather than O(n))\n\n        if record[\"module\"] in self.module_levels:\n            mod_log_level = self.module_levels[record[\"module\"]]\n            mod_level_num = logger.level(mod_log_level).no\n            if record[\"level\"].no &gt;= mod_level_num:\n                return True\n            else:\n                return False\n\n        if record[\"level\"].no &gt;= self.level_num:\n            return True\n\n        return False\n\n    @classmethod\n    def parse_module_str(cls, s: str) -&gt; list[DebugModuleLevel]:\n        s = s.strip()\n\n        mod_list = s.split(\";\")\n        # empty str\n        if mod_list == [\"\"]:\n            return []\n\n        mod_lvl_list: list[dict[str, str]] = []\n        for mod in mod_list:\n            mod_parts = mod.split(\":\")\n            mod_lvl_list.append({\"module_name\": mod_parts[0], \"log_level\": mod_parts[1]})\n\n        debug_module_list = TypeAdapter(list[DebugModuleLevel])\n        return debug_module_list.validate_python(mod_lvl_list)\n</code></pre>"},{"location":"reference/logger/#logger.LogFilter.level","title":"<code>level = level or settings.log_level</code>  <code>instance-attribute</code>","text":""},{"location":"reference/logger/#logger.LogFilter.level_num","title":"<code>level_num = logger.level(self.level).no</code>  <code>instance-attribute</code>","text":""},{"location":"reference/logger/#logger.LogFilter.module_levels","title":"<code>module_levels = {mod_lvl.module_name: mod_lvl.log_levelfor mod_lvl in mod_list}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/logger/#logger.LogFilter.__call__","title":"<code>__call__(record)</code>","text":"Source code in <code>roc/logger.py</code> <pre><code>def __call__(self, record: Any) -&gt; bool:\n    # TODO: this would be more effecient as a dict rather than a loop (O(1) rather than O(n))\n\n    if record[\"module\"] in self.module_levels:\n        mod_log_level = self.module_levels[record[\"module\"]]\n        mod_level_num = logger.level(mod_log_level).no\n        if record[\"level\"].no &gt;= mod_level_num:\n            return True\n        else:\n            return False\n\n    if record[\"level\"].no &gt;= self.level_num:\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/logger/#logger.LogFilter.__init__","title":"<code>__init__(*, level=None, log_modules=None, enabled=True, use_module_settings=True)</code>","text":"Source code in <code>roc/logger.py</code> <pre><code>def __init__(\n    self,\n    *,\n    level: str | None = None,\n    log_modules: str | None = None,\n    enabled: bool = True,\n    use_module_settings: bool = True,\n):\n    settings = Config.get()\n    self.level = level or settings.log_level\n    self.level_num = logger.level(self.level).no\n    if not isinstance(log_modules, str):\n        if use_module_settings:\n            log_modules = settings.log_modules\n        else:\n            log_modules = \"\"\n    mod_list = self.parse_module_str(log_modules)\n    self.module_levels = {mod_lvl.module_name: mod_lvl.log_level for mod_lvl in mod_list}\n</code></pre>"},{"location":"reference/logger/#logger.LogFilter.parse_module_str","title":"<code>parse_module_str(s)</code>  <code>classmethod</code>","text":"Source code in <code>roc/logger.py</code> <pre><code>@classmethod\ndef parse_module_str(cls, s: str) -&gt; list[DebugModuleLevel]:\n    s = s.strip()\n\n    mod_list = s.split(\";\")\n    # empty str\n    if mod_list == [\"\"]:\n        return []\n\n    mod_lvl_list: list[dict[str, str]] = []\n    for mod in mod_list:\n        mod_parts = mod.split(\":\")\n        mod_lvl_list.append({\"module_name\": mod_parts[0], \"log_level\": mod_parts[1]})\n\n    debug_module_list = TypeAdapter(list[DebugModuleLevel])\n    return debug_module_list.validate_python(mod_lvl_list)\n</code></pre>"},{"location":"reference/logger/#logger.init","title":"<code>init()</code>","text":"<p>Initializes the logging module. Installs the filter, fetches the settings, etc.</p> Source code in <code>roc/logger.py</code> <pre><code>def init() -&gt; None:\n    \"\"\"Initializes the logging module. Installs the filter, fetches the\n    settings, etc.\n    \"\"\"\n    global default_log_filter\n    default_log_filter = LogFilter()\n\n    logger.remove()\n    settings = Config.get()\n    if settings.log_enable:\n        logger.add(sys.stderr, level=0, filter=default_log_filter)\n</code></pre>"},{"location":"reference/object/","title":"object","text":""},{"location":"reference/object/#object.ObjectId","title":"<code>ObjectId = NewType('ObjectId', int)</code>  <code>module-attribute</code>","text":""},{"location":"reference/object/#object.CandidateObjects","title":"<code>CandidateObjects</code>","text":"Source code in <code>roc/object.py</code> <pre><code>class CandidateObjects:\n    def __init__(self, feature_nodes: Collection[FeatureNode]) -&gt; None:\n        # TODO: this currently only uses features, not context, for resolution\n        # the other objects in the current context should influence resolution\n        distance_idx: dict[NodeId, float] = defaultdict(float)\n\n        # TODO: getting all objects for the set of features is going to be a\n        # huge explosion of objects... need to come back to this an make a\n        # smarter selection algorithm\n        feature_groups = [\n            fg for n in feature_nodes for fg in n.predecessors.select(labels={\"FeatureGroup\"})\n        ]\n        objs = [obj for fg in feature_groups for obj in fg.predecessors.select(labels={\"Object\"})]\n        for obj in objs:\n            assert isinstance(obj, Object)\n            distance_idx[obj.id] += Object.distance(obj, feature_nodes)\n\n        self.distance_idx = distance_idx\n        self.order: list[NodeId] = sorted(self.distance_idx, key=lambda k: self.distance_idx[k])\n\n    def __getitem__(self, idx: int) -&gt; tuple[Object, float]:\n        n = self.order[idx]\n        return (Object.get(n), self.distance_idx[n])\n\n    def __len__(self) -&gt; int:\n        return len(self.order)\n</code></pre>"},{"location":"reference/object/#object.CandidateObjects.distance_idx","title":"<code>distance_idx = distance_idx</code>  <code>instance-attribute</code>","text":""},{"location":"reference/object/#object.CandidateObjects.order","title":"<code>order: list[NodeId] = sorted(self.distance_idx, key=lambda k: self.distance_idx[k])</code>  <code>instance-attribute</code>","text":""},{"location":"reference/object/#object.CandidateObjects.__getitem__","title":"<code>__getitem__(idx)</code>","text":"Source code in <code>roc/object.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; tuple[Object, float]:\n    n = self.order[idx]\n    return (Object.get(n), self.distance_idx[n])\n</code></pre>"},{"location":"reference/object/#object.CandidateObjects.__init__","title":"<code>__init__(feature_nodes)</code>","text":"Source code in <code>roc/object.py</code> <pre><code>def __init__(self, feature_nodes: Collection[FeatureNode]) -&gt; None:\n    # TODO: this currently only uses features, not context, for resolution\n    # the other objects in the current context should influence resolution\n    distance_idx: dict[NodeId, float] = defaultdict(float)\n\n    # TODO: getting all objects for the set of features is going to be a\n    # huge explosion of objects... need to come back to this an make a\n    # smarter selection algorithm\n    feature_groups = [\n        fg for n in feature_nodes for fg in n.predecessors.select(labels={\"FeatureGroup\"})\n    ]\n    objs = [obj for fg in feature_groups for obj in fg.predecessors.select(labels={\"Object\"})]\n    for obj in objs:\n        assert isinstance(obj, Object)\n        distance_idx[obj.id] += Object.distance(obj, feature_nodes)\n\n    self.distance_idx = distance_idx\n    self.order: list[NodeId] = sorted(self.distance_idx, key=lambda k: self.distance_idx[k])\n</code></pre>"},{"location":"reference/object/#object.CandidateObjects.__len__","title":"<code>__len__()</code>","text":"Source code in <code>roc/object.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.order)\n</code></pre>"},{"location":"reference/object/#object.FeatureGroup","title":"<code>FeatureGroup</code>","text":"<p>               Bases: <code>Node</code></p> Source code in <code>roc/object.py</code> <pre><code>class FeatureGroup(Node):\n    @staticmethod\n    def with_features(features: Collection[PerceptionFeature[Any]]) -&gt; FeatureGroup:\n        feature_nodes: set[FeatureNode] = {f.to_nodes() for f in features}\n\n        return FeatureGroup.from_nodes(feature_nodes)\n\n    @staticmethod\n    def from_nodes(feature_nodes: Collection[FeatureNode]) -&gt; FeatureGroup:\n        fg = FeatureGroup()\n        for f in feature_nodes:\n            Detail.connect(fg, f)\n\n        return fg\n\n    @property\n    def feature_nodes(self) -&gt; list[FeatureNode]:\n        return [cast(FeatureNode, e.dst) for e in self.src_edges if e.type == \"Detail\"]\n</code></pre>"},{"location":"reference/object/#object.FeatureGroup.feature_nodes","title":"<code>feature_nodes: list[FeatureNode]</code>  <code>property</code>","text":""},{"location":"reference/object/#object.FeatureGroup.from_nodes","title":"<code>from_nodes(feature_nodes)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/object.py</code> <pre><code>@staticmethod\ndef from_nodes(feature_nodes: Collection[FeatureNode]) -&gt; FeatureGroup:\n    fg = FeatureGroup()\n    for f in feature_nodes:\n        Detail.connect(fg, f)\n\n    return fg\n</code></pre>"},{"location":"reference/object/#object.FeatureGroup.with_features","title":"<code>with_features(features)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/object.py</code> <pre><code>@staticmethod\ndef with_features(features: Collection[PerceptionFeature[Any]]) -&gt; FeatureGroup:\n    feature_nodes: set[FeatureNode] = {f.to_nodes() for f in features}\n\n    return FeatureGroup.from_nodes(feature_nodes)\n</code></pre>"},{"location":"reference/object/#object.Features","title":"<code>Features</code>","text":"<p>               Bases: <code>Edge</code></p> Source code in <code>roc/object.py</code> <pre><code>class Features(Edge):\n    allowed_connections: EdgeConnectionsList = [(\"Object\", \"FeatureGroup\")]\n</code></pre>"},{"location":"reference/object/#object.Features.allowed_connections","title":"<code>allowed_connections: EdgeConnectionsList = [('Object', 'FeatureGroup')]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/object/#object.Object","title":"<code>Object</code>","text":"<p>               Bases: <code>Node</code></p> Source code in <code>roc/object.py</code> <pre><code>class Object(Node):\n    uuid: ObjectId = Field(default_factory=lambda: ObjectId(uuid4().int))\n    annotations: list[str] = Field(default_factory=list)\n    resolve_count: int = Field(default=0)\n\n    @property\n    def features(self) -&gt; list[FeatureNode]:\n        feature_groups = [e.dst for e in self.src_edges if e.type == \"Features\"]\n        feature_nodes: list[FeatureNode] = []\n        for fg in feature_groups:\n            assert isinstance(fg, FeatureGroup)\n            feature_nodes += fg.feature_nodes\n\n        return feature_nodes\n\n    def __str__(self) -&gt; str:\n        fhh = FlexiHumanHash(\n            \"{{adj}}-{{noun}}-named-{{firstname|lower}}-{{lastname|lower}}-{{hex(6)}}\"\n        )\n        h = fhh.hash(self.uuid)\n        ret = f\"Object({h})\"\n        for f in self.features:\n            ret += f\"\\n\\t{f}\"\n\n        return ret\n\n    @staticmethod\n    def with_features(fg: FeatureGroup) -&gt; Object:\n        o = Object()\n        Features.connect(o, fg)\n\n        return o\n\n    @staticmethod\n    def distance(obj: Object, features: Collection[FeatureNode]) -&gt; float:\n        assert isinstance(obj, Object)\n        # TODO: allowed_attrs is physical attributes, not really great but\n        # NetHack doesn't give us much feature-space to work with. in the future\n        # we may want to come back and use motion or other features for object recognition\n        allowed_attrs = {\"SingleNode\", \"ColorNode\", \"ShapeNode\"}  # TODO: line? flood?\n        features_strs: set[str] = {str(f) for f in features if f.labels &amp; allowed_attrs}\n        obj_features: set[str] = {\n            str(f) for f in obj.features if isinstance(f, FeatureNode) and f.labels &amp; allowed_attrs\n        }\n        return float(len(features_strs ^ obj_features))\n</code></pre>"},{"location":"reference/object/#object.Object.annotations","title":"<code>annotations: list[str] = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/object/#object.Object.features","title":"<code>features: list[FeatureNode]</code>  <code>property</code>","text":""},{"location":"reference/object/#object.Object.resolve_count","title":"<code>resolve_count: int = Field(default=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/object/#object.Object.uuid","title":"<code>uuid: ObjectId = Field(default_factory=lambda: ObjectId(uuid4().int))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/object/#object.Object.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/object.py</code> <pre><code>def __str__(self) -&gt; str:\n    fhh = FlexiHumanHash(\n        \"{{adj}}-{{noun}}-named-{{firstname|lower}}-{{lastname|lower}}-{{hex(6)}}\"\n    )\n    h = fhh.hash(self.uuid)\n    ret = f\"Object({h})\"\n    for f in self.features:\n        ret += f\"\\n\\t{f}\"\n\n    return ret\n</code></pre>"},{"location":"reference/object/#object.Object.distance","title":"<code>distance(obj, features)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/object.py</code> <pre><code>@staticmethod\ndef distance(obj: Object, features: Collection[FeatureNode]) -&gt; float:\n    assert isinstance(obj, Object)\n    # TODO: allowed_attrs is physical attributes, not really great but\n    # NetHack doesn't give us much feature-space to work with. in the future\n    # we may want to come back and use motion or other features for object recognition\n    allowed_attrs = {\"SingleNode\", \"ColorNode\", \"ShapeNode\"}  # TODO: line? flood?\n    features_strs: set[str] = {str(f) for f in features if f.labels &amp; allowed_attrs}\n    obj_features: set[str] = {\n        str(f) for f in obj.features if isinstance(f, FeatureNode) and f.labels &amp; allowed_attrs\n    }\n    return float(len(features_strs ^ obj_features))\n</code></pre>"},{"location":"reference/object/#object.Object.with_features","title":"<code>with_features(fg)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/object.py</code> <pre><code>@staticmethod\ndef with_features(fg: FeatureGroup) -&gt; Object:\n    o = Object()\n    Features.connect(o, fg)\n\n    return o\n</code></pre>"},{"location":"reference/object/#object.ObjectResolver","title":"<code>ObjectResolver</code>","text":"<p>               Bases: <code>Component</code></p> Source code in <code>roc/object.py</code> <pre><code>@register_component(\"resolver\", \"object\", auto=True)\nclass ObjectResolver(Component):\n    bus = EventBus[Object](\"object\")\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.att_conn = self.connect_bus(Attention.bus)\n        self.att_conn.listen(self.do_object_resolution)\n        self.obj_res_conn = self.connect_bus(ObjectResolver.bus)\n\n    def event_filter(self, e: AttentionEvent) -&gt; bool:\n        return e.src_id.name == \"vision\" and e.src_id.type == \"attention\"\n\n    def do_object_resolution(self, e: AttentionEvent) -&gt; None:\n        # TODO: instead of just taking the first focus_point (highest saliency\n        # strength) we probably want to adjust the strength for known objects /\n        # novel objects\n        focus_point = e.data.focus_points.iloc[0]\n        x = XLoc(int(focus_point[\"x\"]))\n        y = YLoc(int(focus_point[\"y\"]))\n        features = e.data.saliency_map.get_val(x, y)\n        fg = FeatureGroup.with_features(features)\n        # Argument 1 to \"with_features\" of \"FeatureGroup\" has incompatible type \"list[Feature[Any]]\"; expected \"FeatureGroup\"\n        objs = CandidateObjects(fg.feature_nodes)\n\n        o: Object | None = None\n        if len(objs) &gt; 0:\n            o, dist = objs[0]\n            o.resolve_count += 1\n\n        # TODO: \"&gt; 1\" as a cutoff for matching is pretty arbitrary\n        # should it be a % of features?\n        # or the cutoff for matching be determined by how well the prediction is works?\n        if o is None or dist &gt; 1:\n            o = Object.with_features(fg)\n\n        self.obj_res_conn.send(o)\n</code></pre>"},{"location":"reference/object/#object.ObjectResolver.att_conn","title":"<code>att_conn = self.connect_bus(Attention.bus)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/object/#object.ObjectResolver.bus","title":"<code>bus = EventBus[Object]('object')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/object/#object.ObjectResolver.obj_res_conn","title":"<code>obj_res_conn = self.connect_bus(ObjectResolver.bus)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/object/#object.ObjectResolver.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/object.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.att_conn = self.connect_bus(Attention.bus)\n    self.att_conn.listen(self.do_object_resolution)\n    self.obj_res_conn = self.connect_bus(ObjectResolver.bus)\n</code></pre>"},{"location":"reference/object/#object.ObjectResolver.do_object_resolution","title":"<code>do_object_resolution(e)</code>","text":"Source code in <code>roc/object.py</code> <pre><code>def do_object_resolution(self, e: AttentionEvent) -&gt; None:\n    # TODO: instead of just taking the first focus_point (highest saliency\n    # strength) we probably want to adjust the strength for known objects /\n    # novel objects\n    focus_point = e.data.focus_points.iloc[0]\n    x = XLoc(int(focus_point[\"x\"]))\n    y = YLoc(int(focus_point[\"y\"]))\n    features = e.data.saliency_map.get_val(x, y)\n    fg = FeatureGroup.with_features(features)\n    # Argument 1 to \"with_features\" of \"FeatureGroup\" has incompatible type \"list[Feature[Any]]\"; expected \"FeatureGroup\"\n    objs = CandidateObjects(fg.feature_nodes)\n\n    o: Object | None = None\n    if len(objs) &gt; 0:\n        o, dist = objs[0]\n        o.resolve_count += 1\n\n    # TODO: \"&gt; 1\" as a cutoff for matching is pretty arbitrary\n    # should it be a % of features?\n    # or the cutoff for matching be determined by how well the prediction is works?\n    if o is None or dist &gt; 1:\n        o = Object.with_features(fg)\n\n    self.obj_res_conn.send(o)\n</code></pre>"},{"location":"reference/object/#object.ObjectResolver.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/object.py</code> <pre><code>def event_filter(self, e: AttentionEvent) -&gt; bool:\n    return e.src_id.name == \"vision\" and e.src_id.type == \"attention\"\n</code></pre>"},{"location":"reference/perception/","title":"perception","text":"<p>The Perception system breaks down the environment into features that can be re-assembled as concepts.</p>"},{"location":"reference/perception/#perception.FeatureNodeType","title":"<code>FeatureNodeType = TypeVar('FeatureNodeType', bound=FeatureNode)</code>  <code>module-attribute</code>","text":""},{"location":"reference/perception/#perception.FeatureType","title":"<code>FeatureType = TypeVar('FeatureType')</code>  <code>module-attribute</code>","text":""},{"location":"reference/perception/#perception.PerceptionData","title":"<code>PerceptionData = VisionData | Settled | Feature[Any]</code>  <code>module-attribute</code>","text":""},{"location":"reference/perception/#perception.PerceptionEvent","title":"<code>PerceptionEvent = Event[PerceptionData]</code>  <code>module-attribute</code>","text":""},{"location":"reference/perception/#perception.cache_registry","title":"<code>cache_registry: dict[str, WeakValueDictionary[int, Node]] = defaultdict(WeakValueDictionary)</code>  <code>module-attribute</code>","text":""},{"location":"reference/perception/#perception.fe_list","title":"<code>fe_list: list[ReferenceType[FeatureExtractor[Any]]] = []</code>  <code>module-attribute</code>","text":""},{"location":"reference/perception/#perception.AreaFeature","title":"<code>AreaFeature</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Feature[FeatureNodeType]</code></p> Source code in <code>roc/perception.py</code> <pre><code>@dataclass(kw_only=True)\nclass AreaFeature(Feature[FeatureNodeType]):\n    type: int\n    points: set[tuple[XLoc, YLoc]]\n    size: int\n\n    def get_points(self) -&gt; set[tuple[XLoc, YLoc]]:\n        return self.points\n\n    def node_hash(self) -&gt; int:\n        return hash((self.type, self.size))\n</code></pre>"},{"location":"reference/perception/#perception.AreaFeature.points","title":"<code>points: set[tuple[XLoc, YLoc]]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.AreaFeature.size","title":"<code>size: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.AreaFeature.type","title":"<code>type: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.AreaFeature.__init__","title":"<code>__init__(*, feature_name, origin_id, type, points, size)</code>","text":""},{"location":"reference/perception/#perception.AreaFeature.get_points","title":"<code>get_points()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def get_points(self) -&gt; set[tuple[XLoc, YLoc]]:\n    return self.points\n</code></pre>"},{"location":"reference/perception/#perception.AreaFeature.node_hash","title":"<code>node_hash()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def node_hash(self) -&gt; int:\n    return hash((self.type, self.size))\n</code></pre>"},{"location":"reference/perception/#perception.Detail","title":"<code>Detail</code>","text":"<p>               Bases: <code>Edge</code></p> Source code in <code>roc/perception.py</code> <pre><code>class Detail(Edge):\n    allowed_connections: EdgeConnectionsList = [(\"FeatureGroup\", \"FeatureNode\")]\n</code></pre>"},{"location":"reference/perception/#perception.Detail.allowed_connections","title":"<code>allowed_connections: EdgeConnectionsList = [('FeatureGroup', 'FeatureNode')]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction","title":"<code>Direction</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>roc/perception.py</code> <pre><code>class Direction(str, Enum):\n    up = \"UP\"\n    down = \"DOWN\"\n    left = \"LEFT\"\n    right = \"RIGHT\"\n    up_right = \"UP_RIGHT\"\n    up_left = \"UP_LEFT\"\n    down_right = \"DOWN_RIGHT\"\n    down_left = \"DOWN_LEFT\"\n\n    def __str__(self) -&gt; str:\n        return self.value\n</code></pre>"},{"location":"reference/perception/#perception.Direction.down","title":"<code>down = 'DOWN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction.down_left","title":"<code>down_left = 'DOWN_LEFT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction.down_right","title":"<code>down_right = 'DOWN_RIGHT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction.left","title":"<code>left = 'LEFT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction.right","title":"<code>right = 'RIGHT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction.up","title":"<code>up = 'UP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction.up_left","title":"<code>up_left = 'UP_LEFT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction.up_right","title":"<code>up_right = 'UP_RIGHT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.value\n</code></pre>"},{"location":"reference/perception/#perception.Feature","title":"<code>Feature</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[FeatureNodeType]</code></p> Source code in <code>roc/perception.py</code> <pre><code>@dataclass(kw_only=True)\nclass Feature(ABC, Generic[FeatureNodeType]):\n    feature_name: str\n    origin_id: tuple[str, str]\n\n    def to_nodes(self) -&gt; FeatureNodeType:\n        # check local cache\n        cache = cache_registry[self.feature_name]\n\n        h = self.node_hash()\n        if h in cache:\n            return cache[h]  # type: ignore\n\n        # if cache miss, find node in database\n        n = self._dbfetch_nodes()\n        if n is None:\n            # if node doesn't exist, create it\n            n = self._create_nodes()\n            # n.labels.add(\"Feature\")\n            # n.labels.add(self.feature_name)\n\n        cache[h] = n\n        return n\n\n    @abstractmethod\n    def get_points(self) -&gt; set[tuple[XLoc, YLoc]]: ...\n\n    @abstractmethod\n    def _create_nodes(self) -&gt; FeatureNodeType: ...\n\n    @abstractmethod\n    def _dbfetch_nodes(self) -&gt; FeatureNodeType | None: ...\n\n    @abstractmethod\n    def node_hash(self) -&gt; int: ...\n</code></pre>"},{"location":"reference/perception/#perception.Feature.feature_name","title":"<code>feature_name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Feature.origin_id","title":"<code>origin_id: tuple[str, str]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Feature.__init__","title":"<code>__init__(*, feature_name, origin_id)</code>","text":""},{"location":"reference/perception/#perception.Feature.get_points","title":"<code>get_points()</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@abstractmethod\ndef get_points(self) -&gt; set[tuple[XLoc, YLoc]]: ...\n</code></pre>"},{"location":"reference/perception/#perception.Feature.node_hash","title":"<code>node_hash()</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@abstractmethod\ndef node_hash(self) -&gt; int: ...\n</code></pre>"},{"location":"reference/perception/#perception.Feature.to_nodes","title":"<code>to_nodes()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def to_nodes(self) -&gt; FeatureNodeType:\n    # check local cache\n    cache = cache_registry[self.feature_name]\n\n    h = self.node_hash()\n    if h in cache:\n        return cache[h]  # type: ignore\n\n    # if cache miss, find node in database\n    n = self._dbfetch_nodes()\n    if n is None:\n        # if node doesn't exist, create it\n        n = self._create_nodes()\n        # n.labels.add(\"Feature\")\n        # n.labels.add(self.feature_name)\n\n    cache[h] = n\n    return n\n</code></pre>"},{"location":"reference/perception/#perception.FeatureExtractor","title":"<code>FeatureExtractor</code>","text":"<p>               Bases: <code>Perception</code>, <code>Generic[FeatureType]</code>, <code>ABC</code></p> Source code in <code>roc/perception.py</code> <pre><code>class FeatureExtractor(Perception, Generic[FeatureType], ABC):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        fe_list.append(ref(self))\n\n    def do_perception(self, e: PerceptionEvent) -&gt; None:\n        f = self.get_feature(e)\n        if f is None:\n            return\n\n        self.pb_conn.send(f)\n\n    def settled(self) -&gt; None:\n        self.pb_conn.send(Settled())\n\n    @abstractmethod\n    def get_feature(self, e: PerceptionEvent) -&gt; Feature[Any] | None: ...\n\n    @classmethod\n    def list(cls) -&gt; list[str]:\n        ret: list[str] = []\n        for fe_ref in fe_list:\n            fe = fe_ref()\n            if fe is None:\n                continue\n            ret.append(str(fe.id))\n\n        return ret\n</code></pre>"},{"location":"reference/perception/#perception.FeatureExtractor.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    fe_list.append(ref(self))\n</code></pre>"},{"location":"reference/perception/#perception.FeatureExtractor.do_perception","title":"<code>do_perception(e)</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def do_perception(self, e: PerceptionEvent) -&gt; None:\n    f = self.get_feature(e)\n    if f is None:\n        return\n\n    self.pb_conn.send(f)\n</code></pre>"},{"location":"reference/perception/#perception.FeatureExtractor.get_feature","title":"<code>get_feature(e)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@abstractmethod\ndef get_feature(self, e: PerceptionEvent) -&gt; Feature[Any] | None: ...\n</code></pre>"},{"location":"reference/perception/#perception.FeatureExtractor.list","title":"<code>list()</code>  <code>classmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@classmethod\ndef list(cls) -&gt; list[str]:\n    ret: list[str] = []\n    for fe_ref in fe_list:\n        fe = fe_ref()\n        if fe is None:\n            continue\n        ret.append(str(fe.id))\n\n    return ret\n</code></pre>"},{"location":"reference/perception/#perception.FeatureExtractor.settled","title":"<code>settled()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def settled(self) -&gt; None:\n    self.pb_conn.send(Settled())\n</code></pre>"},{"location":"reference/perception/#perception.FeatureNode","title":"<code>FeatureNode</code>","text":"<p>               Bases: <code>Node</code></p> Source code in <code>roc/perception.py</code> <pre><code>class FeatureNode(Node):\n    def __hash__(self) -&gt; int:\n        # XXX: this is dangerous because ID changes when a node is saved\n        # should be okay for this use case though\n        return self.id\n\n    def __str__(self) -&gt; str:\n        return f\"\"\"{self.__class__.__name__}({\",\".join(self.attr_strs)})\"\"\"\n\n    @property\n    @abstractmethod\n    def attr_strs(self) -&gt; list[str]: ...\n</code></pre>"},{"location":"reference/perception/#perception.FeatureNode.attr_strs","title":"<code>attr_strs: list[str]</code>  <code>abstractmethod</code> <code>property</code>","text":""},{"location":"reference/perception/#perception.FeatureNode.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __hash__(self) -&gt; int:\n    # XXX: this is dangerous because ID changes when a node is saved\n    # should be okay for this use case though\n    return self.id\n</code></pre>"},{"location":"reference/perception/#perception.FeatureNode.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"\"\"{self.__class__.__name__}({\",\".join(self.attr_strs)})\"\"\"\n</code></pre>"},{"location":"reference/perception/#perception.HashingNoneFeature","title":"<code>HashingNoneFeature</code>","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>roc/perception.py</code> <pre><code>class HashingNoneFeature(Exception):\n    pass\n</code></pre>"},{"location":"reference/perception/#perception.Perception","title":"<code>Perception</code>","text":"<p>               Bases: <code>Component</code>, <code>ABC</code></p> <p>The abstract class for Perception components. Handles perception bus connections and corresponding clean-up.</p> Source code in <code>roc/perception.py</code> <pre><code>class Perception(Component, ABC):\n    \"\"\"The abstract class for Perception components. Handles perception bus\n    connections and corresponding clean-up.\n    \"\"\"\n\n    bus = EventBus[PerceptionData](\"perception\")\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.pb_conn = self.connect_bus(Perception.bus)\n        self.pb_conn.listen(self.do_perception)\n\n    @abstractmethod\n    def do_perception(self, e: PerceptionEvent) -&gt; None: ...\n\n    @classmethod\n    def init(cls) -&gt; None:\n        global perception_bus\n        cls.bus = EventBus[PerceptionData](\"perception\")\n</code></pre>"},{"location":"reference/perception/#perception.Perception.bus","title":"<code>bus = EventBus[PerceptionData]('perception')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Perception.pb_conn","title":"<code>pb_conn = self.connect_bus(Perception.bus)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Perception.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.pb_conn = self.connect_bus(Perception.bus)\n    self.pb_conn.listen(self.do_perception)\n</code></pre>"},{"location":"reference/perception/#perception.Perception.do_perception","title":"<code>do_perception(e)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@abstractmethod\ndef do_perception(self, e: PerceptionEvent) -&gt; None: ...\n</code></pre>"},{"location":"reference/perception/#perception.Perception.init","title":"<code>init()</code>  <code>classmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@classmethod\ndef init(cls) -&gt; None:\n    global perception_bus\n    cls.bus = EventBus[PerceptionData](\"perception\")\n</code></pre>"},{"location":"reference/perception/#perception.PointFeature","title":"<code>PointFeature</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Feature[FeatureNodeType]</code></p> Source code in <code>roc/perception.py</code> <pre><code>@dataclass(kw_only=True)\nclass PointFeature(Feature[FeatureNodeType]):\n    type: int\n    point: tuple[XLoc, YLoc]\n\n    def get_points(self) -&gt; set[tuple[XLoc, YLoc]]:\n        return {self.point}\n\n    def node_hash(self) -&gt; int:\n        return self.type\n</code></pre>"},{"location":"reference/perception/#perception.PointFeature.point","title":"<code>point: tuple[XLoc, YLoc]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.PointFeature.type","title":"<code>type: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.PointFeature.__init__","title":"<code>__init__(*, feature_name, origin_id, type, point)</code>","text":""},{"location":"reference/perception/#perception.PointFeature.get_points","title":"<code>get_points()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def get_points(self) -&gt; set[tuple[XLoc, YLoc]]:\n    return {self.point}\n</code></pre>"},{"location":"reference/perception/#perception.PointFeature.node_hash","title":"<code>node_hash()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def node_hash(self) -&gt; int:\n    return self.type\n</code></pre>"},{"location":"reference/perception/#perception.Settled","title":"<code>Settled</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>class Settled:\n    pass\n</code></pre>"},{"location":"reference/perception/#perception.VisionData","title":"<code>VisionData</code>","text":"<p>Vision data received from the environment.</p> Source code in <code>roc/perception.py</code> <pre><code>class VisionData:\n    \"\"\"Vision data received from the environment.\"\"\"\n\n    def __init__(\n        self,\n        glyphs: npt.NDArray[Any],\n        chars: npt.NDArray[Any],\n        colors: npt.NDArray[Any],\n    ) -&gt; None:\n        self.glyphs = glyphs\n        self.chars = chars\n        self.colors = colors\n\n    @staticmethod\n    def from_dict(d: dict[str, Any]) -&gt; VisionData:\n        \"\"\"Creates VisionData from an arbitrary dictionary\n\n        Args:\n            d (dict[str, Any]): The dictionary to create VisionData from. Must\n            have 'chars', 'glyphs', and 'colors' members.\n\n        Returns:\n            VisionData: The newly created vision data.\n        \"\"\"\n\n        def to_numpy(d: dict[str, Any], k: str) -&gt; np.ndarray[Any, Any]:\n            if not k in d:\n                raise Exception(f\"Expected '{k}' to exist in dict for VisionData.from_dict()\")\n\n            v = d[k]\n            if not isinstance(v, np.ndarray):\n                return np.array(v)\n            return v\n\n        glyphs = to_numpy(d, \"glyphs\")\n        chars = to_numpy(d, \"chars\")\n        colors = to_numpy(d, \"colors\")\n        return VisionData(glyphs, chars, colors)\n\n    @staticmethod\n    def for_test(test_data: list[list[int]]) -&gt; VisionData:\n        \"\"\"Creates VisionData for a test case, using a static 2D list of values\n        to create all aspects of the VisionData\n\n        Args:\n            test_data (list[list[int]]): The test data to convert into VisionData\n\n        Returns:\n            VisionData: The created VisionData\n        \"\"\"\n        a = np.array(test_data)\n        return VisionData(a.copy(), a.copy(), a.copy())\n</code></pre>"},{"location":"reference/perception/#perception.VisionData.chars","title":"<code>chars = chars</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.VisionData.colors","title":"<code>colors = colors</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.VisionData.glyphs","title":"<code>glyphs = glyphs</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.VisionData.__init__","title":"<code>__init__(glyphs, chars, colors)</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __init__(\n    self,\n    glyphs: npt.NDArray[Any],\n    chars: npt.NDArray[Any],\n    colors: npt.NDArray[Any],\n) -&gt; None:\n    self.glyphs = glyphs\n    self.chars = chars\n    self.colors = colors\n</code></pre>"},{"location":"reference/perception/#perception.VisionData.for_test","title":"<code>for_test(test_data)</code>  <code>staticmethod</code>","text":"<p>Creates VisionData for a test case, using a static 2D list of values to create all aspects of the VisionData</p> <p>Parameters:</p> Name Type Description Default <code>test_data</code> <code>list[list[int]]</code> <p>The test data to convert into VisionData</p> required <p>Returns:</p> Name Type Description <code>VisionData</code> <code>VisionData</code> <p>The created VisionData</p> Source code in <code>roc/perception.py</code> <pre><code>@staticmethod\ndef for_test(test_data: list[list[int]]) -&gt; VisionData:\n    \"\"\"Creates VisionData for a test case, using a static 2D list of values\n    to create all aspects of the VisionData\n\n    Args:\n        test_data (list[list[int]]): The test data to convert into VisionData\n\n    Returns:\n        VisionData: The created VisionData\n    \"\"\"\n    a = np.array(test_data)\n    return VisionData(a.copy(), a.copy(), a.copy())\n</code></pre>"},{"location":"reference/perception/#perception.VisionData.from_dict","title":"<code>from_dict(d)</code>  <code>staticmethod</code>","text":"<p>Creates VisionData from an arbitrary dictionary</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict[str, Any]</code> <p>The dictionary to create VisionData from. Must</p> required <p>Returns:</p> Name Type Description <code>VisionData</code> <code>VisionData</code> <p>The newly created vision data.</p> Source code in <code>roc/perception.py</code> <pre><code>@staticmethod\ndef from_dict(d: dict[str, Any]) -&gt; VisionData:\n    \"\"\"Creates VisionData from an arbitrary dictionary\n\n    Args:\n        d (dict[str, Any]): The dictionary to create VisionData from. Must\n        have 'chars', 'glyphs', and 'colors' members.\n\n    Returns:\n        VisionData: The newly created vision data.\n    \"\"\"\n\n    def to_numpy(d: dict[str, Any], k: str) -&gt; np.ndarray[Any, Any]:\n        if not k in d:\n            raise Exception(f\"Expected '{k}' to exist in dict for VisionData.from_dict()\")\n\n        v = d[k]\n        if not isinstance(v, np.ndarray):\n            return np.array(v)\n        return v\n\n    glyphs = to_numpy(d, \"glyphs\")\n    chars = to_numpy(d, \"chars\")\n    colors = to_numpy(d, \"colors\")\n    return VisionData(glyphs, chars, colors)\n</code></pre>"},{"location":"reference/script/","title":"script","text":"<p>This is a Python script that runs the Gym and agent, typically from the command-line. See the Makefile for how to run this script.</p>"},{"location":"reference/script/#script.pp","title":"<code>pp = pprint.PrettyPrinter(width=41, compact=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/script/#script.ascii_list","title":"<code>ascii_list(al)</code>","text":"Source code in <code>roc/script.py</code> <pre><code>def ascii_list(al: list[int]) -&gt; str:\n    result_string = \"\"\n\n    for ascii_value in al:\n        result_string += chr(ascii_value)\n\n    return result_string\n</code></pre>"},{"location":"reference/script/#script.cli","title":"<code>cli(arg)</code>","text":"Source code in <code>roc/script.py</code> <pre><code>@click.command\n@click.option(\"--arg\", default=1)\ndef cli(arg: Any) -&gt; None:\n    roc.init()\n    roc.start()\n</code></pre>"},{"location":"reference/script/#script.int_list","title":"<code>int_list(al)</code>","text":"Source code in <code>roc/script.py</code> <pre><code>def int_list(al: list[int]) -&gt; str:\n    result_string = \"\"\n\n    for ascii_value in al:\n        result_string += str(ascii_value) + \" \"\n\n    return result_string\n</code></pre>"},{"location":"reference/script/#script.print_screen","title":"<code>print_screen(screen, *, as_int=False)</code>","text":"Source code in <code>roc/script.py</code> <pre><code>def print_screen(screen: list[list[int]], *, as_int: bool = False) -&gt; None:\n    for row in screen:\n        if not as_int:\n            print(ascii_list(row))  # noqa: T201\n        else:\n            print(int_list(row))  # noqa: T201\n</code></pre>"},{"location":"reference/feature_extractors/color/","title":"color","text":"<p>Generates Features for things that aren't like their neighbors</p>"},{"location":"reference/feature_extractors/color/#feature_extractors.color.Color","title":"<code>Color</code>","text":"<p>               Bases: <code>FeatureExtractor[Point]</code></p> <p>A component for simulating the color of features based on the character value.</p> Source code in <code>roc/feature_extractors/color.py</code> <pre><code>@register_component(\"color\", \"perception\")\nclass Color(FeatureExtractor[Point]):\n    \"\"\"A component for simulating the color of features based on the character\n    value.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.queue: list[SingleFeature] = list()\n        self.vd: VisionData | None = None\n        self.single_settled = False\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        \"\"\"Filters out non-SingleFeatures and non-VisionData\n\n        Args:\n            e (PerceptionEvent): Any event on the perception bus\n\n        Returns:\n            bool: Returns True if the event is a SingleFeature or VisionData to\n            keep processing it, False otherwise.\n        \"\"\"\n        return isinstance(e.data, VisionData) or e.src_id.name == \"single\"\n\n    def get_feature(self, e: PerceptionEvent) -&gt; None:\n        \"\"\"Emits the color features.\n\n        Args:\n            e (PerceptionEvent): The VisionData or SingleFeature\n\n        Returns:\n            Feature | None: None\n        \"\"\"\n        if isinstance(e.data, SingleFeature):\n            self.queue.append(e.data)\n            return None\n\n        if isinstance(e.data, Settled):\n            self.single_settled = True\n\n        if isinstance(e.data, VisionData):\n            self.vd = e.data\n\n        if self.single_settled and self.vd is not None:\n            for s in self.queue:\n                x, y = s.point\n                self.pb_conn.send(\n                    ColorFeature(\n                        origin_id=self.id,\n                        point=(x, y),\n                        type=self.vd.colors[y, x],\n                    )\n                )\n\n            self.settled()\n            self.queue.clear()\n            self.single_settled = False\n            self.vd = None\n\n        return None\n</code></pre>"},{"location":"reference/feature_extractors/color/#feature_extractors.color.Color.queue","title":"<code>queue: list[SingleFeature] = list()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/color/#feature_extractors.color.Color.single_settled","title":"<code>single_settled = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/color/#feature_extractors.color.Color.vd","title":"<code>vd: VisionData | None = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/color/#feature_extractors.color.Color.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/feature_extractors/color.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.queue: list[SingleFeature] = list()\n    self.vd: VisionData | None = None\n    self.single_settled = False\n</code></pre>"},{"location":"reference/feature_extractors/color/#feature_extractors.color.Color.event_filter","title":"<code>event_filter(e)</code>","text":"<p>Filters out non-SingleFeatures and non-VisionData</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>PerceptionEvent</code> <p>Any event on the perception bus</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns True if the event is a SingleFeature or VisionData to</p> <code>bool</code> <p>keep processing it, False otherwise.</p> Source code in <code>roc/feature_extractors/color.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    \"\"\"Filters out non-SingleFeatures and non-VisionData\n\n    Args:\n        e (PerceptionEvent): Any event on the perception bus\n\n    Returns:\n        bool: Returns True if the event is a SingleFeature or VisionData to\n        keep processing it, False otherwise.\n    \"\"\"\n    return isinstance(e.data, VisionData) or e.src_id.name == \"single\"\n</code></pre>"},{"location":"reference/feature_extractors/color/#feature_extractors.color.Color.get_feature","title":"<code>get_feature(e)</code>","text":"<p>Emits the color features.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>PerceptionEvent</code> <p>The VisionData or SingleFeature</p> required <p>Returns:</p> Type Description <code>None</code> <p>Feature | None: None</p> Source code in <code>roc/feature_extractors/color.py</code> <pre><code>def get_feature(self, e: PerceptionEvent) -&gt; None:\n    \"\"\"Emits the color features.\n\n    Args:\n        e (PerceptionEvent): The VisionData or SingleFeature\n\n    Returns:\n        Feature | None: None\n    \"\"\"\n    if isinstance(e.data, SingleFeature):\n        self.queue.append(e.data)\n        return None\n\n    if isinstance(e.data, Settled):\n        self.single_settled = True\n\n    if isinstance(e.data, VisionData):\n        self.vd = e.data\n\n    if self.single_settled and self.vd is not None:\n        for s in self.queue:\n            x, y = s.point\n            self.pb_conn.send(\n                ColorFeature(\n                    origin_id=self.id,\n                    point=(x, y),\n                    type=self.vd.colors[y, x],\n                )\n            )\n\n        self.settled()\n        self.queue.clear()\n        self.single_settled = False\n        self.vd = None\n\n    return None\n</code></pre>"},{"location":"reference/feature_extractors/color/#feature_extractors.color.ColorFeature","title":"<code>ColorFeature</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PointFeature[ColorNode]</code></p> <p>The color of a single feature.</p> Source code in <code>roc/feature_extractors/color.py</code> <pre><code>@dataclass(kw_only=True)\nclass ColorFeature(PointFeature[ColorNode]):\n    \"\"\"The color of a single feature.\"\"\"\n\n    feature_name: str = \"Color\"\n\n    def _create_nodes(self) -&gt; ColorNode:\n        return ColorNode(type=self.type)\n\n    def _dbfetch_nodes(self) -&gt; ColorNode | None:\n        return ColorNode.find_one(\"src.type = $type\", params={\"type\": self.type})\n</code></pre>"},{"location":"reference/feature_extractors/color/#feature_extractors.color.ColorFeature.feature_name","title":"<code>feature_name: str = 'Color'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/color/#feature_extractors.color.ColorFeature.__init__","title":"<code>__init__(*, feature_name='Color')</code>","text":""},{"location":"reference/feature_extractors/color/#feature_extractors.color.ColorNode","title":"<code>ColorNode</code>","text":"<p>               Bases: <code>FeatureNode</code></p> Source code in <code>roc/feature_extractors/color.py</code> <pre><code>class ColorNode(FeatureNode):\n    type: int\n\n    @property\n    def attr_strs(self) -&gt; list[str]:\n        color: str\n\n        # https://github.com/NetHack/NetHack/blob/8bb764e624aa228ce2a5374739408ed81b77d40e/include/color.h#L14\n        match self.type:\n            case 0:\n                color = \"BLACK\"\n            case 1:\n                color = \"RED\"\n            case 2:\n                color = \"GREEN\"\n            case 3:\n                color = \"BROWN\"\n            case 4:\n                color = \"BLUE\"\n            case 5:\n                color = \"MAGENTA\"\n            case 6:\n                color = \"CYAN\"\n            case 7:\n                color = \"GREY\"\n            case 8:\n                color = \"NO COLOR\"\n            case 9:\n                color = \"ORANGE\"\n            case 10:\n                color = \"BRIGHT GREEN\"\n            case 11:\n                color = \"YELLOW\"\n            case 12:\n                color = \"BRIGHT BLUE\"\n            case 13:\n                color = \"BRIGHT MAGENTA\"\n            case 14:\n                color = \"BRIGHT CYAN\"\n            case 15:\n                color = \"WHITE\"\n            case 16:\n                color = \"MAX\"\n            case _:\n                raise Exception(\"impossible color\")\n\n        return [color]\n</code></pre>"},{"location":"reference/feature_extractors/color/#feature_extractors.color.ColorNode.attr_strs","title":"<code>attr_strs: list[str]</code>  <code>property</code>","text":""},{"location":"reference/feature_extractors/color/#feature_extractors.color.ColorNode.type","title":"<code>type: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/","title":"delta","text":"<p>A component for generating Features that represent differences in vision</p>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Delta","title":"<code>Delta</code>","text":"<p>               Bases: <code>FeatureExtractor[DeltaFeature]</code></p> <p>A component for detecting changes in vision.</p> Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>@register_component(\"delta\", \"perception\")\nclass Delta(FeatureExtractor[DeltaFeature]):\n    \"\"\"A component for detecting changes in vision.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.prev_viz: IntGrid | None = None\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        return isinstance(e.data, VisionData)\n\n    def get_feature(self, e: PerceptionEvent) -&gt; None:\n        data = e.data\n        assert isinstance(data, VisionData)\n\n        prev = self.prev_viz\n        # XXX: NLE reuses numpy arrays rather than creating new ones\n        self.prev_viz = curr = IntGrid(data.glyphs.copy())\n\n        if prev is None:\n            # can't get difference when there was nothing before this\n            self.settled()\n            return None\n\n        # roughly make sure that things are the same size\n        assert prev.height == curr.height\n        assert prev.width == curr.width\n\n        for new_point in curr.points():\n            old_point = prev.get_point(new_point.x, new_point.y)\n            if old_point.val != new_point.val:\n                self.pb_conn.send(\n                    DeltaFeature(\n                        origin_id=self.id,\n                        point=(new_point.x, new_point.y),\n                        old_val=old_point.val,\n                        new_val=new_point.val,\n                    )\n                )\n\n        self.settled()\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Delta.prev_viz","title":"<code>prev_viz: IntGrid | None = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Delta.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.prev_viz: IntGrid | None = None\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Delta.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    return isinstance(e.data, VisionData)\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Delta.get_feature","title":"<code>get_feature(e)</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def get_feature(self, e: PerceptionEvent) -&gt; None:\n    data = e.data\n    assert isinstance(data, VisionData)\n\n    prev = self.prev_viz\n    # XXX: NLE reuses numpy arrays rather than creating new ones\n    self.prev_viz = curr = IntGrid(data.glyphs.copy())\n\n    if prev is None:\n        # can't get difference when there was nothing before this\n        self.settled()\n        return None\n\n    # roughly make sure that things are the same size\n    assert prev.height == curr.height\n    assert prev.width == curr.width\n\n    for new_point in curr.points():\n        old_point = prev.get_point(new_point.x, new_point.y)\n        if old_point.val != new_point.val:\n            self.pb_conn.send(\n                DeltaFeature(\n                    origin_id=self.id,\n                    point=(new_point.x, new_point.y),\n                    old_val=old_point.val,\n                    new_val=new_point.val,\n                )\n            )\n\n    self.settled()\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaFeature","title":"<code>DeltaFeature</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Feature[DeltaNode]</code></p> <p>A Feature that describes changes in vision</p> Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>@dataclass(kw_only=True)\nclass DeltaFeature(Feature[DeltaNode]):\n    \"\"\"A Feature that describes changes in vision\"\"\"\n\n    feature_name: str = \"Delta\"\n    old_val: int\n    new_val: int\n    point: tuple[XLoc, YLoc]\n\n    def get_points(self) -&gt; set[tuple[XLoc, YLoc]]:\n        return {self.point}\n\n    def __str__(self) -&gt; str:\n        return f\"({self.point[0]}, {self.point[1]}): {self.old_val} -&gt; {self.new_val}\\n\"\n\n    def node_hash(self) -&gt; int:\n        return hash((self.old_val, self.new_val))\n\n    def _create_nodes(self) -&gt; DeltaNode:\n        return DeltaNode(old_val=self.old_val, new_val=self.new_val)\n\n    def _dbfetch_nodes(self) -&gt; DeltaNode | None:\n        return DeltaNode.find_one(\n            \"src.old_val = $old_val AND src.new_val = $new_val\",\n            params={\"old_val\": self.old_val, \"new_val\": self.new_val},\n        )\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaFeature.feature_name","title":"<code>feature_name: str = 'Delta'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaFeature.new_val","title":"<code>new_val: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaFeature.old_val","title":"<code>old_val: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaFeature.point","title":"<code>point: tuple[XLoc, YLoc]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaFeature.__init__","title":"<code>__init__(*, feature_name='Delta', old_val, new_val, point)</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaFeature.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"({self.point[0]}, {self.point[1]}): {self.old_val} -&gt; {self.new_val}\\n\"\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaFeature.get_points","title":"<code>get_points()</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def get_points(self) -&gt; set[tuple[XLoc, YLoc]]:\n    return {self.point}\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaFeature.node_hash","title":"<code>node_hash()</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def node_hash(self) -&gt; int:\n    return hash((self.old_val, self.new_val))\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaNode","title":"<code>DeltaNode</code>","text":"<p>               Bases: <code>FeatureNode</code></p> Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>class DeltaNode(FeatureNode):\n    old_val: int\n    new_val: int\n\n    @property\n    def attr_strs(self) -&gt; list[str]:\n        return [str(self.old_val), str(self.new_val)]\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaNode.attr_strs","title":"<code>attr_strs: list[str]</code>  <code>property</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaNode.new_val","title":"<code>new_val: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaNode.old_val","title":"<code>old_val: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/distance/","title":"distance","text":"<p>Calculates distance between Singles. Note: this is probably post-attention in humans, only calculated for a subset of features, and based on the saccades of the eyes.</p>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.Distance","title":"<code>Distance</code>","text":"<p>               Bases: <code>FeatureExtractor[DistanceFeature]</code></p> Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>@register_component(\"distance\", \"perception\")\nclass Distance(FeatureExtractor[DistanceFeature]):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.prev_features: list[SingleFeature] = []\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        # only listen to single:perception events\n        if e.src_id.name == \"single\" and e.src_id.type == \"perception\":\n            return True\n        return False\n\n    def get_feature(self, e: PerceptionEvent) -&gt; None:\n        data = e.data\n\n        if isinstance(data, Settled):\n            self.prev_features.clear()\n            self.settled()\n            return\n\n        # calculate distance between all previous elements and emit event for each\n        assert isinstance(data, SingleFeature)\n        curr_pt = data.point\n        # print(\"### single point:\", curr_pt)\n        for f in self.prev_features:\n            prev_pt = f.point\n            dist = chebyshev_distance(curr_pt, prev_pt)\n            # print(f\"# distance: ({prev_pt[0]}, {prev_pt[1]}) ({curr_pt[0]}, {curr_pt[1]}) {dist}\")\n            self.pb_conn.send(\n                DistanceFeature(\n                    origin_id=self.id,\n                    start_point=prev_pt,\n                    end_point=curr_pt,\n                    size=dist,\n                )\n            )\n\n        # add to previous elements\n        self.prev_features.append(data)\n</code></pre>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.Distance.prev_features","title":"<code>prev_features: list[SingleFeature] = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.Distance.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.prev_features: list[SingleFeature] = []\n</code></pre>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.Distance.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    # only listen to single:perception events\n    if e.src_id.name == \"single\" and e.src_id.type == \"perception\":\n        return True\n    return False\n</code></pre>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.Distance.get_feature","title":"<code>get_feature(e)</code>","text":"Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>def get_feature(self, e: PerceptionEvent) -&gt; None:\n    data = e.data\n\n    if isinstance(data, Settled):\n        self.prev_features.clear()\n        self.settled()\n        return\n\n    # calculate distance between all previous elements and emit event for each\n    assert isinstance(data, SingleFeature)\n    curr_pt = data.point\n    # print(\"### single point:\", curr_pt)\n    for f in self.prev_features:\n        prev_pt = f.point\n        dist = chebyshev_distance(curr_pt, prev_pt)\n        # print(f\"# distance: ({prev_pt[0]}, {prev_pt[1]}) ({curr_pt[0]}, {curr_pt[1]}) {dist}\")\n        self.pb_conn.send(\n            DistanceFeature(\n                origin_id=self.id,\n                start_point=prev_pt,\n                end_point=curr_pt,\n                size=dist,\n            )\n        )\n\n    # add to previous elements\n    self.prev_features.append(data)\n</code></pre>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.DistanceFeature","title":"<code>DistanceFeature</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Feature[DistanceNode]</code></p> <p>The distance between two features</p> Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>@dataclass(kw_only=True)\nclass DistanceFeature(Feature[DistanceNode]):\n    \"\"\"The distance between two features\"\"\"\n\n    feature_name: str = \"Distance\"\n    start_point: tuple[XLoc, YLoc]\n    end_point: tuple[XLoc, YLoc]\n    size: int\n\n    def get_points(self) -&gt; set[tuple[XLoc, YLoc]]:\n        return {self.start_point, self.end_point}\n\n    def node_hash(self) -&gt; int:\n        return hash(self.size)\n\n    def _create_nodes(self) -&gt; DistanceNode:\n        return DistanceNode(size=self.size)\n\n    def _dbfetch_nodes(self) -&gt; DistanceNode | None:\n        return DistanceNode.find_one(\"src.size = $size\", params={\"size\": self.size})\n</code></pre>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.DistanceFeature.end_point","title":"<code>end_point: tuple[XLoc, YLoc]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.DistanceFeature.feature_name","title":"<code>feature_name: str = 'Distance'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.DistanceFeature.size","title":"<code>size: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.DistanceFeature.start_point","title":"<code>start_point: tuple[XLoc, YLoc]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.DistanceFeature.__init__","title":"<code>__init__(*, feature_name='Distance', start_point, end_point, size)</code>","text":""},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.DistanceFeature.get_points","title":"<code>get_points()</code>","text":"Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>def get_points(self) -&gt; set[tuple[XLoc, YLoc]]:\n    return {self.start_point, self.end_point}\n</code></pre>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.DistanceFeature.node_hash","title":"<code>node_hash()</code>","text":"Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>def node_hash(self) -&gt; int:\n    return hash(self.size)\n</code></pre>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.DistanceNode","title":"<code>DistanceNode</code>","text":"<p>               Bases: <code>FeatureNode</code></p> Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>class DistanceNode(FeatureNode):\n    size: int\n\n    @property\n    def attr_strs(self) -&gt; list[str]:\n        return [str(self.size)]\n</code></pre>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.DistanceNode.attr_strs","title":"<code>attr_strs: list[str]</code>  <code>property</code>","text":""},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.DistanceNode.size","title":"<code>size: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.chebyshev_distance","title":"<code>chebyshev_distance(p1, p2)</code>","text":"Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>def chebyshev_distance(p1: tuple[XLoc, YLoc], p2: tuple[XLoc, YLoc]) -&gt; int:\n    x1 = p1[0]\n    x2 = p2[0]\n    y1 = p1[1]\n    y2 = p2[1]\n    dx = abs(x1 - x2)\n    dy = abs(y1 - y2)\n    return max(dx, dy)\n</code></pre>"},{"location":"reference/feature_extractors/flood/","title":"flood","text":""},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.MIN_FLOOD_SIZE","title":"<code>MIN_FLOOD_SIZE = 5</code>  <code>module-attribute</code>","text":""},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.CheckMap","title":"<code>CheckMap</code>","text":"<p>Internal utility class for tracking which points in a flood have already been checked</p> Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>class CheckMap:\n    \"\"\"Internal utility class for tracking which points in a flood have already been checked\"\"\"\n\n    def __init__(self, width: int, height: int) -&gt; None:\n        a = np.zeros((height, width))\n        self.grid = a.view(IntGrid)\n\n    def find_first_unused_point(self) -&gt; Point | None:\n        for p in self.grid.points():\n            if p.val == 0:\n                return p\n\n        return None\n\n    def set(self, x: int, y: int) -&gt; None:\n        self.grid.set_val(x, y, 1)\n\n    def checked(self, x: int, y: int) -&gt; bool:\n        return self.grid.get_val(x, y) == 1\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.CheckMap.grid","title":"<code>grid = a.view(IntGrid)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.CheckMap.__init__","title":"<code>__init__(width, height)</code>","text":"Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>def __init__(self, width: int, height: int) -&gt; None:\n    a = np.zeros((height, width))\n    self.grid = a.view(IntGrid)\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.CheckMap.checked","title":"<code>checked(x, y)</code>","text":"Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>def checked(self, x: int, y: int) -&gt; bool:\n    return self.grid.get_val(x, y) == 1\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.CheckMap.find_first_unused_point","title":"<code>find_first_unused_point()</code>","text":"Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>def find_first_unused_point(self) -&gt; Point | None:\n    for p in self.grid.points():\n        if p.val == 0:\n            return p\n\n    return None\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.CheckMap.set","title":"<code>set(x, y)</code>","text":"Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>def set(self, x: int, y: int) -&gt; None:\n    self.grid.set_val(x, y, 1)\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.Flood","title":"<code>Flood</code>","text":"<p>               Bases: <code>FeatureExtractor[TypedPointCollection]</code></p> <p>A component for creating Flood features -- collections of adjacent points that all have the same value</p> Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>@register_component(\"flood\", \"perception\")\nclass Flood(FeatureExtractor[TypedPointCollection]):\n    \"\"\"A component for creating Flood features -- collections of adjacent points\n    that all have the same value\n    \"\"\"\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        return isinstance(e.data, VisionData)\n\n    def get_feature(self, e: PerceptionEvent) -&gt; None:\n        assert isinstance(e.data, VisionData)\n        data = IntGrid(e.data.glyphs)\n\n        check_map = CheckMap(data.width, data.height)\n\n        def recursive_flood_check(val: int, x: XLoc, y: YLoc, point_list: PointList) -&gt; PointList:\n            if x &lt; 0 or y &lt; 0 or x &gt;= data.width or y &gt;= data.height:\n                # out of bounds... move on\n                return point_list\n\n            if check_map.checked(x, y):\n                # we already checked this point... move on\n                return point_list\n\n            if data.get_val(x, y) != val:\n                # not the right value, for this flood... move on\n                return point_list\n\n            check_map.set(x, y)\n            point_list.append(Point(x, y, val))\n\n            # explanation:\n            # (0, 0) is top left, algorithm is iterating from left to right and\n            # top to bottom\n            # check left: already done\n            # check up *: already done\n\n            # check right\n            recursive_flood_check(val, XLoc(x + 1), y, point_list)\n            # check left down\n            recursive_flood_check(val, XLoc(x - 1), YLoc(y + 1), point_list)\n            # check down\n            recursive_flood_check(val, x, YLoc(y + 1), point_list)\n            # check right down\n            recursive_flood_check(val, XLoc(x + 1), YLoc(y + 1), point_list)\n\n            return point_list\n\n        while p := check_map.find_first_unused_point():\n            val = data.get_val(p.x, p.y)\n            point_list = recursive_flood_check(val, p.x, p.y, [])\n            if len(point_list) &gt;= MIN_FLOOD_SIZE:\n                point_set = set([(p.x, p.y) for p in point_list])\n                self.pb_conn.send(\n                    FloodFeature(\n                        origin_id=self.id,\n                        points=point_set,\n                        type=val,\n                        size=len(point_set),\n                    )\n                )\n            check_map.set(p.x, p.y)\n\n        self.settled()\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.Flood.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    return isinstance(e.data, VisionData)\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.Flood.get_feature","title":"<code>get_feature(e)</code>","text":"Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>def get_feature(self, e: PerceptionEvent) -&gt; None:\n    assert isinstance(e.data, VisionData)\n    data = IntGrid(e.data.glyphs)\n\n    check_map = CheckMap(data.width, data.height)\n\n    def recursive_flood_check(val: int, x: XLoc, y: YLoc, point_list: PointList) -&gt; PointList:\n        if x &lt; 0 or y &lt; 0 or x &gt;= data.width or y &gt;= data.height:\n            # out of bounds... move on\n            return point_list\n\n        if check_map.checked(x, y):\n            # we already checked this point... move on\n            return point_list\n\n        if data.get_val(x, y) != val:\n            # not the right value, for this flood... move on\n            return point_list\n\n        check_map.set(x, y)\n        point_list.append(Point(x, y, val))\n\n        # explanation:\n        # (0, 0) is top left, algorithm is iterating from left to right and\n        # top to bottom\n        # check left: already done\n        # check up *: already done\n\n        # check right\n        recursive_flood_check(val, XLoc(x + 1), y, point_list)\n        # check left down\n        recursive_flood_check(val, XLoc(x - 1), YLoc(y + 1), point_list)\n        # check down\n        recursive_flood_check(val, x, YLoc(y + 1), point_list)\n        # check right down\n        recursive_flood_check(val, XLoc(x + 1), YLoc(y + 1), point_list)\n\n        return point_list\n\n    while p := check_map.find_first_unused_point():\n        val = data.get_val(p.x, p.y)\n        point_list = recursive_flood_check(val, p.x, p.y, [])\n        if len(point_list) &gt;= MIN_FLOOD_SIZE:\n            point_set = set([(p.x, p.y) for p in point_list])\n            self.pb_conn.send(\n                FloodFeature(\n                    origin_id=self.id,\n                    points=point_set,\n                    type=val,\n                    size=len(point_set),\n                )\n            )\n        check_map.set(p.x, p.y)\n\n    self.settled()\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.FloodFeature","title":"<code>FloodFeature</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AreaFeature[FloodNode]</code></p> <p>A collection of points representing similar values that are all adjacent to each other</p> Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>@dataclass(kw_only=True)\nclass FloodFeature(AreaFeature[FloodNode]):\n    \"\"\"A collection of points representing similar values that are all adjacent to each other\"\"\"\n\n    feature_name: str = \"Flood\"\n\n    def _create_nodes(self) -&gt; FloodNode:\n        return FloodNode(type=self.type, size=self.size)\n\n    def _dbfetch_nodes(self) -&gt; FloodNode | None:\n        return FloodNode.find_one(\n            \"src.type = $type AND src.size = $size\", params={\"type\": self.type, \"size\": self.size}\n        )\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.FloodFeature.feature_name","title":"<code>feature_name: str = 'Flood'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.FloodFeature.__init__","title":"<code>__init__(*, feature_name='Flood')</code>","text":""},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.FloodNode","title":"<code>FloodNode</code>","text":"<p>               Bases: <code>FeatureNode</code></p> Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>class FloodNode(FeatureNode):\n    type: int\n    size: int\n\n    @property\n    def attr_strs(self) -&gt; list[str]:\n        return [str(self.type), str(self.size)]\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.FloodNode.attr_strs","title":"<code>attr_strs: list[str]</code>  <code>property</code>","text":""},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.FloodNode.size","title":"<code>size: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.FloodNode.type","title":"<code>type: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/line/","title":"line","text":""},{"location":"reference/feature_extractors/line/#feature_extractors.line.MIN_LINE_COUNT","title":"<code>MIN_LINE_COUNT = 4</code>  <code>module-attribute</code>","text":""},{"location":"reference/feature_extractors/line/#feature_extractors.line.Line","title":"<code>Line</code>","text":"<p>               Bases: <code>FeatureExtractor[TypedPointCollection]</code></p> <p>A component for identifying similar values located along a vertical or horizontal line</p> Source code in <code>roc/feature_extractors/line.py</code> <pre><code>@register_component(\"line\", \"perception\")\nclass Line(FeatureExtractor[TypedPointCollection]):\n    \"\"\"A component for identifying similar values located along a vertical or\n    horizontal line\n    \"\"\"\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        return isinstance(e.data, VisionData)\n\n    def get_feature(self, e: PerceptionEvent) -&gt; None:\n        assert isinstance(e.data, VisionData)\n        data = IntGrid(e.data.glyphs)\n\n        points: PointList = []\n\n        def try_emit(ln: Line) -&gt; None:\n            nonlocal points\n\n            if len(points) &gt;= MIN_LINE_COUNT:\n                point_set = set([(p.x, p.y) for p in points])\n                ln.pb_conn.send(\n                    LineFeature(\n                        origin_id=self.id,\n                        points=point_set,\n                        type=points[0].val,\n                        size=len(points),\n                    ),\n                )\n            points = []\n\n        ## iterate points by 'x' to identify horizontal lines\n        for y in range(data.height):\n            for x in range(data.width):\n                val = data.get_val(x, y)\n                points.append(Point(XLoc(x), YLoc(y), val))\n                if val != points[0].val:\n                    p = points.pop()\n                    try_emit(self)\n                    points = [p]\n            try_emit(self)\n\n        ## iterate points by 'y' to identify vertical lines\n        for x in range(data.width):\n            for y in range(data.height):\n                val = data.get_val(x, y)\n                points.append(Point(XLoc(x), YLoc(y), val))\n                if val != points[0].val:\n                    p = points.pop()\n                    try_emit(self)\n                    points = [p]\n            try_emit(self)\n\n        self.settled()\n</code></pre>"},{"location":"reference/feature_extractors/line/#feature_extractors.line.Line.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/feature_extractors/line.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    return isinstance(e.data, VisionData)\n</code></pre>"},{"location":"reference/feature_extractors/line/#feature_extractors.line.Line.get_feature","title":"<code>get_feature(e)</code>","text":"Source code in <code>roc/feature_extractors/line.py</code> <pre><code>def get_feature(self, e: PerceptionEvent) -&gt; None:\n    assert isinstance(e.data, VisionData)\n    data = IntGrid(e.data.glyphs)\n\n    points: PointList = []\n\n    def try_emit(ln: Line) -&gt; None:\n        nonlocal points\n\n        if len(points) &gt;= MIN_LINE_COUNT:\n            point_set = set([(p.x, p.y) for p in points])\n            ln.pb_conn.send(\n                LineFeature(\n                    origin_id=self.id,\n                    points=point_set,\n                    type=points[0].val,\n                    size=len(points),\n                ),\n            )\n        points = []\n\n    ## iterate points by 'x' to identify horizontal lines\n    for y in range(data.height):\n        for x in range(data.width):\n            val = data.get_val(x, y)\n            points.append(Point(XLoc(x), YLoc(y), val))\n            if val != points[0].val:\n                p = points.pop()\n                try_emit(self)\n                points = [p]\n        try_emit(self)\n\n    ## iterate points by 'y' to identify vertical lines\n    for x in range(data.width):\n        for y in range(data.height):\n            val = data.get_val(x, y)\n            points.append(Point(XLoc(x), YLoc(y), val))\n            if val != points[0].val:\n                p = points.pop()\n                try_emit(self)\n                points = [p]\n        try_emit(self)\n\n    self.settled()\n</code></pre>"},{"location":"reference/feature_extractors/line/#feature_extractors.line.LineFeature","title":"<code>LineFeature</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AreaFeature[LineNode]</code></p> <p>A collection of points representing a line</p> Source code in <code>roc/feature_extractors/line.py</code> <pre><code>@dataclass(kw_only=True)\nclass LineFeature(AreaFeature[LineNode]):\n    \"\"\"A collection of points representing a line\"\"\"\n\n    feature_name: str = \"Line\"\n\n    def _create_nodes(self) -&gt; LineNode:\n        return LineNode(type=self.type, size=self.size)\n\n    def _dbfetch_nodes(self) -&gt; LineNode | None:\n        return LineNode.find_one(\n            \"src.type = $type AND src.size = $size\", params={\"type\": self.type, \"size\": self.size}\n        )\n</code></pre>"},{"location":"reference/feature_extractors/line/#feature_extractors.line.LineFeature.feature_name","title":"<code>feature_name: str = 'Line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/line/#feature_extractors.line.LineFeature.__init__","title":"<code>__init__(*, feature_name='Line')</code>","text":""},{"location":"reference/feature_extractors/line/#feature_extractors.line.LineNode","title":"<code>LineNode</code>","text":"<p>               Bases: <code>FeatureNode</code></p> Source code in <code>roc/feature_extractors/line.py</code> <pre><code>class LineNode(FeatureNode):\n    type: int\n    size: int\n\n    @property\n    def attr_strs(self) -&gt; list[str]:\n        return [str(self.type), str(self.size)]\n</code></pre>"},{"location":"reference/feature_extractors/line/#feature_extractors.line.LineNode.attr_strs","title":"<code>attr_strs: list[str]</code>  <code>property</code>","text":""},{"location":"reference/feature_extractors/line/#feature_extractors.line.LineNode.size","title":"<code>size: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/line/#feature_extractors.line.LineNode.type","title":"<code>type: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/","title":"motion","text":"<p>Converts Delta events into Motion events that signify an object moving in a direction</p>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.DeltaList","title":"<code>DeltaList = list[DeltaFeature]</code>  <code>module-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.Motion","title":"<code>Motion</code>","text":"<p>               Bases: <code>FeatureExtractor[MotionFeature]</code></p> <p>Component that consumes Delta events and produces Motion events</p> Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>@register_component(\"motion\", \"perception\")\nclass Motion(FeatureExtractor[MotionFeature]):\n    \"\"\"Component that consumes Delta events and produces Motion events\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.delta_list: DeltaList = []\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        # only listen to delta:perception events\n        if e.src_id.name == \"delta\" and e.src_id.type == \"perception\":\n            return True\n        return False\n\n    def get_feature(self, e: PerceptionEvent) -&gt; None:\n        if isinstance(e.data, Settled):\n            self.delta_list.clear()\n            self.settled()\n            return None\n\n        assert isinstance(e.data, DeltaFeature)\n        d1 = e.data\n\n        for d2 in self.delta_list:\n            if Point.isadjacent(x1=d1.point[0], y1=d1.point[1], x2=d2.point[0], y2=d2.point[1]):\n                if d2.old_val == d1.new_val:\n                    emit_motion(self, d2, d1)\n                if d1.old_val == d2.new_val:\n                    emit_motion(self, d1, d2)\n\n        self.delta_list.append(d1)\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.Motion.delta_list","title":"<code>delta_list: DeltaList = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.Motion.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.delta_list: DeltaList = []\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.Motion.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    # only listen to delta:perception events\n    if e.src_id.name == \"delta\" and e.src_id.type == \"perception\":\n        return True\n    return False\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.Motion.get_feature","title":"<code>get_feature(e)</code>","text":"Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def get_feature(self, e: PerceptionEvent) -&gt; None:\n    if isinstance(e.data, Settled):\n        self.delta_list.clear()\n        self.settled()\n        return None\n\n    assert isinstance(e.data, DeltaFeature)\n    d1 = e.data\n\n    for d2 in self.delta_list:\n        if Point.isadjacent(x1=d1.point[0], y1=d1.point[1], x2=d2.point[0], y2=d2.point[1]):\n            if d2.old_val == d1.new_val:\n                emit_motion(self, d2, d1)\n            if d1.old_val == d2.new_val:\n                emit_motion(self, d1, d2)\n\n    self.delta_list.append(d1)\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionFeature","title":"<code>MotionFeature</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Feature[MotionNode]</code></p> <p>A vector describing a motion, including the start point, end point, direction and value of the thing moving</p> Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>@dataclass(kw_only=True)\nclass MotionFeature(Feature[MotionNode]):\n    \"\"\"A vector describing a motion, including the start point, end point,\n    direction and value of the thing moving\n    \"\"\"\n\n    feature_name: str = \"Motion\"\n    start_point: tuple[XLoc, YLoc]\n    end_point: tuple[XLoc, YLoc]\n    type: int\n    direction: Direction\n\n    def __str__(self) -&gt; str:\n        return f\"{self.type} '{chr(self.type)}' {self.direction}: ({self.start_point[0]}, {self.start_point[1]}) -&gt; ({self.end_point[0]}, {self.end_point[1]})\"\n\n    def get_points(self) -&gt; set[tuple[XLoc, YLoc]]:\n        return {self.end_point}\n\n    def node_hash(self) -&gt; int:\n        return hash((self.type, self.direction))\n\n    def _create_nodes(self) -&gt; MotionNode:\n        return MotionNode(type=self.type, direction=self.direction)\n\n    def _dbfetch_nodes(self) -&gt; MotionNode | None:\n        return MotionNode.find_one(\n            \"src.type = $type AND src.direction = $direction\",\n            params={\"type\": self.type, \"direction\": self.direction},\n            # params_to_str=False,\n        )\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionFeature.direction","title":"<code>direction: Direction</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionFeature.end_point","title":"<code>end_point: tuple[XLoc, YLoc]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionFeature.feature_name","title":"<code>feature_name: str = 'Motion'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionFeature.start_point","title":"<code>start_point: tuple[XLoc, YLoc]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionFeature.type","title":"<code>type: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionFeature.__init__","title":"<code>__init__(*, feature_name='Motion', start_point, end_point, type, direction)</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionFeature.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"{self.type} '{chr(self.type)}' {self.direction}: ({self.start_point[0]}, {self.start_point[1]}) -&gt; ({self.end_point[0]}, {self.end_point[1]})\"\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionFeature.get_points","title":"<code>get_points()</code>","text":"Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def get_points(self) -&gt; set[tuple[XLoc, YLoc]]:\n    return {self.end_point}\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionFeature.node_hash","title":"<code>node_hash()</code>","text":"Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def node_hash(self) -&gt; int:\n    return hash((self.type, self.direction))\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionNode","title":"<code>MotionNode</code>","text":"<p>               Bases: <code>FeatureNode</code></p> Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>class MotionNode(FeatureNode):\n    type: int\n    direction: Direction\n\n    @property\n    def attr_strs(self) -&gt; list[str]:\n        return [str(self.type), str(self.direction)]\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionNode.attr_strs","title":"<code>attr_strs: list[str]</code>  <code>property</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionNode.direction","title":"<code>direction: Direction</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionNode.type","title":"<code>type: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.adjacent_direction","title":"<code>adjacent_direction(d1, d2)</code>","text":"<p>Helper function to convert two positions into a direction such as 'UP' or 'DOWN_LEFT'</p> Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def adjacent_direction(d1: DeltaFeature, d2: DeltaFeature) -&gt; Direction:\n    \"\"\"Helper function to convert two positions into a direction such as 'UP' or\n    'DOWN_LEFT'\n    \"\"\"\n    lr_str = \"\"\n    if d1.point[0] &lt; d2.point[0]:\n        lr_str = \"RIGHT\"\n    elif d1.point[0] &gt; d2.point[0]:\n        lr_str = \"LEFT\"\n\n    ud_str = \"\"\n    # XXX: top left is 0,0\n    if d1.point[1] &gt; d2.point[1]:\n        ud_str = \"UP\"\n    if d1.point[1] &lt; d2.point[1]:\n        ud_str = \"DOWN\"\n\n    join_str = \"\"\n    if len(lr_str) and len(ud_str):\n        join_str = \"_\"\n\n    return Direction(f\"{ud_str}{join_str}{lr_str}\")\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.emit_motion","title":"<code>emit_motion(mc, old_delta, new_delta)</code>","text":"Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def emit_motion(mc: Motion, old_delta: DeltaFeature, new_delta: DeltaFeature) -&gt; None:\n    mc.pb_conn.send(\n        MotionFeature(\n            origin_id=mc.id,\n            start_point=old_delta.point,\n            end_point=new_delta.point,\n            type=new_delta.new_val,\n            direction=adjacent_direction(old_delta, new_delta),\n        )\n    )\n</code></pre>"},{"location":"reference/feature_extractors/shape/","title":"shape","text":"<p>Generates Features for things that aren't like their neighbors</p>"},{"location":"reference/feature_extractors/shape/#feature_extractors.shape.Shape","title":"<code>Shape</code>","text":"<p>               Bases: <code>FeatureExtractor[Point]</code></p> <p>A component for simulating the shape of features based on the character value.</p> Source code in <code>roc/feature_extractors/shape.py</code> <pre><code>@register_component(\"shape\", \"perception\")\nclass Shape(FeatureExtractor[Point]):\n    \"\"\"A component for simulating the shape of features based on the character\n    value.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.queue: list[SingleFeature] = list()\n        self.vd: VisionData | None = None\n        self.single_settled = False\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        \"\"\"Filters out non-SingleFeatures and non-VisionData\n\n        Args:\n            e (PerceptionEvent): Any event on the perception bus\n\n        Returns:\n            bool: Returns True if the event is a SingleFeature or VisionData to\n            keep processing it, False otherwise.\n        \"\"\"\n        return isinstance(e.data, VisionData) or e.src_id.name == \"single\"\n\n    def get_feature(self, e: PerceptionEvent) -&gt; None:\n        \"\"\"Emits the shape features.\n\n        Args:\n            e (PerceptionEvent): The VisionData or SingleFeature\n\n        Returns:\n            Feature | None: None\n        \"\"\"\n        if isinstance(e.data, SingleFeature):\n            self.queue.append(e.data)\n            return\n\n        if isinstance(e.data, Settled):\n            self.single_settled = True\n\n        if isinstance(e.data, VisionData):\n            self.vd = e.data\n\n        if self.single_settled and self.vd is not None:\n            for s in self.queue:\n                x, y = s.point\n                p = Point(x, y, self.vd.chars[y, x])\n                self.pb_conn.send(\n                    ShapeFeature(\n                        origin_id=self.id,\n                        point=(x, y),\n                        type=self.vd.chars[y, x],\n                    )\n                )\n\n            self.settled()\n            self.queue.clear()\n            self.single_settled = False\n            self.vd = None\n</code></pre>"},{"location":"reference/feature_extractors/shape/#feature_extractors.shape.Shape.queue","title":"<code>queue: list[SingleFeature] = list()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/shape/#feature_extractors.shape.Shape.single_settled","title":"<code>single_settled = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/shape/#feature_extractors.shape.Shape.vd","title":"<code>vd: VisionData | None = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/shape/#feature_extractors.shape.Shape.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/feature_extractors/shape.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.queue: list[SingleFeature] = list()\n    self.vd: VisionData | None = None\n    self.single_settled = False\n</code></pre>"},{"location":"reference/feature_extractors/shape/#feature_extractors.shape.Shape.event_filter","title":"<code>event_filter(e)</code>","text":"<p>Filters out non-SingleFeatures and non-VisionData</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>PerceptionEvent</code> <p>Any event on the perception bus</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns True if the event is a SingleFeature or VisionData to</p> <code>bool</code> <p>keep processing it, False otherwise.</p> Source code in <code>roc/feature_extractors/shape.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    \"\"\"Filters out non-SingleFeatures and non-VisionData\n\n    Args:\n        e (PerceptionEvent): Any event on the perception bus\n\n    Returns:\n        bool: Returns True if the event is a SingleFeature or VisionData to\n        keep processing it, False otherwise.\n    \"\"\"\n    return isinstance(e.data, VisionData) or e.src_id.name == \"single\"\n</code></pre>"},{"location":"reference/feature_extractors/shape/#feature_extractors.shape.Shape.get_feature","title":"<code>get_feature(e)</code>","text":"<p>Emits the shape features.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>PerceptionEvent</code> <p>The VisionData or SingleFeature</p> required <p>Returns:</p> Type Description <code>None</code> <p>Feature | None: None</p> Source code in <code>roc/feature_extractors/shape.py</code> <pre><code>def get_feature(self, e: PerceptionEvent) -&gt; None:\n    \"\"\"Emits the shape features.\n\n    Args:\n        e (PerceptionEvent): The VisionData or SingleFeature\n\n    Returns:\n        Feature | None: None\n    \"\"\"\n    if isinstance(e.data, SingleFeature):\n        self.queue.append(e.data)\n        return\n\n    if isinstance(e.data, Settled):\n        self.single_settled = True\n\n    if isinstance(e.data, VisionData):\n        self.vd = e.data\n\n    if self.single_settled and self.vd is not None:\n        for s in self.queue:\n            x, y = s.point\n            p = Point(x, y, self.vd.chars[y, x])\n            self.pb_conn.send(\n                ShapeFeature(\n                    origin_id=self.id,\n                    point=(x, y),\n                    type=self.vd.chars[y, x],\n                )\n            )\n\n        self.settled()\n        self.queue.clear()\n        self.single_settled = False\n        self.vd = None\n</code></pre>"},{"location":"reference/feature_extractors/shape/#feature_extractors.shape.ShapeFeature","title":"<code>ShapeFeature</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PointFeature[ShapeNode]</code></p> <p>The shape of a single feature.</p> Source code in <code>roc/feature_extractors/shape.py</code> <pre><code>@dataclass(kw_only=True)\nclass ShapeFeature(PointFeature[ShapeNode]):\n    \"\"\"The shape of a single feature.\"\"\"\n\n    feature_name: str = \"Shape\"\n\n    def _create_nodes(self) -&gt; ShapeNode:\n        return ShapeNode(type=self.type)\n\n    def _dbfetch_nodes(self) -&gt; ShapeNode | None:\n        return ShapeNode.find_one(\"src.type = $type\", params={\"type\": self.type})\n</code></pre>"},{"location":"reference/feature_extractors/shape/#feature_extractors.shape.ShapeFeature.feature_name","title":"<code>feature_name: str = 'Shape'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/shape/#feature_extractors.shape.ShapeFeature.__init__","title":"<code>__init__(*, feature_name='Shape')</code>","text":""},{"location":"reference/feature_extractors/shape/#feature_extractors.shape.ShapeNode","title":"<code>ShapeNode</code>","text":"<p>               Bases: <code>FeatureNode</code></p> Source code in <code>roc/feature_extractors/shape.py</code> <pre><code>class ShapeNode(FeatureNode):\n    type: int\n\n    @property\n    def attr_strs(self) -&gt; list[str]:\n        return [chr(self.type)]\n</code></pre>"},{"location":"reference/feature_extractors/shape/#feature_extractors.shape.ShapeNode.attr_strs","title":"<code>attr_strs: list[str]</code>  <code>property</code>","text":""},{"location":"reference/feature_extractors/shape/#feature_extractors.shape.ShapeNode.type","title":"<code>type: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/single/","title":"single","text":"<p>Generates Features for things that aren't like their neighbors</p>"},{"location":"reference/feature_extractors/single/#feature_extractors.single.Single","title":"<code>Single</code>","text":"<p>               Bases: <code>FeatureExtractor[Point]</code></p> <p>A component for identifying single, isolated visual features</p> Source code in <code>roc/feature_extractors/single.py</code> <pre><code>@register_component(\"single\", \"perception\")\nclass Single(FeatureExtractor[Point]):\n    \"\"\"A component for identifying single, isolated visual features\"\"\"\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        \"\"\"Filters out non-VisionData\n\n        Args:\n            e (PerceptionEvent): Any event on the perception bus\n\n        Returns:\n            bool: Returns True if the event is VisionData to keep processing it,\n            False otherwise.\n        \"\"\"\n        return isinstance(e.data, VisionData)\n\n    def get_feature(self, e: PerceptionEvent) -&gt; None:\n        \"\"\"Emits the shape features.\n\n        Args:\n            e (PerceptionEvent): The VisionData\n\n        Returns:\n            Feature | None: None\n        \"\"\"\n        vd = e.data\n        assert isinstance(vd, VisionData)\n        data = IntGrid(vd.glyphs)\n\n        ## iterate points\n        for x, y, v in data:\n            point = Point(x, y, v)\n            if is_unique_from_neighbors(data, point):\n                self.pb_conn.send(\n                    SingleFeature(\n                        origin_id=self.id,\n                        point=(x, y),\n                        type=v,\n                    )\n                )\n        self.settled()\n</code></pre>"},{"location":"reference/feature_extractors/single/#feature_extractors.single.Single.event_filter","title":"<code>event_filter(e)</code>","text":"<p>Filters out non-VisionData</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>PerceptionEvent</code> <p>Any event on the perception bus</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns True if the event is VisionData to keep processing it,</p> <code>bool</code> <p>False otherwise.</p> Source code in <code>roc/feature_extractors/single.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    \"\"\"Filters out non-VisionData\n\n    Args:\n        e (PerceptionEvent): Any event on the perception bus\n\n    Returns:\n        bool: Returns True if the event is VisionData to keep processing it,\n        False otherwise.\n    \"\"\"\n    return isinstance(e.data, VisionData)\n</code></pre>"},{"location":"reference/feature_extractors/single/#feature_extractors.single.Single.get_feature","title":"<code>get_feature(e)</code>","text":"<p>Emits the shape features.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>PerceptionEvent</code> <p>The VisionData</p> required <p>Returns:</p> Type Description <code>None</code> <p>Feature | None: None</p> Source code in <code>roc/feature_extractors/single.py</code> <pre><code>def get_feature(self, e: PerceptionEvent) -&gt; None:\n    \"\"\"Emits the shape features.\n\n    Args:\n        e (PerceptionEvent): The VisionData\n\n    Returns:\n        Feature | None: None\n    \"\"\"\n    vd = e.data\n    assert isinstance(vd, VisionData)\n    data = IntGrid(vd.glyphs)\n\n    ## iterate points\n    for x, y, v in data:\n        point = Point(x, y, v)\n        if is_unique_from_neighbors(data, point):\n            self.pb_conn.send(\n                SingleFeature(\n                    origin_id=self.id,\n                    point=(x, y),\n                    type=v,\n                )\n            )\n    self.settled()\n</code></pre>"},{"location":"reference/feature_extractors/single/#feature_extractors.single.SingleFeature","title":"<code>SingleFeature</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PointFeature[SingleNode]</code></p> <p>A single isolated feature with no similar features around it.</p> Source code in <code>roc/feature_extractors/single.py</code> <pre><code>@dataclass(kw_only=True)\nclass SingleFeature(PointFeature[SingleNode]):\n    \"\"\"A single isolated feature with no similar features around it.\"\"\"\n\n    feature_name: str = \"Single\"\n\n    def _create_nodes(self) -&gt; SingleNode:\n        return SingleNode(type=self.type)\n\n    def _dbfetch_nodes(self) -&gt; SingleNode | None:\n        return SingleNode.find_one(\"src.type = $type\", params={\"type\": self.type})\n</code></pre>"},{"location":"reference/feature_extractors/single/#feature_extractors.single.SingleFeature.feature_name","title":"<code>feature_name: str = 'Single'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/single/#feature_extractors.single.SingleFeature.__init__","title":"<code>__init__(*, feature_name='Single')</code>","text":""},{"location":"reference/feature_extractors/single/#feature_extractors.single.SingleNode","title":"<code>SingleNode</code>","text":"<p>               Bases: <code>FeatureNode</code></p> Source code in <code>roc/feature_extractors/single.py</code> <pre><code>class SingleNode(FeatureNode):\n    type: int\n\n    @property\n    def attr_strs(self) -&gt; list[str]:\n        return [str(self.type)]\n</code></pre>"},{"location":"reference/feature_extractors/single/#feature_extractors.single.SingleNode.attr_strs","title":"<code>attr_strs: list[str]</code>  <code>property</code>","text":""},{"location":"reference/feature_extractors/single/#feature_extractors.single.SingleNode.type","title":"<code>type: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/single/#feature_extractors.single.is_unique_from_neighbors","title":"<code>is_unique_from_neighbors(data, point)</code>","text":"<p>Helper function to determine if a point in a matrix has the same value as any points around it.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>VisionData</code> <p>The matrix / Grid to evaluate</p> required <code>point</code> <code>Point</code> <p>The point to see if any of its neighbors have the same value</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns True if the point is different from all surrounding</p> <code>bool</code> <p>points, False otherwise.</p> Source code in <code>roc/feature_extractors/single.py</code> <pre><code>def is_unique_from_neighbors(data: IntGrid, point: Point) -&gt; bool:\n    \"\"\"Helper function to determine if a point in a matrix has the same value as\n    any points around it.\n\n    Args:\n        data (VisionData): The matrix / Grid to evaluate\n        point (Point): The point to see if any of its neighbors have the same value\n\n    Returns:\n        bool: Returns True if the point is different from all surrounding\n        points, False otherwise.\n    \"\"\"\n    max_width = data.width - 1\n    max_height = data.height - 1\n    # up left\n    if point.x &gt; 0 and point.y &gt; 0 and data.get_val(point.x - 1, point.y - 1) == point.val:\n        return False\n    # up\n    if point.y &gt; 0 and data.get_val(point.x, point.y - 1) == point.val:\n        return False\n    # up right\n    if point.x &lt; max_width and point.y &gt; 0 and data.get_val(point.x + 1, point.y - 1) == point.val:\n        return False\n    # left\n    if point.x &gt; 0 and data.get_val(point.x - 1, point.y) == point.val:\n        return False\n    # right\n    if point.x &lt; max_width and data.get_val(point.x + 1, point.y) == point.val:\n        return False\n    # down left\n    if point.x &gt; 0 and point.y &lt; max_height and data.get_val(point.x - 1, point.y + 1) == point.val:\n        return False\n    # down\n    if point.y &lt; max_height and data.get_val(point.x, point.y + 1) == point.val:\n        return False\n    # down right\n    if (\n        point.x &lt; max_width\n        and point.y &lt; max_height\n        and data.get_val(point.x + 1, point.y + 1) == point.val\n    ):\n        return False\n    return True\n</code></pre>"},{"location":"reference/jupyter/brk/","title":"brk","text":""},{"location":"reference/jupyter/brk/#jupyter.brk.add","title":"<code>add(function)</code>","text":"<p>Add a breakpoints by name or function</p> Source code in <code>roc/jupyter/brk.py</code> <pre><code>@brk_cli.command()\n@click.argument(\"function\")\ndef add(function: str) -&gt; None:\n    \"\"\"Add a breakpoints by name or function\"\"\"\n    sym = get_symbol(function)\n\n    breakpoints.add(sym, name=function, src=\"&lt;iPython&gt;\")\n    print(f\"Added breakpoint: '{function}'\")  # noqa: T201\n</code></pre>"},{"location":"reference/jupyter/brk/#jupyter.brk.brk_cli","title":"<code>brk_cli(ctx)</code>","text":"<p>Controls breakpoints for ROC</p> Source code in <code>roc/jupyter/brk.py</code> <pre><code>@click.group(invoke_without_command=True)\n@click.pass_context\ndef brk_cli(ctx: click.Context) -&gt; None:\n    \"\"\"Controls breakpoints for ROC\"\"\"\n    if ctx.invoked_subcommand is None:\n        breakpoints.do_break()\n</code></pre>"},{"location":"reference/jupyter/brk/#jupyter.brk.clear","title":"<code>clear()</code>","text":"<p>Remove all breakpoints</p> Source code in <code>roc/jupyter/brk.py</code> <pre><code>@brk_cli.command()\ndef clear() -&gt; None:\n    \"\"\"Remove all breakpoints\"\"\"\n    breakpoints.clear()\n</code></pre>"},{"location":"reference/jupyter/brk/#jupyter.brk.list","title":"<code>list()</code>","text":"<p>List all breakpoints</p> Source code in <code>roc/jupyter/brk.py</code> <pre><code>@brk_cli.command()\ndef list() -&gt; None:\n    \"\"\"List all breakpoints\"\"\"\n    breakpoints.list()\n</code></pre>"},{"location":"reference/jupyter/brk/#jupyter.brk.remove","title":"<code>remove(name)</code>","text":"<p>Remove a breakpoint</p> Source code in <code>roc/jupyter/brk.py</code> <pre><code>@brk_cli.command()\n@click.argument(\"name\")\ndef remove(name: str) -&gt; None:\n    \"\"\"Remove a breakpoint\"\"\"\n    breakpoints.remove(name)\n</code></pre>"},{"location":"reference/jupyter/cont/","title":"cont","text":""},{"location":"reference/jupyter/cont/#jupyter.cont.cont_cli","title":"<code>cont_cli()</code>","text":"Source code in <code>roc/jupyter/cont.py</code> <pre><code>@click.command()\ndef cont_cli() -&gt; None:\n    breakpoints.resume()\n</code></pre>"},{"location":"reference/jupyter/roc/","title":"roc","text":""},{"location":"reference/jupyter/roc/#jupyter.roc.roc_cli","title":"<code>roc_cli(num_steps)</code>","text":"<p>Starts running ROC. Assumes that roc.init() has already been called (otherwise how are magics available?)</p> Source code in <code>roc/jupyter/roc.py</code> <pre><code>@click.command()\n@click.argument(\"num_steps\", type=int, default=-1)\ndef roc_cli(num_steps: int) -&gt; None:\n    \"\"\"Starts running ROC. Assumes that roc.init() has already been called\n    (otherwise how are magics available?)\n    \"\"\"\n    roc.start()\n    if num_steps &gt;= 0:\n        add_step(num_steps)\n</code></pre>"},{"location":"reference/jupyter/save/","title":"save","text":""},{"location":"reference/jupyter/save/#jupyter.save.save_cli","title":"<code>save_cli(format, filename, timestamp)</code>","text":"Source code in <code>roc/jupyter/save.py</code> <pre><code>@click.command()\n@click.option(\n    \"-f\",\n    \"--format\",\n    default=\"gexf\",\n    type=click.Choice(\n        [\n            \"gexf\",\n            \"gml\",\n            \"dot\",\n            \"graphml\",\n            \"json-node-link\",\n            \"json-adj\",\n            \"cytoscape\",\n            \"pajek\",\n            \"matrix-market\",\n            \"adj-list\",\n            \"multi-adj-list\",\n            \"edge-list\",\n        ],\n        case_sensitive=False,\n    ),\n)\n@click.option(\"--timestamp/--no-timestamp\", is_flag=True, default=True)\n@click.argument(\"filename\", nargs=1, type=click.Path(), default=\"graph\", required=False)\ndef save_cli(format: str, filename: str, timestamp: bool) -&gt; None:\n    ids = Node.all_ids()\n    print(f\"Saving {len(ids)} nodes...\")  # noqa: T201\n    start_time = time.time()\n\n    # tqdm options: https://github.com/tqdm/tqdm?tab=readme-ov-file#parameters\n    with tqdm(total=len(ids), desc=\"Nodes\", unit=\"node\", ncols=80, colour=\"blue\") as pbar:\n\n        def progress_update(n: Node) -&gt; bool:\n            pbar.update(1)\n            return True\n\n        G = GraphDB.to_networkx(node_ids=ids, filter=progress_update)\n\n    # format timestamp\n    if timestamp:\n        # time format: https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior\n        timestr = datetime.now().strftime(\"%Y.%m.%d-%H.%M.%S\")\n        filename = f\"{filename}-{timestr}\"\n\n    print(f\"Writing graph to '{filename}'...\")  # noqa: T201\n    match format:\n        case \"gexf\":\n            nx.write_gexf(G, f\"{filename}.gexf\")\n        case \"gml\":\n            nx.write_gml(G, f\"{filename}.gml\")\n        case \"dot\":\n            # XXX: pydot uses the 'name' attribute internally, so rename ours if it exists\n            for n in G.nodes(data=True):\n                if \"name\" in n[1]:\n                    n[1][\"nme\"] = n[1][\"name\"]\n                    del n[1][\"name\"]\n            write_dot(G, f\"{filename}.dot\")\n        case \"graphml\":\n            nx.write_graphml(G, f\"{filename}.graphml\")\n        # case \"json-tree\":\n        #     with open(f\"{filename}.tree.json\", \"w\", encoding=\"utf8\") as f:\n        #         json.dump(nx.tree_data(G), f)\n        case \"json-node-link\":\n            with open(f\"{filename}.node-link.json\", \"w\", encoding=\"utf8\") as f:\n                json.dump(nx.node_link_data(G), f)\n        case \"json-adj\":\n            with open(f\"{filename}.adj.json\", \"w\", encoding=\"utf8\") as f:\n                json.dump(nx.adjacency_data(G), f)\n        case \"cytoscape\":\n            with open(f\"{filename}.cytoscape.json\", \"w\", encoding=\"utf8\") as f:\n                json.dump(nx.cytoscape_data(G), f)\n        case \"pajek\":\n            nx.write_pajek(G, f\"{filename}.pajek\")\n        case \"matrix-market\":\n            np_graph = nx.to_numpy_array(G)\n            sp.io.mmwrite(f\"{filename}.mm\", np_graph)\n        case \"adj-list\":\n            nx.write_adjlist(G, f\"{filename}.adjlist\")\n        case \"multi-adj-list\":\n            nx.write_multiline_adjlist(G, f\"{filename}.madjlist\")\n        case \"edge-list\":\n            nx.write_edgelist(G, f\"{filename}.edges\")\n\n    end_time = time.time()\n\n    nc = Node.get_cache()\n    ec = Edge.get_cache()\n    assert len(nc) == len(ids)\n    print(  # noqa: T201\n        f\"Saved {len(ids)} nodes and {len(ec)} edges. Elapsed time: {timedelta(seconds=(end_time-start_time))}\"\n    )\n</code></pre>"},{"location":"reference/jupyter/state/","title":"state","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateType","title":"<code>StateType = TypeVar('StateType')</code>  <code>module-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.all_states","title":"<code>all_states = [field.name for field in dataclasses.fields(StateList)]</code>  <code>module-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.states","title":"<code>states = StateList()</code>  <code>module-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.AvailableMemoryState","title":"<code>AvailableMemoryState</code>","text":"<p>               Bases: <code>State[int]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class AvailableMemoryState(State[int]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"sysmem\")\n        self.val = self.get()\n\n    def __str__(self) -&gt; str:\n        vm = self.get()\n        return f\"Available System Memory: {bytes2human(vm)}\"\n\n    def get(self) -&gt; int:\n        vm = psutil.virtual_memory()\n        return cast(int, vm.available)\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.AvailableMemoryState.val","title":"<code>val = self.get()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.AvailableMemoryState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"sysmem\")\n    self.val = self.get()\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.AvailableMemoryState.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    vm = self.get()\n    return f\"Available System Memory: {bytes2human(vm)}\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.AvailableMemoryState.get","title":"<code>get()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def get(self) -&gt; int:\n    vm = psutil.virtual_memory()\n    return cast(int, vm.available)\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.ComponentsState","title":"<code>ComponentsState</code>","text":"<p>               Bases: <code>State[list[str]]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class ComponentsState(State[list[str]]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"components\", display_name=\"Components\")\n        self.val = []\n\n    def get(self) -&gt; list[str]:\n        self.val = Component.get_loaded_components()\n        return self.val\n\n    def __str__(self) -&gt; str:\n        component_str = \"\\t\" + \"\\n\\t\".join(self.get())\n        return f\"{Component.get_component_count()} components loaded:\\n{component_str}\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.ComponentsState.val","title":"<code>val = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.ComponentsState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"components\", display_name=\"Components\")\n    self.val = []\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.ComponentsState.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    component_str = \"\\t\" + \"\\n\\t\".join(self.get())\n    return f\"{Component.get_component_count()} components loaded:\\n{component_str}\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.ComponentsState.get","title":"<code>get()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def get(self) -&gt; list[str]:\n    self.val = Component.get_loaded_components()\n    return self.val\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CpuLoadState","title":"<code>CpuLoadState</code>","text":"<p>               Bases: <code>State[list[float]]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class CpuLoadState(State[list[float]]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"cpuload\")\n        self.val = self.get()\n\n    def __str__(self) -&gt; str:\n        load = self.get()\n        return f\"CPU Load: {load[0]:1.1f}% / {load[1]:1.1f}% / {load[2]:1.1f}% (1m / 5m / 15m)\"\n\n    def get(self) -&gt; list[float]:\n        return [x / psutil.cpu_count() * 100 for x in psutil.getloadavg()]\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CpuLoadState.val","title":"<code>val = self.get()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.CpuLoadState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"cpuload\")\n    self.val = self.get()\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CpuLoadState.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    load = self.get()\n    return f\"CPU Load: {load[0]:1.1f}% / {load[1]:1.1f}% / {load[2]:1.1f}% (1m / 5m / 15m)\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CpuLoadState.get","title":"<code>get()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def get(self) -&gt; list[float]:\n    return [x / psutil.cpu_count() * 100 for x in psutil.getloadavg()]\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentAttentionState","title":"<code>CurrentAttentionState</code>","text":"<p>               Bases: <code>State[VisionAttentionData]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class CurrentAttentionState(State[VisionAttentionData]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"curr-saliency\", display_name=\"Current Saliency Map\")\n\n    def set(self, att: VisionAttentionData) -&gt; None:\n        self.val = att\n\n    def __str__(self) -&gt; str:\n        if self.val is not None:\n            s = f\"Current Attention:\\n{str(self.val)}\\n\"\n            return s\n        else:\n            return \"Current Attention: None\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentAttentionState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"curr-saliency\", display_name=\"Current Saliency Map\")\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentAttentionState.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    if self.val is not None:\n        s = f\"Current Attention:\\n{str(self.val)}\\n\"\n        return s\n    else:\n        return \"Current Attention: None\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentAttentionState.set","title":"<code>set(att)</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def set(self, att: VisionAttentionData) -&gt; None:\n    self.val = att\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentObjectState","title":"<code>CurrentObjectState</code>","text":"<p>               Bases: <code>State[Object]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class CurrentObjectState(State[Object]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"curr-object\", display_name=\"Current Object\")\n\n    def set(self, obj: Object) -&gt; None:\n        self.val = obj\n\n    def __str__(self) -&gt; str:\n        if self.val is not None:\n            return f\"Current Object:\\n{str(self.val)}\\n\"\n        else:\n            return \"Current Object: None\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentObjectState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"curr-object\", display_name=\"Current Object\")\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentObjectState.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    if self.val is not None:\n        return f\"Current Object:\\n{str(self.val)}\\n\"\n    else:\n        return \"Current Object: None\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentObjectState.set","title":"<code>set(obj)</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def set(self, obj: Object) -&gt; None:\n    self.val = obj\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentSaliencyMapState","title":"<code>CurrentSaliencyMapState</code>","text":"<p>               Bases: <code>State[SaliencyMap]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class CurrentSaliencyMapState(State[SaliencyMap]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"curr-saliency\", display_name=\"Current Saliency Map\")\n\n    def set(self, sal: SaliencyMap) -&gt; None:\n        self.val = sal\n\n    def __str__(self) -&gt; str:\n        if self.val is not None:\n            s = f\"Current Saliency Map:\\n{str(self.val)}\\n\"\n            s += \"\\tFeatures:\\n\"\n            features = self.val.feature_report()\n            for feat_name in features:\n                s += f\"\\t\\t{feat_name}: {features[feat_name]}\\n\"\n            return s\n        else:\n            return \"Current Saliency Map: None\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentSaliencyMapState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"curr-saliency\", display_name=\"Current Saliency Map\")\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentSaliencyMapState.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    if self.val is not None:\n        s = f\"Current Saliency Map:\\n{str(self.val)}\\n\"\n        s += \"\\tFeatures:\\n\"\n        features = self.val.feature_report()\n        for feat_name in features:\n            s += f\"\\t\\t{feat_name}: {features[feat_name]}\\n\"\n        return s\n    else:\n        return \"Current Saliency Map: None\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentSaliencyMapState.set","title":"<code>set(sal)</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def set(self, sal: SaliencyMap) -&gt; None:\n    self.val = sal\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentScreenState","title":"<code>CurrentScreenState</code>","text":"<p>               Bases: <code>State[str]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class CurrentScreenState(State[str]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"curr-screen\", display_name=\"Current Screen\")\n\n    def set(self, screen: str) -&gt; None:\n        self.val = screen\n\n    def __str__(self) -&gt; str:\n        if self.val is not None:\n            return f\"Current Screen:\\n-------------\\n{self.val}\\n-------------\"\n        else:\n            return \"Current Screen: None\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentScreenState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"curr-screen\", display_name=\"Current Screen\")\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentScreenState.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    if self.val is not None:\n        return f\"Current Screen:\\n-------------\\n{self.val}\\n-------------\"\n    else:\n        return \"Current Screen: None\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CurrentScreenState.set","title":"<code>set(screen)</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def set(self, screen: str) -&gt; None:\n    self.val = screen\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState","title":"<code>DiskIoState</code>","text":"<p>               Bases: <code>State[dict[str, float]]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class DiskIoState(State[dict[str, float]]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"diskio\")\n        self.last_time = time.time_ns()\n        ioc = psutil.disk_io_counters()\n        self.last_read_io = ioc.read_count\n        self.last_write_io = ioc.write_count\n        self.last_read_bytes = ioc.read_bytes\n        self.last_write_bytes = ioc.write_bytes\n\n    def __str__(self) -&gt; str:\n        disk_io = self.get()\n        read_io = disk_io[\"read_io\"]\n        write_io = disk_io[\"write_io\"]\n        read_bytes = int(disk_io[\"read_bytes\"])\n        write_bytes = int(disk_io[\"write_bytes\"])\n        return f\"Disk Read I/O: {read_io:1.1f}/s ({bytes2human(read_bytes)}/s), Write I/O {write_io:1.1f}/s ({bytes2human(write_bytes)}/s)\"\n\n    def get(self) -&gt; dict[str, float]:\n        ioc = psutil.disk_io_counters()\n        now = time.time_ns()\n        delta_sec = (now - self.last_time) / 10e8\n        read_io_per_sec = (ioc.read_count - self.last_read_io) / delta_sec\n        write_io_per_sec = (ioc.write_count - self.last_write_io) / delta_sec\n        read_bytes_per_sec = (ioc.read_bytes - self.last_read_bytes) / delta_sec\n        write_bytes_per_sec = (ioc.write_bytes - self.last_write_bytes) / delta_sec\n        self.last_read_io = ioc.read_count\n        self.last_write_io = ioc.write_count\n        self.last_read_bytes = ioc.read_bytes\n        self.last_write_bytes = ioc.write_bytes\n        self.last_time = now\n\n        return {\n            \"read_io\": read_io_per_sec,\n            \"write_io\": write_io_per_sec,\n            \"read_bytes\": read_bytes_per_sec,\n            \"write_bytes\": write_bytes_per_sec,\n        }\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.last_read_bytes","title":"<code>last_read_bytes = ioc.read_bytes</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.last_read_io","title":"<code>last_read_io = ioc.read_count</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.last_time","title":"<code>last_time = time.time_ns()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.last_write_bytes","title":"<code>last_write_bytes = ioc.write_bytes</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.last_write_io","title":"<code>last_write_io = ioc.write_count</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"diskio\")\n    self.last_time = time.time_ns()\n    ioc = psutil.disk_io_counters()\n    self.last_read_io = ioc.read_count\n    self.last_write_io = ioc.write_count\n    self.last_read_bytes = ioc.read_bytes\n    self.last_write_bytes = ioc.write_bytes\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    disk_io = self.get()\n    read_io = disk_io[\"read_io\"]\n    write_io = disk_io[\"write_io\"]\n    read_bytes = int(disk_io[\"read_bytes\"])\n    write_bytes = int(disk_io[\"write_bytes\"])\n    return f\"Disk Read I/O: {read_io:1.1f}/s ({bytes2human(read_bytes)}/s), Write I/O {write_io:1.1f}/s ({bytes2human(write_bytes)}/s)\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.get","title":"<code>get()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def get(self) -&gt; dict[str, float]:\n    ioc = psutil.disk_io_counters()\n    now = time.time_ns()\n    delta_sec = (now - self.last_time) / 10e8\n    read_io_per_sec = (ioc.read_count - self.last_read_io) / delta_sec\n    write_io_per_sec = (ioc.write_count - self.last_write_io) / delta_sec\n    read_bytes_per_sec = (ioc.read_bytes - self.last_read_bytes) / delta_sec\n    write_bytes_per_sec = (ioc.write_bytes - self.last_write_bytes) / delta_sec\n    self.last_read_io = ioc.read_count\n    self.last_write_io = ioc.write_count\n    self.last_read_bytes = ioc.read_bytes\n    self.last_write_bytes = ioc.write_bytes\n    self.last_time = now\n\n    return {\n        \"read_io\": read_io_per_sec,\n        \"write_io\": write_io_per_sec,\n        \"read_bytes\": read_bytes_per_sec,\n        \"write_bytes\": write_bytes_per_sec,\n    }\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.EdgeCacheState","title":"<code>EdgeCacheState</code>","text":"<p>               Bases: <code>State[float]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class EdgeCacheState(State[float]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"edge-cache\", display_name=\"Edge Cache\")\n        self.val = 0\n\n    def get(self) -&gt; float:\n        c = Edge.get_cache()\n        return c.currsize / c.maxsize\n\n    def __str__(self) -&gt; str:\n        c = Edge.get_cache()\n        return f\"Edge Cache: {c.currsize} / {c.maxsize} ({self.get():1.1f}%)\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.EdgeCacheState.val","title":"<code>val = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.EdgeCacheState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"edge-cache\", display_name=\"Edge Cache\")\n    self.val = 0\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.EdgeCacheState.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    c = Edge.get_cache()\n    return f\"Edge Cache: {c.currsize} / {c.maxsize} ({self.get():1.1f}%)\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.EdgeCacheState.get","title":"<code>get()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def get(self) -&gt; float:\n    c = Edge.get_cache()\n    return c.currsize / c.maxsize\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.LoopState","title":"<code>LoopState</code>","text":"<p>               Bases: <code>State[int]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class LoopState(State[int]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"loop\", display_name=\"Loop Number\")\n        self.val = 0\n\n    def incr(self) -&gt; None:\n        self.val = self.get() + 1\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.LoopState.val","title":"<code>val = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.LoopState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"loop\", display_name=\"Loop Number\")\n    self.val = 0\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.LoopState.incr","title":"<code>incr()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def incr(self) -&gt; None:\n    self.val = self.get() + 1\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.NodeCacheState","title":"<code>NodeCacheState</code>","text":"<p>               Bases: <code>State[float]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class NodeCacheState(State[float]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"node-cache\", display_name=\"Node Cache\")\n        self.val = 0\n\n    def get(self) -&gt; float:\n        c = Node.get_cache()\n        return c.currsize / c.maxsize\n\n    def __str__(self) -&gt; str:\n        c = Node.get_cache()\n        return f\"Node Cache: {c.currsize} / {c.maxsize} ({self.get():1.1f}%)\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.NodeCacheState.val","title":"<code>val = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.NodeCacheState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"node-cache\", display_name=\"Node Cache\")\n    self.val = 0\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.NodeCacheState.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    c = Node.get_cache()\n    return f\"Node Cache: {c.currsize} / {c.maxsize} ({self.get():1.1f}%)\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.NodeCacheState.get","title":"<code>get()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def get(self) -&gt; float:\n    c = Node.get_cache()\n    return c.currsize / c.maxsize\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.ProcessMemoryState","title":"<code>ProcessMemoryState</code>","text":"<p>               Bases: <code>State[int]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class ProcessMemoryState(State[int]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"memory\")\n        self.val = self.get()\n\n    def __str__(self) -&gt; str:\n        mem = self.get()\n        return f\"Process Memory Usage: {bytes2human(mem)}\"\n\n    def get(self) -&gt; int:\n        process = psutil.Process(os.getpid())\n        mem_info = process.memory_info()\n        return cast(int, mem_info.rss)\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.ProcessMemoryState.val","title":"<code>val = self.get()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.ProcessMemoryState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"memory\")\n    self.val = self.get()\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.ProcessMemoryState.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    mem = self.get()\n    return f\"Process Memory Usage: {bytes2human(mem)}\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.ProcessMemoryState.get","title":"<code>get()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def get(self) -&gt; int:\n    process = psutil.Process(os.getpid())\n    mem_info = process.memory_info()\n    return cast(int, mem_info.rss)\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.State","title":"<code>State</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[StateType]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class State(ABC, Generic[StateType]):\n    def __init__(self, name: str, display_name: str | None = None) -&gt; None:\n        self.name = name\n        self.display_name = display_name or name\n        self.val: StateType | None = None\n\n    def __str__(self) -&gt; str:\n        return f\"{self.display_name}: {self.val}\"\n\n    def get(self) -&gt; StateType:\n        if self.val is None:\n            raise Exception(\"Trying to get state value before it is set\")\n\n        return self.val\n\n    def set(self, v: StateType) -&gt; None:\n        self.val = v\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.State.display_name","title":"<code>display_name = display_name or name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.State.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.State.val","title":"<code>val: StateType | None = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.State.__init__","title":"<code>__init__(name, display_name=None)</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self, name: str, display_name: str | None = None) -&gt; None:\n    self.name = name\n    self.display_name = display_name or name\n    self.val: StateType | None = None\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.State.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"{self.display_name}: {self.val}\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.State.get","title":"<code>get()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def get(self) -&gt; StateType:\n    if self.val is None:\n        raise Exception(\"Trying to get state value before it is set\")\n\n    return self.val\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.State.set","title":"<code>set(v)</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def set(self, v: StateType) -&gt; None:\n    self.val = v\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.StateComponent","title":"<code>StateComponent</code>","text":"<p>               Bases: <code>Component</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class StateComponent(Component):\n    pass\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.StateList","title":"<code>StateList</code>  <code>dataclass</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>@dataclass\nclass StateList:\n    memory: ProcessMemoryState = ProcessMemoryState()\n    sysmem: AvailableMemoryState = AvailableMemoryState()\n    loop: LoopState = LoopState()\n    cpuload: CpuLoadState = CpuLoadState()\n    diskio: DiskIoState = DiskIoState()\n    node_cache: NodeCacheState = NodeCacheState()\n    edge_cache: EdgeCacheState = EdgeCacheState()\n    screen: CurrentScreenState = CurrentScreenState()\n    salency: CurrentSaliencyMapState = CurrentSaliencyMapState()\n    attention: CurrentAttentionState = CurrentAttentionState()\n    object: CurrentObjectState = CurrentObjectState()\n    components: ComponentsState = ComponentsState()\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.StateList.attention","title":"<code>attention: CurrentAttentionState = CurrentAttentionState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.components","title":"<code>components: ComponentsState = ComponentsState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.cpuload","title":"<code>cpuload: CpuLoadState = CpuLoadState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.diskio","title":"<code>diskio: DiskIoState = DiskIoState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.edge_cache","title":"<code>edge_cache: EdgeCacheState = EdgeCacheState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.loop","title":"<code>loop: LoopState = LoopState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.memory","title":"<code>memory: ProcessMemoryState = ProcessMemoryState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.node_cache","title":"<code>node_cache: NodeCacheState = NodeCacheState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.object","title":"<code>object: CurrentObjectState = CurrentObjectState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.salency","title":"<code>salency: CurrentSaliencyMapState = CurrentSaliencyMapState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.screen","title":"<code>screen: CurrentScreenState = CurrentScreenState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.sysmem","title":"<code>sysmem: AvailableMemoryState = AvailableMemoryState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.__init__","title":"<code>__init__(memory=ProcessMemoryState(), sysmem=AvailableMemoryState(), loop=LoopState(), cpuload=CpuLoadState(), diskio=DiskIoState(), node_cache=NodeCacheState(), edge_cache=EdgeCacheState(), screen=CurrentScreenState(), salency=CurrentSaliencyMapState(), attention=CurrentAttentionState(), object=CurrentObjectState(), components=ComponentsState())</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.SystemCpuState","title":"<code>SystemCpuState</code>","text":"<p>               Bases: <code>State[int]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class SystemCpuState(State[int]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"cpu\", display_name=\"CPU Usage\")\n        self.val = self.get()\n\n    def get(self) -&gt; int:\n        psutil.cpu_times()\n        return 1\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.SystemCpuState.val","title":"<code>val = self.get()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.SystemCpuState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"cpu\", display_name=\"CPU Usage\")\n    self.val = self.get()\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.SystemCpuState.get","title":"<code>get()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def get(self) -&gt; int:\n    psutil.cpu_times()\n    return 1\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.init_state","title":"<code>init_state()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def init_state() -&gt; None:\n    global _state_init_done\n    if _state_init_done:\n        return\n\n    # attention\n    att_conn = Attention.bus.connect(StateComponent())\n\n    def att_evt_handler(e: Event[VisionAttentionData]) -&gt; None:\n        assert isinstance(e.data, VisionAttentionData)\n        states.salency.set(deepcopy(e.data.saliency_map))\n        states.attention.set(deepcopy(e.data))\n\n    att_conn.listen(att_evt_handler, filter=lambda e: isinstance(e.data, VisionAttentionData))\n\n    # object\n    obj_conn = ObjectResolver.bus.connect(StateComponent())\n\n    def obj_evt_handler(e: Event[Object]) -&gt; None:\n        states.object.set(e.data)\n\n    obj_conn.listen(obj_evt_handler, filter=lambda e: isinstance(e.data, Object))\n\n    _state_init_done = True\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.print_state","title":"<code>print_state()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def print_state() -&gt; None:\n    init_state()\n\n    def header(s: str) -&gt; None:\n        print(f\"\\n=== {s.upper()} ===\")  # noqa: T201\n\n    header(\"System Health\")\n    print(states.cpuload)  # noqa: T201\n    print(states.diskio)  # noqa: T201\n    print(states.memory)  # noqa: T201\n    print(states.sysmem)  # noqa: T201\n\n    header(\"Environment\")\n    print(states.loop)  # noqa: T201\n    print(states.screen)  # noqa: T201\n    # TODO: blstats\n\n    header(\"Graph DB\")\n    print(states.node_cache)  # noqa: T201\n    print(states.edge_cache)  # noqa: T201\n\n    header(\"Agent\")\n    print(states.components)  # noqa: T201\n    print(states.salency)  # noqa: T201\n    print(states.attention)  # noqa: T201\n    print(states.object)  # noqa: T201\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.state_cli","title":"<code>state_cli(var)</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>@click.command()\n@click.argument(\n    \"var\",\n    nargs=-1,\n    type=click.Choice(all_states, case_sensitive=False),\n)\ndef state_cli(var: list[str]) -&gt; None:\n    if var is None or len(var) &lt; 1:\n        # if no state is specified, print a selection of the most interesting states\n        print_state()\n        return\n\n    for v in var:\n        s = getattr(states, v)\n        print(str(s))  # noqa: T201\n</code></pre>"},{"location":"reference/jupyter/step/","title":"step","text":""},{"location":"reference/jupyter/step/#jupyter.step.step_cnt","title":"<code>step_cnt = 0</code>  <code>module-attribute</code>","text":""},{"location":"reference/jupyter/step/#jupyter.step.add_step","title":"<code>add_step(num_steps=1)</code>","text":"Source code in <code>roc/jupyter/step.py</code> <pre><code>def add_step(num_steps: int = 1) -&gt; None:\n    global step_cnt\n\n    step_cnt = num_steps\n    logger.info(f\"stepping {step_cnt} times...\")\n\n    breakpoints.add(do_step, name=\"step\")\n    breakpoints.resume(quiet=True)\n</code></pre>"},{"location":"reference/jupyter/step/#jupyter.step.do_step","title":"<code>do_step()</code>","text":"Source code in <code>roc/jupyter/step.py</code> <pre><code>def do_step() -&gt; bool:\n    global step_cnt\n\n    step_cnt -= 1\n    if step_cnt &lt;= 0:\n        breakpoints.remove(\"step\")\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/jupyter/step/#jupyter.step.step_cli","title":"<code>step_cli(num_steps)</code>","text":"Source code in <code>roc/jupyter/step.py</code> <pre><code>@click.command()\n@click.argument(\"num_steps\", type=int, default=1)\ndef step_cli(num_steps: int) -&gt; None:\n    add_step(num_steps)\n</code></pre>"},{"location":"reference/jupyter/utils/","title":"utils","text":""},{"location":"reference/jupyter/utils/#jupyter.utils.bytes2human","title":"<code>bytes2human(n)</code>","text":"Source code in <code>roc/jupyter/utils.py</code> <pre><code>def bytes2human(n: int) -&gt; str:\n    # stolen from: https://psutil.readthedocs.io/en/latest/#recipes\n    symbols = (\"K\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\")\n    prefix = {}\n    for i, s in enumerate(symbols):\n        prefix[s] = 1 &lt;&lt; (i + 1) * 10\n    for s in reversed(symbols):\n        if abs(n) &gt;= prefix[s]:\n            value = float(n) / prefix[s]\n            return \"%.1f%sB\" % (value, s)\n    return \"%sB\" % n\n</code></pre>"},{"location":"reference/jupyter/utils/#jupyter.utils.get_symbol","title":"<code>get_symbol(s)</code>","text":"Source code in <code>roc/jupyter/utils.py</code> <pre><code>def get_symbol(s: str) -&gt; Any:\n    ip = get_ipython()  # type: ignore\n\n    if s not in ip.user_ns:\n        print(f\"ERROR: symbol '{s}' not found in iPython shell\")  # noqa: T201\n        return\n\n    return ip.user_ns[s]\n</code></pre>"}]}