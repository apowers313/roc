{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Main","text":"<p>Reinforcement Learning of Concepts</p>"},{"location":"#roc.ActionData","title":"<code>ActionData = Annotated[ActionCount | ActionGo, Field(discriminator='type')]</code>  <code>module-attribute</code>","text":""},{"location":"#roc.PerceptionData","title":"<code>PerceptionData = VisionData | FeatureData</code>  <code>module-attribute</code>","text":""},{"location":"#roc.__all__","title":"<code>__all__ = ['Component', 'GymComponent', 'Perception', 'PerceptionData', 'action_bus', 'ActionData']</code>  <code>module-attribute</code>","text":""},{"location":"#roc.action_bus","title":"<code>action_bus = EventBus[ActionData]('action')</code>  <code>module-attribute</code>","text":""},{"location":"#roc.Component","title":"<code>Component</code>","text":"<p>             Bases: <code>ABC</code></p> <p>An abstract component class for building pieces of ROC that will talk to each other.</p> Source code in <code>roc/component.py</code> <pre><code>class Component(ABC):\n    \"\"\"An abstract component class for building pieces of ROC that will talk to each other.\"\"\"\n\n    name: str = \"&lt;name unassigned&gt;\"\n    type: str = \"&lt;type unassigned&gt;\"\n\n    def __init__(self) -&gt; None:\n        global component_count\n        component_count = component_count + 1\n        self.bus_conns: dict[str, BusConnection[Any]] = {}\n        # print(\"\\n\\n++ incrementing component count:\", self.name, self.type, self)\n        # traceback.print_stack()\n\n    def __del__(self) -&gt; None:\n        global component_count\n        component_count = component_count - 1\n        # print(\"\\n\\n-- decrementing component count\", self.name, self.type, self)\n\n    def connect_bus(self, bus: EventBus[T]) -&gt; BusConnection[T]:\n        \"\"\"Create a new bus connection for the component, storing the result for\n        later shutdown.\n\n        Args:\n            bus (EventBus[T]): The event bus to attach to\n\n        Raises:\n            ValueError: if the bus has already been connected to by this component\n\n        Returns:\n            BusConnection[T]: The bus connection for listening or sending events\n        \"\"\"\n        if bus.name in self.bus_conns:\n            raise ValueError(\n                f\"Component '{self.name}' attempting duplicate connection to bus '{bus.name}'\"\n            )\n\n        conn = bus.connect(self)\n        self.bus_conns[bus.name] = conn\n        return conn\n\n    def event_filter(self, e: Event[Any]) -&gt; bool:\n        \"\"\"A filter for any incoming events. By default it filters out events\n        sent by itself, but it is especially useful for creating new filters in\n        sub-classes.\n\n        Args:\n            e (Event[Any]): The event to be evaluated\n\n        Returns:\n            bool: True if the event should be sent, False if it should be dropped\n        \"\"\"\n        return e.src is not self\n\n    def shutdown(self) -&gt; None:\n        \"\"\"De-initializes the component, removing any bus connections and any\n        other clean-up that needs to be performed\"\"\"\n\n        for conn in self.bus_conns:\n            for obs in self.bus_conns[conn].attached_bus.subject.observers:\n                obs.on_completed()\n\n    @staticmethod\n    def init() -&gt; None:\n        \"\"\"Loads all components registered as `auto` and perception components\n        in the `perception_components` config field.\"\"\"\n\n        settings = Config.get()\n        component_list = default_components\n        component_list = component_list.union(settings.perception_components)\n\n        # TODO: shutdown previously loaded components\n\n        for reg_str in component_list:\n            logger.trace(f\"Loading component: {reg_str} ...\")\n            (name, type) = reg_str.split(\":\")\n            loaded_components[reg_str] = Component.get(name, type)\n\n    @classmethod\n    def get(cls, name: str, type: str, *args: Any, **kwargs: Any) -&gt; Self:\n        \"\"\"Retreives a component with the specified name from the registry and\n        creates a new version of it with the specified args. Used by\n        `Config.init` and for testing.\n\n        Args:\n            name (str): The name of the component to get, as specified during\n                its registration\n            type (str): The type of the component to get, as specified during\n                its registration\n            args (Any): Fixed position arguments to pass to the Component\n                constructor\n            kwargs (Any): Keyword args to pass to the Component constructor\n\n        Returns:\n            Self: the component that was created, casted as the calling class.\n            (e.g. `Perception.get(...)` will return a Perception component and\n            `Action.get(...)` will return an Action component)\n        \"\"\"\n\n        reg_str = _component_registry_key(name, type)\n        return cast(Self, component_registry[reg_str](*args, **kwargs))\n\n    @staticmethod\n    def get_component_count() -&gt; int:\n        \"\"\"Returns the number of currently created Components. The number goes\n        up on __init__ and down on __del__. Primarily used for testing to ensure\n        Components are being shutdown appropriately.\n\n        Returns:\n            int: The number of currently active Component instances\n        \"\"\"\n        global component_count\n        return component_count\n\n    @staticmethod\n    def deregister(name: str, type: str) -&gt; None:\n        \"\"\"Removes a component from the Component registry. Primarlly used for testing.\n\n        Args:\n            name (str): The name of the Component to deregister\n            type (str): The type of the Component to deregister\n        \"\"\"\n        reg_str = _component_registry_key(name, type)\n        del component_registry[reg_str]\n\n    @staticmethod\n    def reset() -&gt; None:\n        \"\"\"Shuts down all components\"\"\"\n        # shutdown all components\n        global loaded_components\n        for name in loaded_components:\n            logger.trace(f\"Shutting down component: {name}.\")\n            c = loaded_components[name]\n            c.shutdown()\n\n        loaded_components.clear()\n</code></pre>"},{"location":"#roc.Component.bus_conns","title":"<code>bus_conns: dict[str, BusConnection[Any]] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"#roc.Component.name","title":"<code>name: str = '&lt;name unassigned&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#roc.Component.type","title":"<code>type: str = '&lt;type unassigned&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#roc.Component.__del__","title":"<code>__del__()</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __del__(self) -&gt; None:\n    global component_count\n    component_count = component_count - 1\n</code></pre>"},{"location":"#roc.Component.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __init__(self) -&gt; None:\n    global component_count\n    component_count = component_count + 1\n    self.bus_conns: dict[str, BusConnection[Any]] = {}\n</code></pre>"},{"location":"#roc.Component.connect_bus","title":"<code>connect_bus(bus)</code>","text":"<p>Create a new bus connection for the component, storing the result for later shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>EventBus[T]</code> <p>The event bus to attach to</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the bus has already been connected to by this component</p> <p>Returns:</p> Type Description <code>BusConnection[T]</code> <p>BusConnection[T]: The bus connection for listening or sending events</p> Source code in <code>roc/component.py</code> <pre><code>def connect_bus(self, bus: EventBus[T]) -&gt; BusConnection[T]:\n    \"\"\"Create a new bus connection for the component, storing the result for\n    later shutdown.\n\n    Args:\n        bus (EventBus[T]): The event bus to attach to\n\n    Raises:\n        ValueError: if the bus has already been connected to by this component\n\n    Returns:\n        BusConnection[T]: The bus connection for listening or sending events\n    \"\"\"\n    if bus.name in self.bus_conns:\n        raise ValueError(\n            f\"Component '{self.name}' attempting duplicate connection to bus '{bus.name}'\"\n        )\n\n    conn = bus.connect(self)\n    self.bus_conns[bus.name] = conn\n    return conn\n</code></pre>"},{"location":"#roc.Component.deregister","title":"<code>deregister(name, type)</code>  <code>staticmethod</code>","text":"<p>Removes a component from the Component registry. Primarlly used for testing.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the Component to deregister</p> required <code>type</code> <code>str</code> <p>The type of the Component to deregister</p> required Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef deregister(name: str, type: str) -&gt; None:\n    \"\"\"Removes a component from the Component registry. Primarlly used for testing.\n\n    Args:\n        name (str): The name of the Component to deregister\n        type (str): The type of the Component to deregister\n    \"\"\"\n    reg_str = _component_registry_key(name, type)\n    del component_registry[reg_str]\n</code></pre>"},{"location":"#roc.Component.event_filter","title":"<code>event_filter(e)</code>","text":"<p>A filter for any incoming events. By default it filters out events sent by itself, but it is especially useful for creating new filters in sub-classes.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Event[Any]</code> <p>The event to be evaluated</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the event should be sent, False if it should be dropped</p> Source code in <code>roc/component.py</code> <pre><code>def event_filter(self, e: Event[Any]) -&gt; bool:\n    \"\"\"A filter for any incoming events. By default it filters out events\n    sent by itself, but it is especially useful for creating new filters in\n    sub-classes.\n\n    Args:\n        e (Event[Any]): The event to be evaluated\n\n    Returns:\n        bool: True if the event should be sent, False if it should be dropped\n    \"\"\"\n    return e.src is not self\n</code></pre>"},{"location":"#roc.Component.get","title":"<code>get(name, type, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Retreives a component with the specified name from the registry and creates a new version of it with the specified args. Used by <code>Config.init</code> and for testing.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the component to get, as specified during its registration</p> required <code>type</code> <code>str</code> <p>The type of the component to get, as specified during its registration</p> required <code>args</code> <code>Any</code> <p>Fixed position arguments to pass to the Component constructor</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>Keyword args to pass to the Component constructor</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the component that was created, casted as the calling class.</p> <code>Self</code> <p>(e.g. <code>Perception.get(...)</code> will return a Perception component and</p> <code>Self</code> <p><code>Action.get(...)</code> will return an Action component)</p> Source code in <code>roc/component.py</code> <pre><code>@classmethod\ndef get(cls, name: str, type: str, *args: Any, **kwargs: Any) -&gt; Self:\n    \"\"\"Retreives a component with the specified name from the registry and\n    creates a new version of it with the specified args. Used by\n    `Config.init` and for testing.\n\n    Args:\n        name (str): The name of the component to get, as specified during\n            its registration\n        type (str): The type of the component to get, as specified during\n            its registration\n        args (Any): Fixed position arguments to pass to the Component\n            constructor\n        kwargs (Any): Keyword args to pass to the Component constructor\n\n    Returns:\n        Self: the component that was created, casted as the calling class.\n        (e.g. `Perception.get(...)` will return a Perception component and\n        `Action.get(...)` will return an Action component)\n    \"\"\"\n\n    reg_str = _component_registry_key(name, type)\n    return cast(Self, component_registry[reg_str](*args, **kwargs))\n</code></pre>"},{"location":"#roc.Component.get_component_count","title":"<code>get_component_count()</code>  <code>staticmethod</code>","text":"<p>Returns the number of currently created Components. The number goes up on init and down on del. Primarily used for testing to ensure Components are being shutdown appropriately.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of currently active Component instances</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef get_component_count() -&gt; int:\n    \"\"\"Returns the number of currently created Components. The number goes\n    up on __init__ and down on __del__. Primarily used for testing to ensure\n    Components are being shutdown appropriately.\n\n    Returns:\n        int: The number of currently active Component instances\n    \"\"\"\n    global component_count\n    return component_count\n</code></pre>"},{"location":"#roc.Component.init","title":"<code>init()</code>  <code>staticmethod</code>","text":"<p>Loads all components registered as <code>auto</code> and perception components in the <code>perception_components</code> config field.</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef init() -&gt; None:\n    \"\"\"Loads all components registered as `auto` and perception components\n    in the `perception_components` config field.\"\"\"\n\n    settings = Config.get()\n    component_list = default_components\n    component_list = component_list.union(settings.perception_components)\n\n    # TODO: shutdown previously loaded components\n\n    for reg_str in component_list:\n        logger.trace(f\"Loading component: {reg_str} ...\")\n        (name, type) = reg_str.split(\":\")\n        loaded_components[reg_str] = Component.get(name, type)\n</code></pre>"},{"location":"#roc.Component.reset","title":"<code>reset()</code>  <code>staticmethod</code>","text":"<p>Shuts down all components</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef reset() -&gt; None:\n    \"\"\"Shuts down all components\"\"\"\n    # shutdown all components\n    global loaded_components\n    for name in loaded_components:\n        logger.trace(f\"Shutting down component: {name}.\")\n        c = loaded_components[name]\n        c.shutdown()\n\n    loaded_components.clear()\n</code></pre>"},{"location":"#roc.Component.shutdown","title":"<code>shutdown()</code>","text":"<p>De-initializes the component, removing any bus connections and any other clean-up that needs to be performed</p> Source code in <code>roc/component.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"De-initializes the component, removing any bus connections and any\n    other clean-up that needs to be performed\"\"\"\n\n    for conn in self.bus_conns:\n        for obs in self.bus_conns[conn].attached_bus.subject.observers:\n            obs.on_completed()\n</code></pre>"},{"location":"#roc.Perception","title":"<code>Perception</code>","text":"<p>             Bases: <code>Component</code>, <code>ABC</code></p> <p>The abstract class for Perception components. Handles perception bus connections and corresponding clean-up.</p> Source code in <code>roc/perception.py</code> <pre><code>class Perception(Component, ABC):\n    \"\"\"The abstract class for Perception components. Handles perception bus\n    connections and corresponding clean-up.\"\"\"\n\n    bus = EventBus[PerceptionData](\"perception\")\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.pb_conn = self.connect_bus(Perception.bus)\n        self.pb_conn.listen(self.do_perception)\n\n    @abstractmethod\n    def do_perception(self, e: PerceptionEvent) -&gt; None:\n        ...\n\n    @classmethod\n    def init(cls) -&gt; None:\n        global perception_bus\n        cls.bus = EventBus[PerceptionData](\"perception\")\n</code></pre>"},{"location":"#roc.Perception.bus","title":"<code>bus = EventBus[PerceptionData]('perception')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#roc.Perception.pb_conn","title":"<code>pb_conn = self.connect_bus(Perception.bus)</code>  <code>instance-attribute</code>","text":""},{"location":"#roc.Perception.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.pb_conn = self.connect_bus(Perception.bus)\n    self.pb_conn.listen(self.do_perception)\n</code></pre>"},{"location":"#roc.Perception.do_perception","title":"<code>do_perception(e)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@abstractmethod\ndef do_perception(self, e: PerceptionEvent) -&gt; None:\n    ...\n</code></pre>"},{"location":"#roc.Perception.init","title":"<code>init()</code>  <code>classmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@classmethod\ndef init(cls) -&gt; None:\n    global perception_bus\n    cls.bus = EventBus[PerceptionData](\"perception\")\n</code></pre>"},{"location":"#roc.init","title":"<code>init()</code>","text":"<p>Initializes the agent before starting the agent.</p> Source code in <code>roc/__init__.py</code> <pre><code>def init() -&gt; None:\n    \"\"\"Initializes the agent before starting the agent.\"\"\"\n\n    Config.init()\n    logger.init()\n    Component.init()\n</code></pre>"},{"location":"#roc.start","title":"<code>start()</code>","text":"<p>Starts the agent.</p> Source code in <code>roc/__init__.py</code> <pre><code>def start() -&gt; None:\n    \"\"\"Starts the agent.\"\"\"\n\n    g = NethackGym()\n    g.start()\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>action</li> <li>component</li> <li>config</li> <li>event</li> <li>feature_extractors<ul> <li>delta</li> </ul> </li> <li>graphdb</li> <li>gymnasium</li> <li>intrinsic</li> <li>logger</li> <li>perception</li> <li>script</li> </ul>"},{"location":"reference/action/","title":"action","text":"<p>The action module decides what action the agent should perform.</p>"},{"location":"reference/action/#action.ActionData","title":"<code>ActionData = Annotated[ActionCount | ActionGo, Field(discriminator='type')]</code>  <code>module-attribute</code>","text":""},{"location":"reference/action/#action.ActionEvent","title":"<code>ActionEvent = Event[ActionData]</code>  <code>module-attribute</code>","text":""},{"location":"reference/action/#action.ActionFn","title":"<code>ActionFn = Callable[[], int]</code>  <code>module-attribute</code>","text":""},{"location":"reference/action/#action.action_bus","title":"<code>action_bus = EventBus[ActionData]('action')</code>  <code>module-attribute</code>","text":""},{"location":"reference/action/#action.default_action_registry","title":"<code>default_action_registry: dict[str, ActionFn] = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/action/#action.Action","title":"<code>Action</code>","text":"<p>             Bases: <code>Component</code></p> <p>Component for determining which action to take.</p> Source code in <code>roc/action.py</code> <pre><code>@register_component(\"action\", \"action\", auto=True)\nclass Action(Component):\n    \"\"\"Component for determining which action to take.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.action_bus_conn = self.connect_bus(action_bus)\n\n        # XXX: function because you can't type annotate an inline lambda\n        def count_filter(e: ActionEvent) -&gt; bool:\n            return e.data.type == \"action_count\"\n\n        def go_filter(e: ActionEvent) -&gt; bool:\n            return e.data.type == \"action_go\"\n\n        # self.action_bus_conn.subject.pipe(\n        #     op.filter(count_filter),\n        # ).subscribe(self.recv_action_count)\n        self.action_bus_conn.listen(\n            listener=self.recv_action_count,\n            filter=count_filter,\n        )\n        self.action_count: None | int = None\n\n    def recv_action_count(self, e: ActionEvent) -&gt; None:\n        if e.data.type != \"action_count\":\n            raise Exception(\"bad data received in recv_action_count\")\n\n        self.action_count = e.data.action_count\n</code></pre>"},{"location":"reference/action/#action.Action.action_bus_conn","title":"<code>action_bus_conn = self.connect_bus(action_bus)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.Action.action_count","title":"<code>action_count: None | int = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.Action.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/action.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.action_bus_conn = self.connect_bus(action_bus)\n\n    # XXX: function because you can't type annotate an inline lambda\n    def count_filter(e: ActionEvent) -&gt; bool:\n        return e.data.type == \"action_count\"\n\n    def go_filter(e: ActionEvent) -&gt; bool:\n        return e.data.type == \"action_go\"\n\n    # self.action_bus_conn.subject.pipe(\n    #     op.filter(count_filter),\n    # ).subscribe(self.recv_action_count)\n    self.action_bus_conn.listen(\n        listener=self.recv_action_count,\n        filter=count_filter,\n    )\n    self.action_count: None | int = None\n</code></pre>"},{"location":"reference/action/#action.Action.recv_action_count","title":"<code>recv_action_count(e)</code>","text":"Source code in <code>roc/action.py</code> <pre><code>def recv_action_count(self, e: ActionEvent) -&gt; None:\n    if e.data.type != \"action_count\":\n        raise Exception(\"bad data received in recv_action_count\")\n\n    self.action_count = e.data.action_count\n</code></pre>"},{"location":"reference/action/#action.ActionCount","title":"<code>ActionCount</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A Pydantic model for communicating the number of actions that can be taken.</p> Source code in <code>roc/action.py</code> <pre><code>class ActionCount(BaseModel):\n    \"\"\"A Pydantic model for communicating the number of actions that can be\n    taken.\"\"\"\n\n    type: Literal[\"action_count\"] = \"action_count\"\n    action_count: int\n</code></pre>"},{"location":"reference/action/#action.ActionCount.action_count","title":"<code>action_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.ActionCount.type","title":"<code>type: Literal['action_count'] = 'action_count'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.ActionGo","title":"<code>ActionGo</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A Pydantic model for communicating that the Gym is waiting for the agent to take an action.</p> Source code in <code>roc/action.py</code> <pre><code>class ActionGo(BaseModel):\n    \"\"\"A Pydantic model for communicating that the Gym is waiting for the agent\n    to take an action.\"\"\"\n\n    type: Literal[\"action_go\"] = \"action_go\"\n    go: bool\n</code></pre>"},{"location":"reference/action/#action.ActionGo.go","title":"<code>go: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.ActionGo.type","title":"<code>type: Literal['action_go'] = 'action_go'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.register_default_action","title":"<code>register_default_action</code>","text":"<p>Decorator for registering potential default actions. Default actions are set in the configuration.</p> Source code in <code>roc/action.py</code> <pre><code>class register_default_action:\n    \"\"\"Decorator for registering potential default actions. Default actions are\n    set in the configuration.\"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        self.name = name\n\n    def __call__(self, fn: ActionFn) -&gt; ActionFn:\n        if self.name in default_action_registry:\n            raise ValueError(f\"Registering duplicate default action '{self.name}'\")\n\n        default_action_registry[self.name] = fn\n\n        return fn\n</code></pre>"},{"location":"reference/action/#action.register_default_action.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.register_default_action.__call__","title":"<code>__call__(fn)</code>","text":"Source code in <code>roc/action.py</code> <pre><code>def __call__(self, fn: ActionFn) -&gt; ActionFn:\n    if self.name in default_action_registry:\n        raise ValueError(f\"Registering duplicate default action '{self.name}'\")\n\n    default_action_registry[self.name] = fn\n\n    return fn\n</code></pre>"},{"location":"reference/action/#action.register_default_action.__init__","title":"<code>__init__(name)</code>","text":"Source code in <code>roc/action.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    self.name = name\n</code></pre>"},{"location":"reference/action/#action.default_pass","title":"<code>default_pass()</code>","text":"<p>Default action for Nethack that passes (the <code>.</code> character in the game)</p> Source code in <code>roc/action.py</code> <pre><code>@register_default_action(\"pass\")\ndef default_pass() -&gt; int:\n    \"\"\"Default action for Nethack that passes (the `.` character in the game)\"\"\"\n\n    return 19\n</code></pre>"},{"location":"reference/action/#action.default_random","title":"<code>default_random()</code>","text":"<p>A default action for taking random Nethack actions.</p> Source code in <code>roc/action.py</code> <pre><code>@register_default_action(\"random\")\ndef default_random() -&gt; int:\n    \"\"\"A default action for taking random Nethack actions.\"\"\"\n\n    c = Action.get(\"action\", \"action\")\n    if c.action_count is None:\n        raise ValueError(\"Trying to get action before actions have been configured\")\n\n    return randrange(c.action_count)\n</code></pre>"},{"location":"reference/component/","title":"component","text":"<p>This module defines the Component base class, which is instantiated for nearly every part of the system. It implements interfaces for communications, initialization, shutdown, etc.</p>"},{"location":"reference/component/#component.T","title":"<code>T = TypeVar('T')</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.WrappedComponentBase","title":"<code>WrappedComponentBase = TypeVar('WrappedComponentBase', bound=Component)</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.component_count","title":"<code>component_count = 0</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.component_registry","title":"<code>component_registry: dict[str, type[Component]] = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.default_components","title":"<code>default_components: set[str] = set()</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.loaded_components","title":"<code>loaded_components: dict[str, Component] = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.Component","title":"<code>Component</code>","text":"<p>             Bases: <code>ABC</code></p> <p>An abstract component class for building pieces of ROC that will talk to each other.</p> Source code in <code>roc/component.py</code> <pre><code>class Component(ABC):\n    \"\"\"An abstract component class for building pieces of ROC that will talk to each other.\"\"\"\n\n    name: str = \"&lt;name unassigned&gt;\"\n    type: str = \"&lt;type unassigned&gt;\"\n\n    def __init__(self) -&gt; None:\n        global component_count\n        component_count = component_count + 1\n        self.bus_conns: dict[str, BusConnection[Any]] = {}\n        # print(\"\\n\\n++ incrementing component count:\", self.name, self.type, self)\n        # traceback.print_stack()\n\n    def __del__(self) -&gt; None:\n        global component_count\n        component_count = component_count - 1\n        # print(\"\\n\\n-- decrementing component count\", self.name, self.type, self)\n\n    def connect_bus(self, bus: EventBus[T]) -&gt; BusConnection[T]:\n        \"\"\"Create a new bus connection for the component, storing the result for\n        later shutdown.\n\n        Args:\n            bus (EventBus[T]): The event bus to attach to\n\n        Raises:\n            ValueError: if the bus has already been connected to by this component\n\n        Returns:\n            BusConnection[T]: The bus connection for listening or sending events\n        \"\"\"\n        if bus.name in self.bus_conns:\n            raise ValueError(\n                f\"Component '{self.name}' attempting duplicate connection to bus '{bus.name}'\"\n            )\n\n        conn = bus.connect(self)\n        self.bus_conns[bus.name] = conn\n        return conn\n\n    def event_filter(self, e: Event[Any]) -&gt; bool:\n        \"\"\"A filter for any incoming events. By default it filters out events\n        sent by itself, but it is especially useful for creating new filters in\n        sub-classes.\n\n        Args:\n            e (Event[Any]): The event to be evaluated\n\n        Returns:\n            bool: True if the event should be sent, False if it should be dropped\n        \"\"\"\n        return e.src is not self\n\n    def shutdown(self) -&gt; None:\n        \"\"\"De-initializes the component, removing any bus connections and any\n        other clean-up that needs to be performed\"\"\"\n\n        for conn in self.bus_conns:\n            for obs in self.bus_conns[conn].attached_bus.subject.observers:\n                obs.on_completed()\n\n    @staticmethod\n    def init() -&gt; None:\n        \"\"\"Loads all components registered as `auto` and perception components\n        in the `perception_components` config field.\"\"\"\n\n        settings = Config.get()\n        component_list = default_components\n        component_list = component_list.union(settings.perception_components)\n\n        # TODO: shutdown previously loaded components\n\n        for reg_str in component_list:\n            logger.trace(f\"Loading component: {reg_str} ...\")\n            (name, type) = reg_str.split(\":\")\n            loaded_components[reg_str] = Component.get(name, type)\n\n    @classmethod\n    def get(cls, name: str, type: str, *args: Any, **kwargs: Any) -&gt; Self:\n        \"\"\"Retreives a component with the specified name from the registry and\n        creates a new version of it with the specified args. Used by\n        `Config.init` and for testing.\n\n        Args:\n            name (str): The name of the component to get, as specified during\n                its registration\n            type (str): The type of the component to get, as specified during\n                its registration\n            args (Any): Fixed position arguments to pass to the Component\n                constructor\n            kwargs (Any): Keyword args to pass to the Component constructor\n\n        Returns:\n            Self: the component that was created, casted as the calling class.\n            (e.g. `Perception.get(...)` will return a Perception component and\n            `Action.get(...)` will return an Action component)\n        \"\"\"\n\n        reg_str = _component_registry_key(name, type)\n        return cast(Self, component_registry[reg_str](*args, **kwargs))\n\n    @staticmethod\n    def get_component_count() -&gt; int:\n        \"\"\"Returns the number of currently created Components. The number goes\n        up on __init__ and down on __del__. Primarily used for testing to ensure\n        Components are being shutdown appropriately.\n\n        Returns:\n            int: The number of currently active Component instances\n        \"\"\"\n        global component_count\n        return component_count\n\n    @staticmethod\n    def deregister(name: str, type: str) -&gt; None:\n        \"\"\"Removes a component from the Component registry. Primarlly used for testing.\n\n        Args:\n            name (str): The name of the Component to deregister\n            type (str): The type of the Component to deregister\n        \"\"\"\n        reg_str = _component_registry_key(name, type)\n        del component_registry[reg_str]\n\n    @staticmethod\n    def reset() -&gt; None:\n        \"\"\"Shuts down all components\"\"\"\n        # shutdown all components\n        global loaded_components\n        for name in loaded_components:\n            logger.trace(f\"Shutting down component: {name}.\")\n            c = loaded_components[name]\n            c.shutdown()\n\n        loaded_components.clear()\n</code></pre>"},{"location":"reference/component/#component.Component.bus_conns","title":"<code>bus_conns: dict[str, BusConnection[Any]] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.Component.name","title":"<code>name: str = '&lt;name unassigned&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.Component.type","title":"<code>type: str = '&lt;type unassigned&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.Component.__del__","title":"<code>__del__()</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __del__(self) -&gt; None:\n    global component_count\n    component_count = component_count - 1\n</code></pre>"},{"location":"reference/component/#component.Component.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __init__(self) -&gt; None:\n    global component_count\n    component_count = component_count + 1\n    self.bus_conns: dict[str, BusConnection[Any]] = {}\n</code></pre>"},{"location":"reference/component/#component.Component.connect_bus","title":"<code>connect_bus(bus)</code>","text":"<p>Create a new bus connection for the component, storing the result for later shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>EventBus[T]</code> <p>The event bus to attach to</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the bus has already been connected to by this component</p> <p>Returns:</p> Type Description <code>BusConnection[T]</code> <p>BusConnection[T]: The bus connection for listening or sending events</p> Source code in <code>roc/component.py</code> <pre><code>def connect_bus(self, bus: EventBus[T]) -&gt; BusConnection[T]:\n    \"\"\"Create a new bus connection for the component, storing the result for\n    later shutdown.\n\n    Args:\n        bus (EventBus[T]): The event bus to attach to\n\n    Raises:\n        ValueError: if the bus has already been connected to by this component\n\n    Returns:\n        BusConnection[T]: The bus connection for listening or sending events\n    \"\"\"\n    if bus.name in self.bus_conns:\n        raise ValueError(\n            f\"Component '{self.name}' attempting duplicate connection to bus '{bus.name}'\"\n        )\n\n    conn = bus.connect(self)\n    self.bus_conns[bus.name] = conn\n    return conn\n</code></pre>"},{"location":"reference/component/#component.Component.deregister","title":"<code>deregister(name, type)</code>  <code>staticmethod</code>","text":"<p>Removes a component from the Component registry. Primarlly used for testing.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the Component to deregister</p> required <code>type</code> <code>str</code> <p>The type of the Component to deregister</p> required Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef deregister(name: str, type: str) -&gt; None:\n    \"\"\"Removes a component from the Component registry. Primarlly used for testing.\n\n    Args:\n        name (str): The name of the Component to deregister\n        type (str): The type of the Component to deregister\n    \"\"\"\n    reg_str = _component_registry_key(name, type)\n    del component_registry[reg_str]\n</code></pre>"},{"location":"reference/component/#component.Component.event_filter","title":"<code>event_filter(e)</code>","text":"<p>A filter for any incoming events. By default it filters out events sent by itself, but it is especially useful for creating new filters in sub-classes.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Event[Any]</code> <p>The event to be evaluated</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the event should be sent, False if it should be dropped</p> Source code in <code>roc/component.py</code> <pre><code>def event_filter(self, e: Event[Any]) -&gt; bool:\n    \"\"\"A filter for any incoming events. By default it filters out events\n    sent by itself, but it is especially useful for creating new filters in\n    sub-classes.\n\n    Args:\n        e (Event[Any]): The event to be evaluated\n\n    Returns:\n        bool: True if the event should be sent, False if it should be dropped\n    \"\"\"\n    return e.src is not self\n</code></pre>"},{"location":"reference/component/#component.Component.get","title":"<code>get(name, type, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Retreives a component with the specified name from the registry and creates a new version of it with the specified args. Used by <code>Config.init</code> and for testing.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the component to get, as specified during its registration</p> required <code>type</code> <code>str</code> <p>The type of the component to get, as specified during its registration</p> required <code>args</code> <code>Any</code> <p>Fixed position arguments to pass to the Component constructor</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>Keyword args to pass to the Component constructor</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the component that was created, casted as the calling class.</p> <code>Self</code> <p>(e.g. <code>Perception.get(...)</code> will return a Perception component and</p> <code>Self</code> <p><code>Action.get(...)</code> will return an Action component)</p> Source code in <code>roc/component.py</code> <pre><code>@classmethod\ndef get(cls, name: str, type: str, *args: Any, **kwargs: Any) -&gt; Self:\n    \"\"\"Retreives a component with the specified name from the registry and\n    creates a new version of it with the specified args. Used by\n    `Config.init` and for testing.\n\n    Args:\n        name (str): The name of the component to get, as specified during\n            its registration\n        type (str): The type of the component to get, as specified during\n            its registration\n        args (Any): Fixed position arguments to pass to the Component\n            constructor\n        kwargs (Any): Keyword args to pass to the Component constructor\n\n    Returns:\n        Self: the component that was created, casted as the calling class.\n        (e.g. `Perception.get(...)` will return a Perception component and\n        `Action.get(...)` will return an Action component)\n    \"\"\"\n\n    reg_str = _component_registry_key(name, type)\n    return cast(Self, component_registry[reg_str](*args, **kwargs))\n</code></pre>"},{"location":"reference/component/#component.Component.get_component_count","title":"<code>get_component_count()</code>  <code>staticmethod</code>","text":"<p>Returns the number of currently created Components. The number goes up on init and down on del. Primarily used for testing to ensure Components are being shutdown appropriately.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of currently active Component instances</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef get_component_count() -&gt; int:\n    \"\"\"Returns the number of currently created Components. The number goes\n    up on __init__ and down on __del__. Primarily used for testing to ensure\n    Components are being shutdown appropriately.\n\n    Returns:\n        int: The number of currently active Component instances\n    \"\"\"\n    global component_count\n    return component_count\n</code></pre>"},{"location":"reference/component/#component.Component.init","title":"<code>init()</code>  <code>staticmethod</code>","text":"<p>Loads all components registered as <code>auto</code> and perception components in the <code>perception_components</code> config field.</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef init() -&gt; None:\n    \"\"\"Loads all components registered as `auto` and perception components\n    in the `perception_components` config field.\"\"\"\n\n    settings = Config.get()\n    component_list = default_components\n    component_list = component_list.union(settings.perception_components)\n\n    # TODO: shutdown previously loaded components\n\n    for reg_str in component_list:\n        logger.trace(f\"Loading component: {reg_str} ...\")\n        (name, type) = reg_str.split(\":\")\n        loaded_components[reg_str] = Component.get(name, type)\n</code></pre>"},{"location":"reference/component/#component.Component.reset","title":"<code>reset()</code>  <code>staticmethod</code>","text":"<p>Shuts down all components</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef reset() -&gt; None:\n    \"\"\"Shuts down all components\"\"\"\n    # shutdown all components\n    global loaded_components\n    for name in loaded_components:\n        logger.trace(f\"Shutting down component: {name}.\")\n        c = loaded_components[name]\n        c.shutdown()\n\n    loaded_components.clear()\n</code></pre>"},{"location":"reference/component/#component.Component.shutdown","title":"<code>shutdown()</code>","text":"<p>De-initializes the component, removing any bus connections and any other clean-up that needs to be performed</p> Source code in <code>roc/component.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"De-initializes the component, removing any bus connections and any\n    other clean-up that needs to be performed\"\"\"\n\n    for conn in self.bus_conns:\n        for obs in self.bus_conns[conn].attached_bus.subject.observers:\n            obs.on_completed()\n</code></pre>"},{"location":"reference/component/#component.register_component","title":"<code>register_component</code>","text":"Source code in <code>roc/component.py</code> <pre><code>class register_component:\n    def __init__(self, name: str, type: str, *, auto: bool = False) -&gt; None:\n        self.name = name\n        self.type = type\n        self.auto = auto\n\n    def __call__(self, cls: type[Component]) -&gt; type[Component]:\n        global register_component\n        global component_registry\n\n        reg_str = _component_registry_key(self.name, self.type)\n        if reg_str in component_registry:\n            raise ValueError(f\"Registering duplicate component name: '{self.name}'\")\n\n        if self.auto:\n            global default_components\n            default_components.add(reg_str)\n\n        component_registry[reg_str] = cls\n        cls.name = self.name\n        cls.type = self.type\n\n        return cls\n</code></pre>"},{"location":"reference/component/#component.register_component.auto","title":"<code>auto = auto</code>  <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.register_component.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.register_component.type","title":"<code>type = type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.register_component.__call__","title":"<code>__call__(cls)</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __call__(self, cls: type[Component]) -&gt; type[Component]:\n    global register_component\n    global component_registry\n\n    reg_str = _component_registry_key(self.name, self.type)\n    if reg_str in component_registry:\n        raise ValueError(f\"Registering duplicate component name: '{self.name}'\")\n\n    if self.auto:\n        global default_components\n        default_components.add(reg_str)\n\n    component_registry[reg_str] = cls\n    cls.name = self.name\n    cls.type = self.type\n\n    return cls\n</code></pre>"},{"location":"reference/component/#component.register_component.__init__","title":"<code>__init__(name, type, *, auto=False)</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __init__(self, name: str, type: str, *, auto: bool = False) -&gt; None:\n    self.name = name\n    self.type = type\n    self.auto = auto\n</code></pre>"},{"location":"reference/config/","title":"config","text":"<p>This module contains all the settings for the system.</p>"},{"location":"reference/config/#config.Config","title":"<code>Config</code>","text":"<p>             Bases: <code>BaseSettings</code></p> <p>A Pydantic settings model for configuration of the agent.</p> Source code in <code>roc/config.py</code> <pre><code>class Config(BaseSettings):\n    \"\"\"A Pydantic settings model for configuration of the agent.\"\"\"\n\n    model_config = SettingsConfigDict(\n        env_prefix=\"roc_\",\n        env_file=\".env\",\n        extra=\"forbid\",\n    )\n    db_host: str = Field(default=\"127.0.0.1\")\n    db_port: int = Field(default=7687)\n    db_conn_encrypted: bool = Field(default=False)\n    db_username: str = Field(default=\"\")\n    db_password: str = Field(default=\"\")\n    db_lazy: bool = Field(default=False)\n    node_cache_size: int = Field(default=2**11)\n    edge_cache_size: int = Field(default=2**11)\n    log_enable: bool = Field(default=True)\n    log_level: str = Field(default=\"INFO\")\n    log_modules: str = Field(default=\"\")\n    default_action: str = Field(default=\"pass\")\n    perception_components: list[str] = Field(default=[\"delta:perception\"])\n    enable_gym_dump_env: bool = Field(default=False)\n    max_dump_frames: int = Field(default=10)\n    nethack_spectrum: str = Field(pattern=r\"chars|colors|glyphs\", default=\"chars\")\n\n    @staticmethod\n    def get() -&gt; Config:\n        global _config_singleton\n        if _config_singleton is None:\n            warnings.warn(\n                \"Getting settings before config module was initialized. Please call init() first\",\n                ConfigInitWarning,\n            )\n            Config.init()\n            assert _config_singleton is not None\n        return _config_singleton\n\n    @staticmethod\n    def init(\n        config: dict[str, Any] | None = None,\n        *,\n        force: bool = False,\n        use_secrets: bool = True,\n    ) -&gt; None:\n        \"\"\"Initializes the settings by reading the configuration files and environment variables\"\"\"\n\n        global _config_singleton\n        initialized = _config_singleton is not None\n        if initialized and not force:\n            warnings.warn(\n                \"Config already initialized, returning existing configuration.\",\n                ConfigInitWarning,\n            )\n            return\n\n        passed_conf = config or {}\n        _config_singleton = Config(**passed_conf)\n\n    @staticmethod\n    def reset() -&gt; None:\n        global _config_singleton\n        _config_singleton = None\n</code></pre>"},{"location":"reference/config/#config.Config.db_conn_encrypted","title":"<code>db_conn_encrypted: bool = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_host","title":"<code>db_host: str = Field(default='127.0.0.1')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_lazy","title":"<code>db_lazy: bool = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_password","title":"<code>db_password: str = Field(default='')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_port","title":"<code>db_port: int = Field(default=7687)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_username","title":"<code>db_username: str = Field(default='')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.default_action","title":"<code>default_action: str = Field(default='pass')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.edge_cache_size","title":"<code>edge_cache_size: int = Field(default=2 ** 11)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.enable_gym_dump_env","title":"<code>enable_gym_dump_env: bool = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.log_enable","title":"<code>log_enable: bool = Field(default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.log_level","title":"<code>log_level: str = Field(default='INFO')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.log_modules","title":"<code>log_modules: str = Field(default='')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.max_dump_frames","title":"<code>max_dump_frames: int = Field(default=10)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.model_config","title":"<code>model_config = SettingsConfigDict(env_prefix='roc_', env_file='.env', extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.nethack_spectrum","title":"<code>nethack_spectrum: str = Field(pattern='chars|colors|glyphs', default='chars')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.node_cache_size","title":"<code>node_cache_size: int = Field(default=2 ** 11)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.perception_components","title":"<code>perception_components: list[str] = Field(default=['delta:perception'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.get","title":"<code>get()</code>  <code>staticmethod</code>","text":"Source code in <code>roc/config.py</code> <pre><code>@staticmethod\ndef get() -&gt; Config:\n    global _config_singleton\n    if _config_singleton is None:\n        warnings.warn(\n            \"Getting settings before config module was initialized. Please call init() first\",\n            ConfigInitWarning,\n        )\n        Config.init()\n        assert _config_singleton is not None\n    return _config_singleton\n</code></pre>"},{"location":"reference/config/#config.Config.init","title":"<code>init(config=None, *, force=False, use_secrets=True)</code>  <code>staticmethod</code>","text":"<p>Initializes the settings by reading the configuration files and environment variables</p> Source code in <code>roc/config.py</code> <pre><code>@staticmethod\ndef init(\n    config: dict[str, Any] | None = None,\n    *,\n    force: bool = False,\n    use_secrets: bool = True,\n) -&gt; None:\n    \"\"\"Initializes the settings by reading the configuration files and environment variables\"\"\"\n\n    global _config_singleton\n    initialized = _config_singleton is not None\n    if initialized and not force:\n        warnings.warn(\n            \"Config already initialized, returning existing configuration.\",\n            ConfigInitWarning,\n        )\n        return\n\n    passed_conf = config or {}\n    _config_singleton = Config(**passed_conf)\n</code></pre>"},{"location":"reference/config/#config.Config.reset","title":"<code>reset()</code>  <code>staticmethod</code>","text":"Source code in <code>roc/config.py</code> <pre><code>@staticmethod\ndef reset() -&gt; None:\n    global _config_singleton\n    _config_singleton = None\n</code></pre>"},{"location":"reference/config/#config.ConfigInitWarning","title":"<code>ConfigInitWarning</code>","text":"<p>             Bases: <code>Warning</code></p> <p>A Warning for when attempting to access config before it has been initialized.</p> Source code in <code>roc/config.py</code> <pre><code>class ConfigInitWarning(Warning):\n    \"\"\"A Warning for when attempting to access config before it has been initialized.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/event/","title":"event","text":"<p>This module defines all the communications and eventing interfaces for the system.</p>"},{"location":"reference/event/#event.EventData","title":"<code>EventData = TypeVar('EventData')</code>  <code>module-attribute</code>","text":""},{"location":"reference/event/#event.eventbus_names","title":"<code>eventbus_names: set[str] = set()</code>  <code>module-attribute</code>","text":""},{"location":"reference/event/#event.BusConnection","title":"<code>BusConnection</code>","text":"<p>             Bases: <code>Generic[EventData]</code></p> <p>A connection between an EventBus and a Component, used to send Events</p> <p>Parameters:</p> Name Type Description Default <code>Generic</code> <code>EventData</code> <p>The data type that will be sent over this connection</p> required Source code in <code>roc/event.py</code> <pre><code>class BusConnection(Generic[EventData]):\n    \"\"\"A connection between an EventBus and a Component, used to send Events\n\n    Args:\n        Generic (EventData): The data type that will be sent over this connection\n    \"\"\"\n\n    def __init__(self, bus: EventBus[EventData], component: Component):\n        self.attached_bus = bus\n        self.attached_component = component\n        self.subject: rx.Subject[Event[EventData]] = self.attached_bus.subject\n        self.subscribers: list[Disposable] = []\n\n    def send(self, data: EventData) -&gt; None:\n        \"\"\"Send data over the EventBus. Internally, the data is converted to an Event\n        with the relevant data (such as the source Component).\n\n        Args:\n            data (EventData): The data type of the data to be sent\n        \"\"\"\n        e = Event[EventData](data, self.attached_component, self.attached_bus)\n        logger.trace(f\"&gt;&gt;&gt; Sending {e}\")\n        self.attached_bus.subject.on_next(e)\n\n    def listen(\n        self,\n        listener: Callable[[Event[EventData]], None],\n        *,\n        filter: Callable[[Event[EventData]], bool] | None = None,\n    ) -&gt; None:\n        pipe_args: list[Callable[[Any], Observable[Event[EventData]]]] = [\n            # op.filter(lambda e: e.src is not self.attached_component),\n            op.filter(self.attached_component.event_filter),\n        ]\n        if filter is not None:\n            pipe_args.append(op.filter(filter))\n\n        sub = self.subject.pipe(*pipe_args).subscribe(listener)\n        self.subscribers.append(sub)\n\n    def close(self) -&gt; None:\n        logger.trace(\n            f\"Closing connection {self.attached_component.name} -&gt; {self.attached_bus.name}\"\n        )\n\n        for sub in self.subscribers:\n            sub.dispose()\n</code></pre>"},{"location":"reference/event/#event.BusConnection.attached_bus","title":"<code>attached_bus = bus</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.BusConnection.attached_component","title":"<code>attached_component = component</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.BusConnection.subject","title":"<code>subject: rx.Subject[Event[EventData]] = self.attached_bus.subject</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.BusConnection.subscribers","title":"<code>subscribers: list[Disposable] = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.BusConnection.__init__","title":"<code>__init__(bus, component)</code>","text":"Source code in <code>roc/event.py</code> <pre><code>def __init__(self, bus: EventBus[EventData], component: Component):\n    self.attached_bus = bus\n    self.attached_component = component\n    self.subject: rx.Subject[Event[EventData]] = self.attached_bus.subject\n    self.subscribers: list[Disposable] = []\n</code></pre>"},{"location":"reference/event/#event.BusConnection.close","title":"<code>close()</code>","text":"Source code in <code>roc/event.py</code> <pre><code>def close(self) -&gt; None:\n    logger.trace(\n        f\"Closing connection {self.attached_component.name} -&gt; {self.attached_bus.name}\"\n    )\n\n    for sub in self.subscribers:\n        sub.dispose()\n</code></pre>"},{"location":"reference/event/#event.BusConnection.listen","title":"<code>listen(listener, *, filter=None)</code>","text":"Source code in <code>roc/event.py</code> <pre><code>def listen(\n    self,\n    listener: Callable[[Event[EventData]], None],\n    *,\n    filter: Callable[[Event[EventData]], bool] | None = None,\n) -&gt; None:\n    pipe_args: list[Callable[[Any], Observable[Event[EventData]]]] = [\n        # op.filter(lambda e: e.src is not self.attached_component),\n        op.filter(self.attached_component.event_filter),\n    ]\n    if filter is not None:\n        pipe_args.append(op.filter(filter))\n\n    sub = self.subject.pipe(*pipe_args).subscribe(listener)\n    self.subscribers.append(sub)\n</code></pre>"},{"location":"reference/event/#event.BusConnection.send","title":"<code>send(data)</code>","text":"<p>Send data over the EventBus. Internally, the data is converted to an Event with the relevant data (such as the source Component).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>EventData</code> <p>The data type of the data to be sent</p> required Source code in <code>roc/event.py</code> <pre><code>def send(self, data: EventData) -&gt; None:\n    \"\"\"Send data over the EventBus. Internally, the data is converted to an Event\n    with the relevant data (such as the source Component).\n\n    Args:\n        data (EventData): The data type of the data to be sent\n    \"\"\"\n    e = Event[EventData](data, self.attached_component, self.attached_bus)\n    logger.trace(f\"&gt;&gt;&gt; Sending {e}\")\n    self.attached_bus.subject.on_next(e)\n</code></pre>"},{"location":"reference/event/#event.Event","title":"<code>Event</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[EventData]</code></p> <p>An abstract event class for sending messages between Components over an EventBus</p> <p>Parameters:</p> Name Type Description Default <code>ABC</code> <code>ABC</code> <p>Abstract base class</p> required <code>Generic</code> <code>EventData</code> <p>The data to be carried by the event</p> required Source code in <code>roc/event.py</code> <pre><code>class Event(ABC, Generic[EventData]):\n    \"\"\"An abstract event class for sending messages between Components over an EventBus\n\n    Args:\n        ABC (ABC): Abstract base class\n        Generic (EventData): The data to be carried by the event\n    \"\"\"\n\n    def __init__(self, data: EventData, src: Component, bus: EventBus[EventData]):\n        \"\"\"The initializer for the Event\n\n        Args:\n            data (EventData): The data for this event\n            src (Component): The Component sending the event\n            bus (EventBus): The EventBus that the event is being sent over\n        \"\"\"\n        self.data = data\n        self.src = src\n        self.bus = bus\n\n    def __repr__(self) -&gt; str:\n        data_str = pretty_repr(\n            self.data,\n            # max_depth=4, # Maximum depth of nested data structure\n            max_length=5,  # Maximum length of containers before abbreviating\n            max_string=60,  # Maximum length of string before truncating\n            expand_all=False,  # Expand all containers regardless of available width\n            max_width=120,\n        )\n        if \"\\n\" in data_str:\n            data_str = \"\\n\" + data_str\n        return f\"[EVENT: {self.src.name} &gt;&gt;&gt; {self.bus.name}]: {data_str}\"\n</code></pre>"},{"location":"reference/event/#event.Event.bus","title":"<code>bus = bus</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.Event.data","title":"<code>data = data</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.Event.src","title":"<code>src = src</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.Event.__init__","title":"<code>__init__(data, src, bus)</code>","text":"<p>The initializer for the Event</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>EventData</code> <p>The data for this event</p> required <code>src</code> <code>Component</code> <p>The Component sending the event</p> required <code>bus</code> <code>EventBus</code> <p>The EventBus that the event is being sent over</p> required Source code in <code>roc/event.py</code> <pre><code>def __init__(self, data: EventData, src: Component, bus: EventBus[EventData]):\n    \"\"\"The initializer for the Event\n\n    Args:\n        data (EventData): The data for this event\n        src (Component): The Component sending the event\n        bus (EventBus): The EventBus that the event is being sent over\n    \"\"\"\n    self.data = data\n    self.src = src\n    self.bus = bus\n</code></pre>"},{"location":"reference/event/#event.Event.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>roc/event.py</code> <pre><code>def __repr__(self) -&gt; str:\n    data_str = pretty_repr(\n        self.data,\n        # max_depth=4, # Maximum depth of nested data structure\n        max_length=5,  # Maximum length of containers before abbreviating\n        max_string=60,  # Maximum length of string before truncating\n        expand_all=False,  # Expand all containers regardless of available width\n        max_width=120,\n    )\n    if \"\\n\" in data_str:\n        data_str = \"\\n\" + data_str\n    return f\"[EVENT: {self.src.name} &gt;&gt;&gt; {self.bus.name}]: {data_str}\"\n</code></pre>"},{"location":"reference/event/#event.EventBus","title":"<code>EventBus</code>","text":"<p>             Bases: <code>Generic[EventData]</code></p> <p>A communication channel for sending events between Components</p> <p>Parameters:</p> Name Type Description Default <code>Generic</code> <code>EventData</code> <p>The data type that is allowed to be sent over the bus</p> required Source code in <code>roc/event.py</code> <pre><code>class EventBus(Generic[EventData]):\n    \"\"\"A communication channel for sending events between Components\n\n    Args:\n        Generic (EventData): The data type that is allowed to be sent over the bus\n    \"\"\"\n\n    name: str\n    \"\"\"The name of the bus. Used to ensure uniqueness.\"\"\"\n    subject: rx.Subject[Event[EventData]]\n    \"\"\"The RxPy Subject that the bus uses to communicate.\"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        if name in eventbus_names:\n            raise Exception(f\"Duplicate EventBus name: {name}\")\n        self.name = name\n        eventbus_names.add(name)\n        self.subject = rx.Subject[Event[EventData]]()\n\n    def connect(self, component: Component) -&gt; BusConnection[EventData]:\n        \"\"\"Creates a connection between an EventBus and a Component for sending Events\n\n        Args:\n            component (Component): The Component to connect to the bus\n\n        Returns:\n            BusConnection[EventData]: A new connection that can be used to send data\n        \"\"\"\n        return BusConnection[EventData](self, component)\n\n    @staticmethod\n    def clear_names() -&gt; None:\n        \"\"\"Clears all EventBusses that have been registered, mostly used for testing.\"\"\"\n        eventbus_names.clear()\n</code></pre>"},{"location":"reference/event/#event.EventBus.name","title":"<code>name: str = name</code>  <code>instance-attribute</code>","text":"<p>The name of the bus. Used to ensure uniqueness.</p>"},{"location":"reference/event/#event.EventBus.subject","title":"<code>subject: rx.Subject[Event[EventData]] = rx.Subject[Event[EventData]]()</code>  <code>instance-attribute</code>","text":"<p>The RxPy Subject that the bus uses to communicate.</p>"},{"location":"reference/event/#event.EventBus.__init__","title":"<code>__init__(name)</code>","text":"Source code in <code>roc/event.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    if name in eventbus_names:\n        raise Exception(f\"Duplicate EventBus name: {name}\")\n    self.name = name\n    eventbus_names.add(name)\n    self.subject = rx.Subject[Event[EventData]]()\n</code></pre>"},{"location":"reference/event/#event.EventBus.clear_names","title":"<code>clear_names()</code>  <code>staticmethod</code>","text":"<p>Clears all EventBusses that have been registered, mostly used for testing.</p> Source code in <code>roc/event.py</code> <pre><code>@staticmethod\ndef clear_names() -&gt; None:\n    \"\"\"Clears all EventBusses that have been registered, mostly used for testing.\"\"\"\n    eventbus_names.clear()\n</code></pre>"},{"location":"reference/event/#event.EventBus.connect","title":"<code>connect(component)</code>","text":"<p>Creates a connection between an EventBus and a Component for sending Events</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>Component</code> <p>The Component to connect to the bus</p> required <p>Returns:</p> Type Description <code>BusConnection[EventData]</code> <p>BusConnection[EventData]: A new connection that can be used to send data</p> Source code in <code>roc/event.py</code> <pre><code>def connect(self, component: Component) -&gt; BusConnection[EventData]:\n    \"\"\"Creates a connection between an EventBus and a Component for sending Events\n\n    Args:\n        component (Component): The Component to connect to the bus\n\n    Returns:\n        BusConnection[EventData]: A new connection that can be used to send data\n    \"\"\"\n    return BusConnection[EventData](self, component)\n</code></pre>"},{"location":"reference/graphdb/","title":"graphdb","text":"<p>This module is a wrapper around a graph database and abstracts away all the database-specific features as various classes (GraphDB, Node, Edge, etc)</p>"},{"location":"reference/graphdb/#graphdb.CacheDefault","title":"<code>CacheDefault = TypeVar('CacheDefault')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.CacheId","title":"<code>CacheId = TypeVar('CacheId')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.CacheKey","title":"<code>CacheKey = TypeVar('CacheKey')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.CacheType","title":"<code>CacheType = TypeVar('CacheType')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.CacheValue","title":"<code>CacheValue = TypeVar('CacheValue')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeCache","title":"<code>EdgeCache = GraphCache[EdgeId, Edge]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeId","title":"<code>EdgeId = NewType('EdgeId', int)</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.NodeCache","title":"<code>NodeCache = GraphCache[NodeId, Node]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.NodeId","title":"<code>NodeId = NewType('NodeId', int)</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.RecordFn","title":"<code>RecordFn = Callable[[str, Iterator[Any]], None]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.edge_cache","title":"<code>edge_cache: EdgeCache | None = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.graph_db_singleton","title":"<code>graph_db_singleton: GraphDB | None = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.next_new_edge","title":"<code>next_new_edge: EdgeId = cast(EdgeId, -1)</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.next_new_node","title":"<code>next_new_node: NodeId = cast(NodeId, -1)</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.node_cache","title":"<code>node_cache: NodeCache | None = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge","title":"<code>Edge</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An edge (a.k.a. Relationship or Connection) between two Nodes. An edge obect automatically implements all phases of CRUD in the underlying graph database. This is a directional relationship with a \"source\" and \"destination\". The source and destination properties are dynamically loaded through property getters when they are called, and may trigger a graph database query if they don't already exist in the edge cache.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class Edge(BaseModel, extra=\"allow\"):\n    \"\"\"\n    An edge (a.k.a. Relationship or Connection) between two Nodes. An edge obect automatically\n    implements all phases of CRUD in the underlying graph database. This is a directional\n    relationship with a \"source\" and \"destination\". The source and destination properties\n    are dynamically loaded through property getters when they are called, and may trigger\n    a graph database query if they don't already exist in the edge cache.\n    \"\"\"\n\n    id: EdgeId = Field(exclude=True)\n    # XXX: type, src_id, and dst_id used to be pydantic literals, but updating\n    # the pydantic version broke them\n    type: str = Field(exclude=True)\n    src_id: NodeId = Field(exclude=True)\n    dst_id: NodeId = Field(exclude=True)\n\n    @field_validator(\"id\", mode=\"before\")\n    def default_id(cls, id: EdgeId | None) -&gt; EdgeId:\n        if isinstance(id, int):\n            return id\n\n        return get_next_new_edge_id()\n\n    @property\n    def src(self) -&gt; Node:\n        return Node.get(self.src_id)\n\n    @property\n    def dst(self) -&gt; Node:\n        return Node.get(self.dst_id)\n\n    @property\n    def new(self) -&gt; bool:\n        return self._new\n\n    def __init__(\n        self,\n        src_id: NodeId,\n        dst_id: NodeId,\n        type: str,\n        *,\n        id: EdgeId | None = None,\n        data: dict[Any, Any] | None = None,\n    ):\n        data = data or {}\n        super().__init__(\n            src_id=src_id,\n            dst_id=dst_id,\n            type=type,\n            id=id,\n            **data,\n        )\n\n        self._new = False\n        self._no_save = False\n        self._deleted = False\n\n        if self.id &lt; 0:\n            self._new = True\n            Edge.get_cache()[self.id] = self\n\n    def __del__(self) -&gt; None:\n        Edge.save(self)\n\n    @classmethod\n    def get_cache(self) -&gt; EdgeCache:\n        global edge_cache\n        if edge_cache is None:\n            settings = Config.get()\n            edge_cache = EdgeCache(maxsize=settings.edge_cache_size)\n\n        return edge_cache\n\n    @classmethod\n    def get(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Looks up an Edge based on it's ID. If the Edge is cached, the cached edge is returned;\n        otherwise the Edge is queried from the graph database based the ID provided and a new\n        Edge is returned and cached.\n\n        Args:\n            id (EdgeId): the unique identifier for the Edge\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: returns the Edge requested by the id\n        \"\"\"\n        cache = Edge.get_cache()\n        e = cache.get(id)\n        if not e:\n            e = cls.load(id, db=db)\n            cache[id] = e\n\n        return cast(Self, e)\n\n    @classmethod\n    def load(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Loads an Edge from the graph database without attempting to check if the Edge\n        already exists in the cache. Typically this is only called by Edge.get()\n\n        Args:\n            id (EdgeId): the unique identifier of the Edge to fetch\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            EdgeNotFound: if the specified ID does not exist in the cache or the database\n\n        Returns:\n            Self: returns the Edge requested by the id\n        \"\"\"\n        db = db or GraphDB.singleton()\n        edge_list = list(db.raw_fetch(f\"MATCH (n)-[e]-(m) WHERE id(e) = {id} RETURN e LIMIT 1\"))\n        if not len(edge_list) == 1:\n            raise EdgeNotFound(f\"Couldn't find edge ID: {id}\")\n\n        e = edge_list[0][\"e\"]\n        props = None\n        if hasattr(e, \"properties\"):\n            props = e.properties\n        return cls(\n            e.start_id,\n            e.end_id,\n            id=id,\n            data=props,\n            type=e.type,\n        )\n\n    @classmethod\n    def save(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Saves the edge to the database. Calls Edge.create if the edge is new, or Edge.update if\n        edge already exists in the database.\n\n        Args:\n            e (Self): The edge to save\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: The same edge that was passed in, for convenience. The Edge may be updated with a\n            new identifier if it was newly created in the database.\n        \"\"\"\n        if e._new:\n            return cls.create(e, db=db)\n        else:\n            return cls.update(e, db=db)\n\n    @classmethod\n    def create(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Creates a new edge in the database. Typically only called by Edge.save\n\n        Args:\n            e (Self): The edge to create\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            EdgeCreateFailed: Failed to write the edge to the database, for eample\n                if the ID is wrong.\n\n        Returns:\n            Self: the edge that was created, with an updated identifier and other chagned attributes\n        \"\"\"\n        if e._no_save:\n            return e\n\n        db = db or GraphDB.singleton()\n        old_id = e.id\n\n        if e.src._new:\n            Node.save(e.src)\n\n        if e.dst._new:\n            Node.save(e.dst)\n\n        params = {\"props\": e.model_dump()}\n\n        ret = list(\n            db.raw_fetch(\n                f\"\"\"\n                MATCH (src), (dst)\n                WHERE id(src) = {e.src_id} AND id(dst) = {e.dst_id} \n                CREATE (src)-[e:{e.type} $props]-&gt;(dst)\n                RETURN id(e) as e_id\n                \"\"\",\n                params=params,\n            )\n        )\n\n        if len(ret) != 1:\n            raise EdgeCreateFailed(\"failed to create new edge\")\n\n        e.id = ret[0][\"e_id\"]\n        e._new = False\n        # update the cache; if being called during __del__ then the cache entry may not exist\n        try:\n            cache = Edge.get_cache()\n            del cache[old_id]\n            cache[e.id] = e\n        except KeyError:\n            pass\n        # update references to edge id\n        e.src.src_edges.replace(old_id, e.id)\n        e.dst.dst_edges.replace(old_id, e.id)\n\n        return e\n\n    @classmethod\n    def update(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Updates the edge in the database. Typically only called by Edge.save\n\n        Args:\n            e (Self): The edge to update\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: The same edge that was passed in, for convenience\n        \"\"\"\n        if e._no_save:\n            return e\n\n        db = db or GraphDB.singleton()\n\n        params = {\"props\": e.model_dump()}\n\n        db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} SET e = $props\", params=params)\n\n        return e\n\n    @staticmethod\n    def delete(e: Edge, *, db: GraphDB | None = None) -&gt; None:\n        \"\"\"Deletes the specified edge from the database. If the edge has not already been persisted\n        to the database, this marks the edge as deleted and returns.\n\n        Args:\n            e (Edge): The edge to delete\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n        \"\"\"\n        e._deleted = True\n        e._no_save = True\n        db = db or GraphDB.singleton()\n\n        # remove e from src and dst nodes\n        e.src.src_edges.discard(e)\n        e.dst.dst_edges.discard(e)\n\n        # remove from cache\n        edge_cache = Edge.get_cache()\n        if e.id in edge_cache:\n            del edge_cache[e.id]\n\n        # delete from db\n        if not e._new:\n            db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} DELETE e\")\n\n    @staticmethod\n    def to_id(e: Edge | EdgeId) -&gt; EdgeId:\n        if isinstance(e, Edge):\n            return e.id\n        else:\n            return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.dst","title":"<code>dst: Node</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.dst_id","title":"<code>dst_id: NodeId = Field(exclude=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.id","title":"<code>id: EdgeId = Field(exclude=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.new","title":"<code>new: bool</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.src","title":"<code>src: Node</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.src_id","title":"<code>src_id: NodeId = Field(exclude=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.type","title":"<code>type: str = Field(exclude=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.__del__","title":"<code>__del__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __del__(self) -&gt; None:\n    Edge.save(self)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.__init__","title":"<code>__init__(src_id, dst_id, type, *, id=None, data=None)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(\n    self,\n    src_id: NodeId,\n    dst_id: NodeId,\n    type: str,\n    *,\n    id: EdgeId | None = None,\n    data: dict[Any, Any] | None = None,\n):\n    data = data or {}\n    super().__init__(\n        src_id=src_id,\n        dst_id=dst_id,\n        type=type,\n        id=id,\n        **data,\n    )\n\n    self._new = False\n    self._no_save = False\n    self._deleted = False\n\n    if self.id &lt; 0:\n        self._new = True\n        Edge.get_cache()[self.id] = self\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.create","title":"<code>create(e, *, db=None)</code>  <code>classmethod</code>","text":"<p>Creates a new edge in the database. Typically only called by Edge.save</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Self</code> <p>The edge to create</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>EdgeCreateFailed</code> <p>Failed to write the edge to the database, for eample if the ID is wrong.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the edge that was created, with an updated identifier and other chagned attributes</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef create(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Creates a new edge in the database. Typically only called by Edge.save\n\n    Args:\n        e (Self): The edge to create\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        EdgeCreateFailed: Failed to write the edge to the database, for eample\n            if the ID is wrong.\n\n    Returns:\n        Self: the edge that was created, with an updated identifier and other chagned attributes\n    \"\"\"\n    if e._no_save:\n        return e\n\n    db = db or GraphDB.singleton()\n    old_id = e.id\n\n    if e.src._new:\n        Node.save(e.src)\n\n    if e.dst._new:\n        Node.save(e.dst)\n\n    params = {\"props\": e.model_dump()}\n\n    ret = list(\n        db.raw_fetch(\n            f\"\"\"\n            MATCH (src), (dst)\n            WHERE id(src) = {e.src_id} AND id(dst) = {e.dst_id} \n            CREATE (src)-[e:{e.type} $props]-&gt;(dst)\n            RETURN id(e) as e_id\n            \"\"\",\n            params=params,\n        )\n    )\n\n    if len(ret) != 1:\n        raise EdgeCreateFailed(\"failed to create new edge\")\n\n    e.id = ret[0][\"e_id\"]\n    e._new = False\n    # update the cache; if being called during __del__ then the cache entry may not exist\n    try:\n        cache = Edge.get_cache()\n        del cache[old_id]\n        cache[e.id] = e\n    except KeyError:\n        pass\n    # update references to edge id\n    e.src.src_edges.replace(old_id, e.id)\n    e.dst.dst_edges.replace(old_id, e.id)\n\n    return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.default_id","title":"<code>default_id(id)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@field_validator(\"id\", mode=\"before\")\ndef default_id(cls, id: EdgeId | None) -&gt; EdgeId:\n    if isinstance(id, int):\n        return id\n\n    return get_next_new_edge_id()\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.delete","title":"<code>delete(e, *, db=None)</code>  <code>staticmethod</code>","text":"<p>Deletes the specified edge from the database. If the edge has not already been persisted to the database, this marks the edge as deleted and returns.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Edge</code> <p>The edge to delete</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef delete(e: Edge, *, db: GraphDB | None = None) -&gt; None:\n    \"\"\"Deletes the specified edge from the database. If the edge has not already been persisted\n    to the database, this marks the edge as deleted and returns.\n\n    Args:\n        e (Edge): The edge to delete\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n    \"\"\"\n    e._deleted = True\n    e._no_save = True\n    db = db or GraphDB.singleton()\n\n    # remove e from src and dst nodes\n    e.src.src_edges.discard(e)\n    e.dst.dst_edges.discard(e)\n\n    # remove from cache\n    edge_cache = Edge.get_cache()\n    if e.id in edge_cache:\n        del edge_cache[e.id]\n\n    # delete from db\n    if not e._new:\n        db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} DELETE e\")\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.get","title":"<code>get(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Looks up an Edge based on it's ID. If the Edge is cached, the cached edge is returned; otherwise the Edge is queried from the graph database based the ID provided and a new Edge is returned and cached.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>EdgeId</code> <p>the unique identifier for the Edge</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>returns the Edge requested by the id</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Looks up an Edge based on it's ID. If the Edge is cached, the cached edge is returned;\n    otherwise the Edge is queried from the graph database based the ID provided and a new\n    Edge is returned and cached.\n\n    Args:\n        id (EdgeId): the unique identifier for the Edge\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: returns the Edge requested by the id\n    \"\"\"\n    cache = Edge.get_cache()\n    e = cache.get(id)\n    if not e:\n        e = cls.load(id, db=db)\n        cache[id] = e\n\n    return cast(Self, e)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.get_cache","title":"<code>get_cache()</code>  <code>classmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get_cache(self) -&gt; EdgeCache:\n    global edge_cache\n    if edge_cache is None:\n        settings = Config.get()\n        edge_cache = EdgeCache(maxsize=settings.edge_cache_size)\n\n    return edge_cache\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.load","title":"<code>load(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Loads an Edge from the graph database without attempting to check if the Edge already exists in the cache. Typically this is only called by Edge.get()</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>EdgeId</code> <p>the unique identifier of the Edge to fetch</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>EdgeNotFound</code> <p>if the specified ID does not exist in the cache or the database</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>returns the Edge requested by the id</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef load(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Loads an Edge from the graph database without attempting to check if the Edge\n    already exists in the cache. Typically this is only called by Edge.get()\n\n    Args:\n        id (EdgeId): the unique identifier of the Edge to fetch\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        EdgeNotFound: if the specified ID does not exist in the cache or the database\n\n    Returns:\n        Self: returns the Edge requested by the id\n    \"\"\"\n    db = db or GraphDB.singleton()\n    edge_list = list(db.raw_fetch(f\"MATCH (n)-[e]-(m) WHERE id(e) = {id} RETURN e LIMIT 1\"))\n    if not len(edge_list) == 1:\n        raise EdgeNotFound(f\"Couldn't find edge ID: {id}\")\n\n    e = edge_list[0][\"e\"]\n    props = None\n    if hasattr(e, \"properties\"):\n        props = e.properties\n    return cls(\n        e.start_id,\n        e.end_id,\n        id=id,\n        data=props,\n        type=e.type,\n    )\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.save","title":"<code>save(e, *, db=None)</code>  <code>classmethod</code>","text":"<p>Saves the edge to the database. Calls Edge.create if the edge is new, or Edge.update if edge already exists in the database.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Self</code> <p>The edge to save</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The same edge that was passed in, for convenience. The Edge may be updated with a</p> <code>Self</code> <p>new identifier if it was newly created in the database.</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef save(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Saves the edge to the database. Calls Edge.create if the edge is new, or Edge.update if\n    edge already exists in the database.\n\n    Args:\n        e (Self): The edge to save\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: The same edge that was passed in, for convenience. The Edge may be updated with a\n        new identifier if it was newly created in the database.\n    \"\"\"\n    if e._new:\n        return cls.create(e, db=db)\n    else:\n        return cls.update(e, db=db)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.to_id","title":"<code>to_id(e)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef to_id(e: Edge | EdgeId) -&gt; EdgeId:\n    if isinstance(e, Edge):\n        return e.id\n    else:\n        return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.update","title":"<code>update(e, *, db=None)</code>  <code>classmethod</code>","text":"<p>Updates the edge in the database. Typically only called by Edge.save</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Self</code> <p>The edge to update</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The same edge that was passed in, for convenience</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef update(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Updates the edge in the database. Typically only called by Edge.save\n\n    Args:\n        e (Self): The edge to update\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: The same edge that was passed in, for convenience\n    \"\"\"\n    if e._no_save:\n        return e\n\n    db = db or GraphDB.singleton()\n\n    params = {\"props\": e.model_dump()}\n\n    db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} SET e = $props\", params=params)\n\n    return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeCreateFailed","title":"<code>EdgeCreateFailed</code>","text":"<p>             Bases: <code>Exception</code></p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeCreateFailed(Exception):\n    pass\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator","title":"<code>EdgeFetchIterator</code>","text":"<p>The implementation of an iterator for an EdgeList. Only intended to be used internally by EdgeList.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeFetchIterator:\n    \"\"\"\n    The implementation of an iterator for an EdgeList. Only intended to be used internally by\n    EdgeList.\n    \"\"\"\n\n    def __init__(self, edge_list: list[EdgeId]):\n        self.__edge_list = edge_list\n        self.cur = 0\n\n    def __iter__(self) -&gt; EdgeFetchIterator:\n        return self\n\n    def __next__(self) -&gt; Edge:\n        if self.cur &gt;= len(self.__edge_list):\n            raise StopIteration\n\n        id = self.__edge_list[self.cur]\n        self.cur = self.cur + 1\n        return Edge.get(id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator.__edge_list","title":"<code>__edge_list = edge_list</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator.cur","title":"<code>cur = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator.__init__","title":"<code>__init__(edge_list)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, edge_list: list[EdgeId]):\n    self.__edge_list = edge_list\n    self.cur = 0\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __iter__(self) -&gt; EdgeFetchIterator:\n    return self\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator.__next__","title":"<code>__next__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __next__(self) -&gt; Edge:\n    if self.cur &gt;= len(self.__edge_list):\n        raise StopIteration\n\n    id = self.__edge_list[self.cur]\n    self.cur = self.cur + 1\n    return Edge.get(id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList","title":"<code>EdgeList</code>","text":"<p>             Bases: <code>MutableSet[Edge | EdgeId]</code>, <code>Mapping[int, Edge]</code></p> <p>A list of Edges that is used by Node for keeping track of the connections it has. Implements interfaces for both a MutableSet (i.e. set()) and a Mapping (i.e. read-only list())</p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeList(MutableSet[Edge | EdgeId], Mapping[int, Edge]):\n    \"\"\"\n    A list of Edges that is used by Node for keeping track of the connections it has.\n    Implements interfaces for both a MutableSet (i.e. set()) and a Mapping (i.e. read-only list())\n    \"\"\"\n\n    def __init__(self, ids: list[EdgeId] | set[EdgeId]):\n        self.__edges: list[EdgeId] = list(ids)\n\n    def __iter__(self) -&gt; EdgeFetchIterator:\n        return EdgeFetchIterator(self.__edges)\n\n    def __getitem__(self, key: int) -&gt; Edge:\n        return Edge.get(self.__edges[key])\n\n    def __len__(self) -&gt; int:\n        return len(self.__edges)\n\n    def __contains__(self, e: Any) -&gt; bool:\n        if isinstance(e, Edge) or isinstance(e, int):\n            e_id = Edge.to_id(e)  # type: ignore\n        else:\n            return False\n\n        return e_id in self.__edges\n\n    def add(self, e: Edge | EdgeId) -&gt; None:\n        e_id = Edge.to_id(e)\n\n        if e_id in self.__edges:\n            return\n\n        self.__edges.append(e_id)\n\n    def discard(self, e: Edge | EdgeId) -&gt; None:\n        e_id = Edge.to_id(e)\n\n        self.__edges.remove(e_id)\n\n    def replace(self, old: Edge | EdgeId, new: Edge | EdgeId) -&gt; None:\n        old_id = Edge.to_id(old)\n        new_id = Edge.to_id(new)\n        for i in range(len(self.__edges)):\n            if self.__edges[i] == old_id:\n                self.__edges[i] = new_id\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__edges","title":"<code>__edges: list[EdgeId] = list(ids)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeList.__contains__","title":"<code>__contains__(e)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __contains__(self, e: Any) -&gt; bool:\n    if isinstance(e, Edge) or isinstance(e, int):\n        e_id = Edge.to_id(e)  # type: ignore\n    else:\n        return False\n\n    return e_id in self.__edges\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__getitem__","title":"<code>__getitem__(key)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __getitem__(self, key: int) -&gt; Edge:\n    return Edge.get(self.__edges[key])\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__init__","title":"<code>__init__(ids)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, ids: list[EdgeId] | set[EdgeId]):\n    self.__edges: list[EdgeId] = list(ids)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __iter__(self) -&gt; EdgeFetchIterator:\n    return EdgeFetchIterator(self.__edges)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__len__","title":"<code>__len__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.__edges)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.add","title":"<code>add(e)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def add(self, e: Edge | EdgeId) -&gt; None:\n    e_id = Edge.to_id(e)\n\n    if e_id in self.__edges:\n        return\n\n    self.__edges.append(e_id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.discard","title":"<code>discard(e)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def discard(self, e: Edge | EdgeId) -&gt; None:\n    e_id = Edge.to_id(e)\n\n    self.__edges.remove(e_id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.replace","title":"<code>replace(old, new)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def replace(self, old: Edge | EdgeId, new: Edge | EdgeId) -&gt; None:\n    old_id = Edge.to_id(old)\n    new_id = Edge.to_id(new)\n    for i in range(len(self.__edges)):\n        if self.__edges[i] == old_id:\n            self.__edges[i] = new_id\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeNotFound","title":"<code>EdgeNotFound</code>","text":"<p>             Bases: <code>Exception</code></p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeNotFound(Exception):\n    pass\n</code></pre>"},{"location":"reference/graphdb/#graphdb.ErrorSavingDuringDelWarning","title":"<code>ErrorSavingDuringDelWarning</code>","text":"<p>             Bases: <code>Warning</code></p> Source code in <code>roc/graphdb.py</code> <pre><code>class ErrorSavingDuringDelWarning(Warning):\n    pass\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphCache","title":"<code>GraphCache</code>","text":"<p>             Bases: <code>LRUCache[CacheKey, CacheValue]</code>, <code>Generic[CacheKey, CacheValue]</code></p> Source code in <code>roc/graphdb.py</code> <pre><code>class GraphCache(LRUCache[CacheKey, CacheValue], Generic[CacheKey, CacheValue]):\n    def __init__(self, maxsize: int):\n        super().__init__(maxsize=maxsize)\n        self.hits = 0\n        self.misses = 0\n\n    def get(  # type: ignore [override]\n        self,\n        key: CacheKey,\n        /,\n        default: CacheValue | None = None,\n    ) -&gt; CacheValue | None:\n        v = super().get(key)\n        if not v:\n            self.misses = self.misses + 1\n        else:\n            self.hits = self.hits + 1\n        return v\n\n    def clear(self) -&gt; None:\n        super().clear()\n        self.hits = 0\n        self.misses = 0\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphCache.hits","title":"<code>hits = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphCache.misses","title":"<code>misses = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphCache.__init__","title":"<code>__init__(maxsize)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, maxsize: int):\n    super().__init__(maxsize=maxsize)\n    self.hits = 0\n    self.misses = 0\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphCache.clear","title":"<code>clear()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def clear(self) -&gt; None:\n    super().clear()\n    self.hits = 0\n    self.misses = 0\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphCache.get","title":"<code>get(key, /, default=None)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def get(  # type: ignore [override]\n    self,\n    key: CacheKey,\n    /,\n    default: CacheValue | None = None,\n) -&gt; CacheValue | None:\n    v = super().get(key)\n    if not v:\n        self.misses = self.misses + 1\n    else:\n        self.hits = self.hits + 1\n    return v\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB","title":"<code>GraphDB</code>","text":"<p>A graph database singleton. Settings for the graph database come from the config module.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class GraphDB:\n    \"\"\"\n    A graph database singleton. Settings for the graph database come from the config module.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        settings = Config.get()\n        self.host = settings.db_host\n        self.port = settings.db_port\n        self.encrypted = settings.db_conn_encrypted\n        self.username = settings.db_username\n        self.password = settings.db_password\n        self.lazy = settings.db_lazy\n        self.client_name = \"roc-graphdb-client\"\n        self.db_conn = self.connect()\n\n    def raw_fetch(\n        self, query: str, *, params: dict[str, Any] | None = None\n    ) -&gt; Iterator[dict[str, Any]]:\n        params = params or {}\n        logger.trace(f\"raw_fetch: '{query}' *** with params: *** '{params}\")\n\n        cursor = self.db_conn.cursor()\n        cursor.execute(query, params)\n        while True:\n            row = cursor.fetchone()\n            if row is None:\n                break\n            yield {\n                dsc.name: _convert_memgraph_value(row[index])\n                for index, dsc in enumerate(cursor.description)\n            }\n\n    def raw_execute(self, query: str, *, params: dict[str, Any] | None = None) -&gt; None:\n        params = params or {}\n        logger.trace(f\"raw_execute: '{query}' *** with params: *** '{params}'\")\n        cursor = self.db_conn.cursor()\n        cursor.execute(query, params)\n        cursor.fetchall()\n\n    def connected(self) -&gt; bool:\n        return self.db_conn is not None and self.db_conn.status == mgclient.CONN_STATUS_READY\n\n    def connect(self) -&gt; mgclient.Connection:\n        sslmode = mgclient.MG_SSLMODE_REQUIRE if self.encrypted else mgclient.MG_SSLMODE_DISABLE\n        connection = mgclient.connect(\n            host=self.host,\n            port=self.port,\n            username=self.username,\n            password=self.password,\n            sslmode=sslmode,\n            lazy=self.lazy,\n            client_name=self.client_name,\n        )\n        connection.autocommit = True\n        return connection\n\n    @classmethod\n    def singleton(cls) -&gt; GraphDB:\n        global graph_db_singleton\n        if not graph_db_singleton:\n            graph_db_singleton = GraphDB()\n\n        return graph_db_singleton\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.client_name","title":"<code>client_name = 'roc-graphdb-client'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.db_conn","title":"<code>db_conn = self.connect()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.encrypted","title":"<code>encrypted = settings.db_conn_encrypted</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.host","title":"<code>host = settings.db_host</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.lazy","title":"<code>lazy = settings.db_lazy</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.password","title":"<code>password = settings.db_password</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.port","title":"<code>port = settings.db_port</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.username","title":"<code>username = settings.db_username</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self) -&gt; None:\n    settings = Config.get()\n    self.host = settings.db_host\n    self.port = settings.db_port\n    self.encrypted = settings.db_conn_encrypted\n    self.username = settings.db_username\n    self.password = settings.db_password\n    self.lazy = settings.db_lazy\n    self.client_name = \"roc-graphdb-client\"\n    self.db_conn = self.connect()\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.connect","title":"<code>connect()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def connect(self) -&gt; mgclient.Connection:\n    sslmode = mgclient.MG_SSLMODE_REQUIRE if self.encrypted else mgclient.MG_SSLMODE_DISABLE\n    connection = mgclient.connect(\n        host=self.host,\n        port=self.port,\n        username=self.username,\n        password=self.password,\n        sslmode=sslmode,\n        lazy=self.lazy,\n        client_name=self.client_name,\n    )\n    connection.autocommit = True\n    return connection\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.connected","title":"<code>connected()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def connected(self) -&gt; bool:\n    return self.db_conn is not None and self.db_conn.status == mgclient.CONN_STATUS_READY\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.raw_execute","title":"<code>raw_execute(query, *, params=None)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def raw_execute(self, query: str, *, params: dict[str, Any] | None = None) -&gt; None:\n    params = params or {}\n    logger.trace(f\"raw_execute: '{query}' *** with params: *** '{params}'\")\n    cursor = self.db_conn.cursor()\n    cursor.execute(query, params)\n    cursor.fetchall()\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.raw_fetch","title":"<code>raw_fetch(query, *, params=None)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def raw_fetch(\n    self, query: str, *, params: dict[str, Any] | None = None\n) -&gt; Iterator[dict[str, Any]]:\n    params = params or {}\n    logger.trace(f\"raw_fetch: '{query}' *** with params: *** '{params}\")\n\n    cursor = self.db_conn.cursor()\n    cursor.execute(query, params)\n    while True:\n        row = cursor.fetchone()\n        if row is None:\n            break\n        yield {\n            dsc.name: _convert_memgraph_value(row[index])\n            for index, dsc in enumerate(cursor.description)\n        }\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.singleton","title":"<code>singleton()</code>  <code>classmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef singleton(cls) -&gt; GraphDB:\n    global graph_db_singleton\n    if not graph_db_singleton:\n        graph_db_singleton = GraphDB()\n\n    return graph_db_singleton\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node","title":"<code>Node</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An graph database node that automatically handles CRUD for the underlying graph database objects</p> Source code in <code>roc/graphdb.py</code> <pre><code>class Node(BaseModel, extra=\"allow\"):\n    \"\"\"\n    An graph database node that automatically handles CRUD for the underlying graph database objects\n    \"\"\"\n\n    id: NodeId = Field(exclude=True)\n    labels: set[str] = Field(exclude=True)\n\n    @field_validator(\"id\", mode=\"before\")\n    def default_id(cls, id: NodeId | None) -&gt; NodeId:\n        if isinstance(id, int):\n            return id\n\n        return get_next_new_node_id()\n\n    @field_validator(\"labels\", mode=\"before\")\n    def default_labels(cls, labels: list[str] | set[str] | None) -&gt; set[str]:\n        if not labels:\n            return set()\n\n        if isinstance(labels, list):\n            return set(labels)\n\n        return labels\n\n    @property\n    def src_edges(self) -&gt; EdgeList:\n        return self._src_edges\n\n    @property\n    def dst_edges(self) -&gt; EdgeList:\n        return self._dst_edges\n\n    @property\n    def new(self) -&gt; bool:\n        return self._new\n\n    def __init__(\n        self,\n        *,\n        id: NodeId | None = None,\n        data: dict[Any, Any] | None = None,\n        labels: set[str] | list[str] | None = None,\n        src_edges: EdgeList | None = None,\n        dst_edges: EdgeList | None = None,\n        db: GraphDB | None = None,\n    ):\n        data = data or {}\n\n        super().__init__(\n            id=id,\n            labels=labels,\n            **data,\n        )\n\n        self._new = False\n        self._no_save = False\n        self._deleted = False\n        self._db = db or GraphDB.singleton()\n\n        if self.id &lt; 0:\n            self._new = True  # TODO: derived?\n            Node.get_cache()[self.id] = self\n\n        self._orig_labels = self.labels.copy()\n        self._src_edges = src_edges or EdgeList([])\n        self._dst_edges = dst_edges or EdgeList([])\n        # TODO: ignore fields on save\n        # self._ignored_fields = [\"new\", \"no_save\", \"deleted\"]\n\n    def __del__(self) -&gt; None:\n        try:\n            self.__class__.save(self, db=self._db)\n        except Exception as e:\n            err_msg = f\"error saving during del: {e}\"\n            # logger.warning(err_msg)\n            warnings.warn(err_msg, ErrorSavingDuringDelWarning)\n\n    @classmethod\n    def load(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Loads a node from the database. Use `Node.get` or other methods instead.\n\n        Args:\n            id (NodeId): The identifier of the node to fetch\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            NodeNotFound: The node specified by the identifier does not exist in the database\n\n        Returns:\n            Self: The node from the database\n        \"\"\"\n\n        db = db or GraphDB.singleton()\n        res = list(\n            db.raw_fetch(\n                f\"\"\"\n                MATCH (n)-[e]-(m) WHERE id(n) = {id}\n                RETURN n, e, id(e) as e_id, id(startNode(e)) as e_start, id(endNode(e)) as e_end\n                \"\"\",\n            )\n        )\n\n        # print(\"RES\", res)\n\n        if not len(res) &gt;= 1:\n            raise NodeNotFound(f\"Couldn't find node ID: {id}\")\n\n        n = res[0][\"n\"]\n        edges = list(\n            map(lambda r: {\"id\": r[\"e_id\"], \"start\": r[\"e_start\"], \"end\": r[\"e_end\"]}, res)\n        )\n        src_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"start\"] == id, edges)))\n        dst_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"end\"] == id, edges)))\n        return cls(\n            id=id,\n            src_edges=EdgeList(src_edges),\n            dst_edges=EdgeList(dst_edges),\n            labels=n.labels,\n            data=n.properties,\n        )\n\n    @classmethod\n    def get_cache(cls) -&gt; NodeCache:\n        global node_cache\n        if node_cache is None:\n            settings = Config.get()\n            node_cache = NodeCache(settings.node_cache_size)\n\n        return node_cache\n\n    @classmethod\n    def get(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Returns a cached node with the specified id. If no node is cached, it is retrieved from\n        the database.\n\n\n        Args:\n            id (NodeId): The unique identifier of the node to fetch\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: the cached or newly retrieved node\n        \"\"\"\n        cache = Node.get_cache()\n        n = cache.get(id)\n        if not n:\n            n = cls.load(id, db=db)\n            cache[id] = n\n\n        return cast(Self, n)\n\n    @classmethod\n    def save(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Save a node to persistent storage\n\n        Writes the specified node to the GraphDB for persistent storage. If the node does not\n        already exist in storage, it is created via the `create` method. If the node does exist, it\n        is updated via the `update` method.\n\n        If the _no_save flag is True on the node, the save request will be silently ignored.\n\n        Args:\n            n (Self): The Node to be saved\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: As a convenience, the node that was stored is returned. This may be useful\n            since the the id of the node may change if it was created in the database.\n        \"\"\"\n        if n._new:\n            return cls.create(n, db=db)\n        else:\n            return cls.update(n, db=db)\n\n    @classmethod\n    def update(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Update an existing node in the GraphDB.\n\n        Calling `save` is preferred to using this method so that the caller doesn't need to know the\n        state of the node.\n\n        Args:\n            n (Self): The node to be updated\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: The node that was passed in, for convenience\n        \"\"\"\n        if n._no_save:\n            return n\n\n        db = db or GraphDB.singleton()\n\n        orig_labels = n._orig_labels\n        curr_labels = set(n.labels)\n        new_labels = curr_labels - orig_labels\n        rm_labels = orig_labels - curr_labels\n        set_label_str = Node.mklabels(new_labels)\n        if set_label_str:\n            set_query = f\"SET n{set_label_str}, n = $props\"\n        else:\n            set_query = \"SET n = $props\"\n        rm_label_str = Node.mklabels(rm_labels)\n        if rm_label_str:\n            rm_query = f\"REMOVE n{rm_label_str}\"\n        else:\n            rm_query = \"\"\n\n        params = {\"props\": n.model_dump()}\n\n        db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} {set_query} {rm_query}\", params=params)\n\n        return n\n\n    @classmethod\n    def create(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Creates the specified node in the GraphDB.\n\n        Calling `save` is preferred to using this method so that the caller doesn't need to know the\n        state of the node.\n\n        Args:\n            n (Self): the node to be created\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            NodeCreationFailed: if creating the node failed in the database\n\n        Returns:\n            Self: the node that was passed in, albeit with a new `id` and potenitally other new\n            fields\n        \"\"\"\n        if n._no_save:\n            return n\n\n        db = db or GraphDB.singleton()\n        old_id = n.id\n\n        label_str = Node.mklabels(n.labels)\n        params = {\"props\": n.model_dump()}\n\n        res = list(db.raw_fetch(f\"CREATE (n{label_str} $props) RETURN id(n) as id\", params=params))\n\n        if not len(res) &gt;= 1:\n            raise NodeCreationFailed(f\"Couldn't find node ID: {id}\")\n\n        new_id = res[0][\"id\"]\n        n.id = new_id\n        n._new = False\n        # update the cache; if being called during c then the cache entry may not exist\n        try:\n            cache = Node.get_cache()\n            del cache[old_id]\n            cache[new_id] = n\n        except KeyError:\n            pass\n\n        for e in n.src_edges:\n            assert e.src_id == old_id\n            e.src_id = new_id\n\n        for e in n.dst_edges:\n            assert e.dst_id == old_id\n            e.dst_id = new_id\n\n        return n\n\n    @classmethod\n    def connect(\n        cls,\n        src: NodeId | Self,\n        dst: NodeId | Self,\n        type: str,\n        *,\n        db: GraphDB | None = None,\n    ) -&gt; Edge:\n        \"\"\"Connects two nodes (creates an Edge between two nodes)\n\n        Args:\n            src (NodeId | Node): _description_\n            dst (NodeId | Node): _description_\n            type (str): _description_\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Edge: _description_\n        \"\"\"\n        if isinstance(src, Node):\n            src_id = src.id\n        else:\n            src_id = src\n\n        if isinstance(dst, Node):\n            dst_id = dst.id\n        else:\n            dst_id = dst\n\n        e = Edge(src_id, dst_id, type)\n        src_node = cls.get(src_id, db=db)\n        dst_node = cls.get(dst_id, db=db)\n        src_node.src_edges.add(e)\n        dst_node.dst_edges.add(e)\n        return e\n\n    @staticmethod\n    def delete(n: Node, *, db: GraphDB | None = None) -&gt; None:\n        db = db or GraphDB.singleton()\n\n        # remove edges\n        for e in n.src_edges:\n            Edge.delete(e)\n\n        for e in n.dst_edges:\n            Edge.delete(e)\n\n        # remove from cache\n        node_cache = Node.get_cache()\n        if n.id in node_cache:\n            del node_cache[n.id]\n\n        if not n._new:\n            db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} DELETE n\")\n\n        n._deleted = True\n        n._no_save = True\n\n    @staticmethod\n    def mklabels(labels: set[str]) -&gt; str:\n        \"Converts a list of strings into proper Cypher syntax for a graph database query\"\n        labels_list = [i for i in labels]\n        labels_list.sort()\n        label_str = \":\".join(labels_list)\n        if len(label_str) &gt; 0:\n            label_str = \":\" + label_str\n        return label_str\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.dst_edges","title":"<code>dst_edges: EdgeList</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Node.id","title":"<code>id: NodeId = Field(exclude=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Node.labels","title":"<code>labels: set[str] = Field(exclude=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Node.new","title":"<code>new: bool</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Node.src_edges","title":"<code>src_edges: EdgeList</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Node.__del__","title":"<code>__del__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __del__(self) -&gt; None:\n    try:\n        self.__class__.save(self, db=self._db)\n    except Exception as e:\n        err_msg = f\"error saving during del: {e}\"\n        # logger.warning(err_msg)\n        warnings.warn(err_msg, ErrorSavingDuringDelWarning)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.__init__","title":"<code>__init__(*, id=None, data=None, labels=None, src_edges=None, dst_edges=None, db=None)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(\n    self,\n    *,\n    id: NodeId | None = None,\n    data: dict[Any, Any] | None = None,\n    labels: set[str] | list[str] | None = None,\n    src_edges: EdgeList | None = None,\n    dst_edges: EdgeList | None = None,\n    db: GraphDB | None = None,\n):\n    data = data or {}\n\n    super().__init__(\n        id=id,\n        labels=labels,\n        **data,\n    )\n\n    self._new = False\n    self._no_save = False\n    self._deleted = False\n    self._db = db or GraphDB.singleton()\n\n    if self.id &lt; 0:\n        self._new = True  # TODO: derived?\n        Node.get_cache()[self.id] = self\n\n    self._orig_labels = self.labels.copy()\n    self._src_edges = src_edges or EdgeList([])\n    self._dst_edges = dst_edges or EdgeList([])\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.connect","title":"<code>connect(src, dst, type, *, db=None)</code>  <code>classmethod</code>","text":"<p>Connects two nodes (creates an Edge between two nodes)</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>NodeId | Node</code> <p>description</p> required <code>dst</code> <code>NodeId | Node</code> <p>description</p> required <code>type</code> <code>str</code> <p>description</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Edge</code> <code>Edge</code> <p>description</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef connect(\n    cls,\n    src: NodeId | Self,\n    dst: NodeId | Self,\n    type: str,\n    *,\n    db: GraphDB | None = None,\n) -&gt; Edge:\n    \"\"\"Connects two nodes (creates an Edge between two nodes)\n\n    Args:\n        src (NodeId | Node): _description_\n        dst (NodeId | Node): _description_\n        type (str): _description_\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Edge: _description_\n    \"\"\"\n    if isinstance(src, Node):\n        src_id = src.id\n    else:\n        src_id = src\n\n    if isinstance(dst, Node):\n        dst_id = dst.id\n    else:\n        dst_id = dst\n\n    e = Edge(src_id, dst_id, type)\n    src_node = cls.get(src_id, db=db)\n    dst_node = cls.get(dst_id, db=db)\n    src_node.src_edges.add(e)\n    dst_node.dst_edges.add(e)\n    return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.create","title":"<code>create(n, *, db=None)</code>  <code>classmethod</code>","text":"<p>Creates the specified node in the GraphDB.</p> <p>Calling <code>save</code> is preferred to using this method so that the caller doesn't need to know the state of the node.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Self</code> <p>the node to be created</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>NodeCreationFailed</code> <p>if creating the node failed in the database</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the node that was passed in, albeit with a new <code>id</code> and potenitally other new</p> <code>Self</code> <p>fields</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef create(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Creates the specified node in the GraphDB.\n\n    Calling `save` is preferred to using this method so that the caller doesn't need to know the\n    state of the node.\n\n    Args:\n        n (Self): the node to be created\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        NodeCreationFailed: if creating the node failed in the database\n\n    Returns:\n        Self: the node that was passed in, albeit with a new `id` and potenitally other new\n        fields\n    \"\"\"\n    if n._no_save:\n        return n\n\n    db = db or GraphDB.singleton()\n    old_id = n.id\n\n    label_str = Node.mklabels(n.labels)\n    params = {\"props\": n.model_dump()}\n\n    res = list(db.raw_fetch(f\"CREATE (n{label_str} $props) RETURN id(n) as id\", params=params))\n\n    if not len(res) &gt;= 1:\n        raise NodeCreationFailed(f\"Couldn't find node ID: {id}\")\n\n    new_id = res[0][\"id\"]\n    n.id = new_id\n    n._new = False\n    # update the cache; if being called during c then the cache entry may not exist\n    try:\n        cache = Node.get_cache()\n        del cache[old_id]\n        cache[new_id] = n\n    except KeyError:\n        pass\n\n    for e in n.src_edges:\n        assert e.src_id == old_id\n        e.src_id = new_id\n\n    for e in n.dst_edges:\n        assert e.dst_id == old_id\n        e.dst_id = new_id\n\n    return n\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.default_id","title":"<code>default_id(id)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@field_validator(\"id\", mode=\"before\")\ndef default_id(cls, id: NodeId | None) -&gt; NodeId:\n    if isinstance(id, int):\n        return id\n\n    return get_next_new_node_id()\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.default_labels","title":"<code>default_labels(labels)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@field_validator(\"labels\", mode=\"before\")\ndef default_labels(cls, labels: list[str] | set[str] | None) -&gt; set[str]:\n    if not labels:\n        return set()\n\n    if isinstance(labels, list):\n        return set(labels)\n\n    return labels\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.delete","title":"<code>delete(n, *, db=None)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef delete(n: Node, *, db: GraphDB | None = None) -&gt; None:\n    db = db or GraphDB.singleton()\n\n    # remove edges\n    for e in n.src_edges:\n        Edge.delete(e)\n\n    for e in n.dst_edges:\n        Edge.delete(e)\n\n    # remove from cache\n    node_cache = Node.get_cache()\n    if n.id in node_cache:\n        del node_cache[n.id]\n\n    if not n._new:\n        db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} DELETE n\")\n\n    n._deleted = True\n    n._no_save = True\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.get","title":"<code>get(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Returns a cached node with the specified id. If no node is cached, it is retrieved from the database.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>NodeId</code> <p>The unique identifier of the node to fetch</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the cached or newly retrieved node</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Returns a cached node with the specified id. If no node is cached, it is retrieved from\n    the database.\n\n\n    Args:\n        id (NodeId): The unique identifier of the node to fetch\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: the cached or newly retrieved node\n    \"\"\"\n    cache = Node.get_cache()\n    n = cache.get(id)\n    if not n:\n        n = cls.load(id, db=db)\n        cache[id] = n\n\n    return cast(Self, n)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.get_cache","title":"<code>get_cache()</code>  <code>classmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get_cache(cls) -&gt; NodeCache:\n    global node_cache\n    if node_cache is None:\n        settings = Config.get()\n        node_cache = NodeCache(settings.node_cache_size)\n\n    return node_cache\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.load","title":"<code>load(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Loads a node from the database. Use <code>Node.get</code> or other methods instead.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>NodeId</code> <p>The identifier of the node to fetch</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>NodeNotFound</code> <p>The node specified by the identifier does not exist in the database</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The node from the database</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef load(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Loads a node from the database. Use `Node.get` or other methods instead.\n\n    Args:\n        id (NodeId): The identifier of the node to fetch\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        NodeNotFound: The node specified by the identifier does not exist in the database\n\n    Returns:\n        Self: The node from the database\n    \"\"\"\n\n    db = db or GraphDB.singleton()\n    res = list(\n        db.raw_fetch(\n            f\"\"\"\n            MATCH (n)-[e]-(m) WHERE id(n) = {id}\n            RETURN n, e, id(e) as e_id, id(startNode(e)) as e_start, id(endNode(e)) as e_end\n            \"\"\",\n        )\n    )\n\n    # print(\"RES\", res)\n\n    if not len(res) &gt;= 1:\n        raise NodeNotFound(f\"Couldn't find node ID: {id}\")\n\n    n = res[0][\"n\"]\n    edges = list(\n        map(lambda r: {\"id\": r[\"e_id\"], \"start\": r[\"e_start\"], \"end\": r[\"e_end\"]}, res)\n    )\n    src_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"start\"] == id, edges)))\n    dst_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"end\"] == id, edges)))\n    return cls(\n        id=id,\n        src_edges=EdgeList(src_edges),\n        dst_edges=EdgeList(dst_edges),\n        labels=n.labels,\n        data=n.properties,\n    )\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.mklabels","title":"<code>mklabels(labels)</code>  <code>staticmethod</code>","text":"<p>Converts a list of strings into proper Cypher syntax for a graph database query</p> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef mklabels(labels: set[str]) -&gt; str:\n    \"Converts a list of strings into proper Cypher syntax for a graph database query\"\n    labels_list = [i for i in labels]\n    labels_list.sort()\n    label_str = \":\".join(labels_list)\n    if len(label_str) &gt; 0:\n        label_str = \":\" + label_str\n    return label_str\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.save","title":"<code>save(n, *, db=None)</code>  <code>classmethod</code>","text":"<p>Save a node to persistent storage</p> <p>Writes the specified node to the GraphDB for persistent storage. If the node does not already exist in storage, it is created via the <code>create</code> method. If the node does exist, it is updated via the <code>update</code> method.</p> <p>If the _no_save flag is True on the node, the save request will be silently ignored.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Self</code> <p>The Node to be saved</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>As a convenience, the node that was stored is returned. This may be useful</p> <code>Self</code> <p>since the the id of the node may change if it was created in the database.</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef save(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Save a node to persistent storage\n\n    Writes the specified node to the GraphDB for persistent storage. If the node does not\n    already exist in storage, it is created via the `create` method. If the node does exist, it\n    is updated via the `update` method.\n\n    If the _no_save flag is True on the node, the save request will be silently ignored.\n\n    Args:\n        n (Self): The Node to be saved\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: As a convenience, the node that was stored is returned. This may be useful\n        since the the id of the node may change if it was created in the database.\n    \"\"\"\n    if n._new:\n        return cls.create(n, db=db)\n    else:\n        return cls.update(n, db=db)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.update","title":"<code>update(n, *, db=None)</code>  <code>classmethod</code>","text":"<p>Update an existing node in the GraphDB.</p> <p>Calling <code>save</code> is preferred to using this method so that the caller doesn't need to know the state of the node.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Self</code> <p>The node to be updated</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The node that was passed in, for convenience</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef update(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Update an existing node in the GraphDB.\n\n    Calling `save` is preferred to using this method so that the caller doesn't need to know the\n    state of the node.\n\n    Args:\n        n (Self): The node to be updated\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: The node that was passed in, for convenience\n    \"\"\"\n    if n._no_save:\n        return n\n\n    db = db or GraphDB.singleton()\n\n    orig_labels = n._orig_labels\n    curr_labels = set(n.labels)\n    new_labels = curr_labels - orig_labels\n    rm_labels = orig_labels - curr_labels\n    set_label_str = Node.mklabels(new_labels)\n    if set_label_str:\n        set_query = f\"SET n{set_label_str}, n = $props\"\n    else:\n        set_query = \"SET n = $props\"\n    rm_label_str = Node.mklabels(rm_labels)\n    if rm_label_str:\n        rm_query = f\"REMOVE n{rm_label_str}\"\n    else:\n        rm_query = \"\"\n\n    params = {\"props\": n.model_dump()}\n\n    db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} {set_query} {rm_query}\", params=params)\n\n    return n\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeCreationFailed","title":"<code>NodeCreationFailed</code>","text":"<p>             Bases: <code>Exception</code></p> Source code in <code>roc/graphdb.py</code> <pre><code>class NodeCreationFailed(Exception):\n    pass\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeNotFound","title":"<code>NodeNotFound</code>","text":"<p>             Bases: <code>Exception</code></p> Source code in <code>roc/graphdb.py</code> <pre><code>class NodeNotFound(Exception):\n    pass\n</code></pre>"},{"location":"reference/graphdb/#graphdb.get_next_new_edge_id","title":"<code>get_next_new_edge_id()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def get_next_new_edge_id() -&gt; EdgeId:\n    global next_new_edge\n    id = next_new_edge\n    next_new_edge = cast(EdgeId, next_new_edge - 1)\n\n    return id\n</code></pre>"},{"location":"reference/graphdb/#graphdb.get_next_new_node_id","title":"<code>get_next_new_node_id()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def get_next_new_node_id() -&gt; NodeId:\n    global next_new_node\n    id = next_new_node\n    next_new_node = cast(NodeId, next_new_node - 1)\n    return id\n</code></pre>"},{"location":"reference/gymnasium/","title":"gymnasium","text":"<p>This module is a wrapper around the Gym / Gymnasium interfaces and drives all the interactions between the agent and the system, including the main event loop.</p>"},{"location":"reference/gymnasium/#gymnasium.count","title":"<code>count = 0</code>  <code>module-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.dump_env_file","title":"<code>dump_env_file: Any = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats","title":"<code>BottomlineStats</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A Pydantic model representing the Nethack bottom line statistics.</p> Source code in <code>roc/gymnasium.py</code> <pre><code>class BottomlineStats(BaseModel):\n    \"\"\"A Pydantic model representing the Nethack bottom line statistics.\"\"\"\n\n    X: int\n    Y: int\n    STR25: int\n    STR125: int\n    DEX: int\n    CON: int\n    INT: int\n    WIS: int\n    CHA: int\n    SCORE: int\n    HP: int\n    HPMAX: int\n    DEPTH: int\n    GOLD: int\n    ENE: int\n    ENEMAX: int\n    AC: int\n    HD: int\n    XP: int\n    EXP: int\n    TIME: int\n    HUNGER: int\n    CAP: int\n    DNUM: int\n    DLEVEL: int\n    CONDITION: int\n    ALIGN: int\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.AC","title":"<code>AC: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.ALIGN","title":"<code>ALIGN: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.CAP","title":"<code>CAP: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.CHA","title":"<code>CHA: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.CON","title":"<code>CON: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.CONDITION","title":"<code>CONDITION: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.DEPTH","title":"<code>DEPTH: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.DEX","title":"<code>DEX: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.DLEVEL","title":"<code>DLEVEL: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.DNUM","title":"<code>DNUM: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.ENE","title":"<code>ENE: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.ENEMAX","title":"<code>ENEMAX: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.EXP","title":"<code>EXP: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.GOLD","title":"<code>GOLD: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.HD","title":"<code>HD: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.HP","title":"<code>HP: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.HPMAX","title":"<code>HPMAX: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.HUNGER","title":"<code>HUNGER: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.INT","title":"<code>INT: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.SCORE","title":"<code>SCORE: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.STR125","title":"<code>STR125: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.STR25","title":"<code>STR25: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.TIME","title":"<code>TIME: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.WIS","title":"<code>WIS: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.X","title":"<code>X: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.XP","title":"<code>XP: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.Y","title":"<code>Y: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym","title":"<code>Gym</code>","text":"<p>             Bases: <code>Component</code>, <code>ABC</code></p> <p>A wrapper around an OpenAI Gym / Farama Gymnasium that drives the event loop and interfaces to the ROC agent.</p> Source code in <code>roc/gymnasium.py</code> <pre><code>class Gym(Component, ABC):\n    \"\"\"A wrapper around an OpenAI Gym / Farama Gymnasium that drives the event\n    loop and interfaces to the ROC agent.\n    \"\"\"\n\n    def __init__(self, gym_id: str, *, gym_opts: dict[str, Any] | None = None) -&gt; None:\n        super().__init__()\n        gym_opts = gym_opts or {}\n        self.env = gym.make(gym_id, **gym_opts)\n\n        # setup communications\n        self.env_bus = Perception.bus\n        self.action_bus = action_bus\n        self.env_bus_conn = self.env_bus.connect(self)\n        self.action_bus_conn = self.action_bus.connect(self)\n\n        # config actions\n        self.action_count = self.env.action_space.n\n        self.config_actions(self.action_count)\n\n        # TODO: config environment\n        # setup which features detectors to use on each bus\n\n    @abstractmethod\n    def send_obs(self, obs: Any) -&gt; None:\n        pass\n\n    @abstractmethod\n    def config_actions(self, action_count: int) -&gt; None:\n        pass\n\n    @logger.catch\n    def start(self) -&gt; None:\n        obs = self.env.reset()\n\n        done = False\n        dump_env_start()\n\n        # main environment loop\n        while not done:\n            # logger.trace(f\"Sending observation: {obs}\")\n            self.send_obs(obs)\n            action = self.await_action()\n            logger.trace(f\"Doing action: {action}\")\n            step_res = self.env.step(action)\n            obs = step_res[0]\n            dump_env_record(obs)\n\n            if len(step_res) == 5:\n                done = step_res[2] or step_res[3]\n            else:\n                done = step_res[2]\n\n            # self.env.render()\n            logger.trace(f\"Main loop done: {done}\")\n\n        dump_env_end()\n\n    def decode_action(self, action: int) -&gt; Any:\n        return action\n\n    def await_action(self) -&gt; Any:\n        # TODO: self.action_bus_conn.subject.first()\n        logger.warning(\"AWAIT ACTION NOT IMPLEMENTED\")\n        default_action = 19  # 19 = 46 = \".\" = do nothing\n        action = self.decode_action(default_action)\n        return action\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.action_bus","title":"<code>action_bus = action_bus</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.action_bus_conn","title":"<code>action_bus_conn = self.action_bus.connect(self)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.action_count","title":"<code>action_count = self.env.action_space.n</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.env","title":"<code>env = gym.make(gym_id, **gym_opts)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.env_bus","title":"<code>env_bus = Perception.bus</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.env_bus_conn","title":"<code>env_bus_conn = self.env_bus.connect(self)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.__init__","title":"<code>__init__(gym_id, *, gym_opts=None)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def __init__(self, gym_id: str, *, gym_opts: dict[str, Any] | None = None) -&gt; None:\n    super().__init__()\n    gym_opts = gym_opts or {}\n    self.env = gym.make(gym_id, **gym_opts)\n\n    # setup communications\n    self.env_bus = Perception.bus\n    self.action_bus = action_bus\n    self.env_bus_conn = self.env_bus.connect(self)\n    self.action_bus_conn = self.action_bus.connect(self)\n\n    # config actions\n    self.action_count = self.env.action_space.n\n    self.config_actions(self.action_count)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.await_action","title":"<code>await_action()</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def await_action(self) -&gt; Any:\n    # TODO: self.action_bus_conn.subject.first()\n    logger.warning(\"AWAIT ACTION NOT IMPLEMENTED\")\n    default_action = 19  # 19 = 46 = \".\" = do nothing\n    action = self.decode_action(default_action)\n    return action\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.config_actions","title":"<code>config_actions(action_count)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>@abstractmethod\ndef config_actions(self, action_count: int) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.decode_action","title":"<code>decode_action(action)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def decode_action(self, action: int) -&gt; Any:\n    return action\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.send_obs","title":"<code>send_obs(obs)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>@abstractmethod\ndef send_obs(self, obs: Any) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.start","title":"<code>start()</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>@logger.catch\ndef start(self) -&gt; None:\n    obs = self.env.reset()\n\n    done = False\n    dump_env_start()\n\n    # main environment loop\n    while not done:\n        # logger.trace(f\"Sending observation: {obs}\")\n        self.send_obs(obs)\n        action = self.await_action()\n        logger.trace(f\"Doing action: {action}\")\n        step_res = self.env.step(action)\n        obs = step_res[0]\n        dump_env_record(obs)\n\n        if len(step_res) == 5:\n            done = step_res[2] or step_res[3]\n        else:\n            done = step_res[2]\n\n        # self.env.render()\n        logger.trace(f\"Main loop done: {done}\")\n\n    dump_env_end()\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym","title":"<code>NethackGym</code>","text":"<p>             Bases: <code>Gym</code></p> <p>Wrapper around the Gym class for driving the Nethack interface to the ROC agent. Decodes Nethack specific data and sends it to the agent as Events.</p> Source code in <code>roc/gymnasium.py</code> <pre><code>class NethackGym(Gym):\n    \"\"\"Wrapper around the Gym class for driving the Nethack interface to the ROC\n    agent. Decodes Nethack specific data and sends it to the agent as Events.\"\"\"\n\n    def __init__(self, *, gym_opts: dict[str, Any] | None = None) -&gt; None:\n        gym_opts = gym_opts or {}\n        super().__init__(\"NetHackScore-v0\", **gym_opts)\n\n    def config_actions(self, action_count: int) -&gt; None:\n        a = ActionCount(action_count=action_count)\n        self.action_bus_conn.send(a)\n\n    def send_obs(self, obs: Any) -&gt; None:\n        self.send_vision(obs)\n        self.send_intrinsics(obs)\n\n    def send_vision(self, obs: Any) -&gt; None:\n        # spectrum = [obs[\"chars\"], obs[\"colors\"], obs[\"glyphs\"]]\n\n        self.env_bus_conn.send(VisionData(screen=obs[\"chars\"]))\n\n    def send_auditory(self) -&gt; None:\n        pass\n\n    def send_proprioceptive(self) -&gt; None:\n        pass\n\n    def send_intrinsics(self, obs: Any) -&gt; None:\n        pass\n        # NOTE: obs[\"blstats\"] is an ndarray object from numpy\n        bl = obs[\"blstats\"].tolist()\n        blstat_args = {e.name: bl[e.value] for e in blstat_offsets}\n        # print(\"blstat_args\", blstat_args)\n\n        blstats = BottomlineStats(**blstat_args)\n        # print(\"blstats\", blstats.model_dump())\n        blstat_conds = {bit.name for bit in condition_bits if blstats.CONDITION &amp; bit.value}\n        # TODO: remove... just curious if conditions ever get set\n        if len(blstat_conds):\n            logger.warning(\"!!! FOUND CONDITIONS\", blstat_conds)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.__init__","title":"<code>__init__(*, gym_opts=None)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def __init__(self, *, gym_opts: dict[str, Any] | None = None) -&gt; None:\n    gym_opts = gym_opts or {}\n    super().__init__(\"NetHackScore-v0\", **gym_opts)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.config_actions","title":"<code>config_actions(action_count)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def config_actions(self, action_count: int) -&gt; None:\n    a = ActionCount(action_count=action_count)\n    self.action_bus_conn.send(a)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.send_auditory","title":"<code>send_auditory()</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def send_auditory(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.send_intrinsics","title":"<code>send_intrinsics(obs)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def send_intrinsics(self, obs: Any) -&gt; None:\n    pass\n    # NOTE: obs[\"blstats\"] is an ndarray object from numpy\n    bl = obs[\"blstats\"].tolist()\n    blstat_args = {e.name: bl[e.value] for e in blstat_offsets}\n    # print(\"blstat_args\", blstat_args)\n\n    blstats = BottomlineStats(**blstat_args)\n    # print(\"blstats\", blstats.model_dump())\n    blstat_conds = {bit.name for bit in condition_bits if blstats.CONDITION &amp; bit.value}\n    # TODO: remove... just curious if conditions ever get set\n    if len(blstat_conds):\n        logger.warning(\"!!! FOUND CONDITIONS\", blstat_conds)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.send_obs","title":"<code>send_obs(obs)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def send_obs(self, obs: Any) -&gt; None:\n    self.send_vision(obs)\n    self.send_intrinsics(obs)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.send_proprioceptive","title":"<code>send_proprioceptive()</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def send_proprioceptive(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.send_vision","title":"<code>send_vision(obs)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def send_vision(self, obs: Any) -&gt; None:\n    # spectrum = [obs[\"chars\"], obs[\"colors\"], obs[\"glyphs\"]]\n\n    self.env_bus_conn.send(VisionData(screen=obs[\"chars\"]))\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.blstat_offsets","title":"<code>blstat_offsets</code>","text":"<p>             Bases: <code>IntEnum</code></p> <p>An enumeration of Nethack bottom line statistics (intelligence, strength, charisma, position, hit points, etc.)</p> Source code in <code>roc/gymnasium.py</code> <pre><code>class blstat_offsets(IntEnum):\n    \"\"\"An enumeration of Nethack bottom line statistics (intelligence, strength,\n    charisma, position, hit points, etc.)\n    \"\"\"\n\n    # fmt: off\n    X =         0\n    Y =         1\n    STR25 =     2\n    STR125 =    3\n    DEX =       4\n    CON =       5\n    INT =       6\n    WIS =       7\n    CHA =       8\n    SCORE =     9\n    HP =        10\n    HPMAX =     11\n    DEPTH =     12\n    GOLD =      13\n    ENE =       14\n    ENEMAX =    15\n    AC =        16\n    HD =        17\n    XP =        18\n    EXP =       19\n    TIME =      20\n    HUNGER =    21\n    CAP =       22\n    DNUM =      23\n    DLEVEL =    24\n    CONDITION = 25\n    ALIGN =     26\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.AC","title":"<code>AC = 16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.ALIGN","title":"<code>ALIGN = 26</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.CAP","title":"<code>CAP = 22</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.CHA","title":"<code>CHA = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.CON","title":"<code>CON = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.CONDITION","title":"<code>CONDITION = 25</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.DEPTH","title":"<code>DEPTH = 12</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.DEX","title":"<code>DEX = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.DLEVEL","title":"<code>DLEVEL = 24</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.DNUM","title":"<code>DNUM = 23</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.ENE","title":"<code>ENE = 14</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.ENEMAX","title":"<code>ENEMAX = 15</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.EXP","title":"<code>EXP = 19</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.GOLD","title":"<code>GOLD = 13</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.HD","title":"<code>HD = 17</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.HP","title":"<code>HP = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.HPMAX","title":"<code>HPMAX = 11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.HUNGER","title":"<code>HUNGER = 21</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.INT","title":"<code>INT = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.SCORE","title":"<code>SCORE = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.STR125","title":"<code>STR125 = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.STR25","title":"<code>STR25 = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.TIME","title":"<code>TIME = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.WIS","title":"<code>WIS = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.X","title":"<code>X = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.XP","title":"<code>XP = 18</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.Y","title":"<code>Y = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits","title":"<code>condition_bits</code>","text":"<p>             Bases: <code>IntEnum</code></p> <p>Bits for decoding the <code>CONDITION</code> bottomline stat to determin if the player is flying, deaf, food poisoned, etc.</p> Source code in <code>roc/gymnasium.py</code> <pre><code>class condition_bits(IntEnum):\n    \"\"\"Bits for decoding the `CONDITION` bottomline stat to determin if the\n    player is flying, deaf, food poisoned, etc.\n    \"\"\"\n\n    # fmt: off\n    BAREH =     0x00000001\n    BLIND =     0x00000002\n    BUSY =      0x00000004\n    CONF =      0x00000008\n    DEAF =      0x00000010\n    ELF_IRON =  0x00000020\n    FLY =       0x00000040\n    FOODPOIS =  0x00000080\n    GLOWHANDS = 0x00000100\n    GRAB =      0x00000200\n    HALLU =     0x00000400\n    HELD =      0x00000800\n    ICY =       0x00001000\n    INLAVA =    0x00002000\n    LEV =       0x00004000\n    PARLYZ =    0x00008000\n    RIDE =      0x00010000\n    SLEEPING =  0x00020000\n    SLIME =     0x00040000\n    SLIPPERY =  0x00080000\n    STONE =     0x00100000\n    STRNGL =    0x00200000\n    STUN =      0x00400000\n    SUBMERGED = 0x00800000\n    TERMILL   = 0x01000000\n    TETHERED =  0x02000000\n    TRAPPED =   0x04000000\n    UNCONSC =   0x08000000\n    WOUNDEDL =  0x10000000\n    HOLDING =   0x20000000\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.condition_bits.BAREH","title":"<code>BAREH = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.BLIND","title":"<code>BLIND = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.BUSY","title":"<code>BUSY = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.CONF","title":"<code>CONF = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.DEAF","title":"<code>DEAF = 16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.ELF_IRON","title":"<code>ELF_IRON = 32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.FLY","title":"<code>FLY = 64</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.FOODPOIS","title":"<code>FOODPOIS = 128</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.GLOWHANDS","title":"<code>GLOWHANDS = 256</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.GRAB","title":"<code>GRAB = 512</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.HALLU","title":"<code>HALLU = 1024</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.HELD","title":"<code>HELD = 2048</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.HOLDING","title":"<code>HOLDING = 536870912</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.ICY","title":"<code>ICY = 4096</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.INLAVA","title":"<code>INLAVA = 8192</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.LEV","title":"<code>LEV = 16384</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.PARLYZ","title":"<code>PARLYZ = 32768</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.RIDE","title":"<code>RIDE = 65536</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.SLEEPING","title":"<code>SLEEPING = 131072</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.SLIME","title":"<code>SLIME = 262144</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.SLIPPERY","title":"<code>SLIPPERY = 524288</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.STONE","title":"<code>STONE = 1048576</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.STRNGL","title":"<code>STRNGL = 2097152</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.STUN","title":"<code>STUN = 4194304</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.SUBMERGED","title":"<code>SUBMERGED = 8388608</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.TERMILL","title":"<code>TERMILL = 16777216</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.TETHERED","title":"<code>TETHERED = 33554432</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.TRAPPED","title":"<code>TRAPPED = 67108864</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.UNCONSC","title":"<code>UNCONSC = 134217728</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.WOUNDEDL","title":"<code>WOUNDEDL = 268435456</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.ascii_list","title":"<code>ascii_list(al)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def ascii_list(al: list[int]) -&gt; str:\n    result_string = \"# \"\n\n    for ascii_value in al:\n        result_string += chr(ascii_value)\n\n    return result_string\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.dump_env_end","title":"<code>dump_env_end()</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def dump_env_end() -&gt; None:\n    if not Config.enable_gym_dump_env:\n        return\n\n    global dump_env_file\n    assert dump_env_file\n    dump_env_file.write(\"]\\n\")\n    dump_env_file.close()\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.dump_env_record","title":"<code>dump_env_record(obs)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def dump_env_record(obs: Any) -&gt; None:\n    if not Config.enable_gym_dump_env:\n        return\n\n    global dump_env_file\n    assert dump_env_file\n\n    global count\n    count = count + 1\n    if count &gt;= Config.max_dump_frames:\n        return\n\n    print_screen(obs[\"tty_chars\"])\n    dump_env_file.write(\"{\\n# fmt: off\\n\")\n    dump_env_file.write(f\"        \\\"chars\\\": {obs['chars'].tolist()},\\n\")\n    dump_env_file.write(f\"        \\\"colors\\\": {obs['colors'].tolist()},\\n\")\n    dump_env_file.write(f\"        \\\"glyphs\\\": {obs['glyphs'].tolist()},\\n\")\n    dump_env_file.write(\"# fmt: on\\n},\\n\")\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.dump_env_start","title":"<code>dump_env_start()</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def dump_env_start() -&gt; None:\n    if not Config.enable_gym_dump_env:\n        return\n\n    global dump_env_file\n    dump_env_file = open(\"env_dump.py\", \"w\")\n    dump_env_file.write(\"[\\n\")\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.print_screen","title":"<code>print_screen(screen, *, as_int=False)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def print_screen(screen: list[list[int]], *, as_int: bool = False) -&gt; None:\n    global dump_env_file\n    assert dump_env_file\n    for row in screen:\n        dump_env_file.write(ascii_list(row) + \"\\n\")\n</code></pre>"},{"location":"reference/intrinsic/","title":"intrinsic","text":""},{"location":"reference/intrinsic/#intrinsic.IntrinsicEvent","title":"<code>IntrinsicEvent = Event[IntrinsicData]</code>  <code>module-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.IntrinsicFn","title":"<code>IntrinsicFn = Callable[[IntrinsicEvent], None]</code>  <code>module-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.intrinsic_registry","title":"<code>intrinsic_registry: dict[str, IntrinsicFn] = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.Intrinsic","title":"<code>Intrinsic</code>","text":"<p>             Bases: <code>Component</code></p> Source code in <code>roc/intrinsic.py</code> <pre><code>@register_component(\"intrinsic\", \"intrinsic\")\nclass Intrinsic(Component):\n    pass\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.IntrinsicData","title":"<code>IntrinsicData</code>","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>roc/intrinsic.py</code> <pre><code>class IntrinsicData(BaseModel):\n    pass\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.register_intrinsic","title":"<code>register_intrinsic</code>","text":"<p>Decorator for registering intrinsics.</p> Source code in <code>roc/intrinsic.py</code> <pre><code>class register_intrinsic:\n    \"\"\"Decorator for registering intrinsics.\"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        self.name = name\n\n    def __call__(self, fn: IntrinsicFn) -&gt; IntrinsicFn:\n        if self.name in intrinsic_registry:\n            raise ValueError(f\"Registering duplicate intrinsic '{self.name}'\")\n\n        intrinsic_registry[self.name] = fn\n\n        return fn\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.register_intrinsic.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.register_intrinsic.__call__","title":"<code>__call__(fn)</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>def __call__(self, fn: IntrinsicFn) -&gt; IntrinsicFn:\n    if self.name in intrinsic_registry:\n        raise ValueError(f\"Registering duplicate intrinsic '{self.name}'\")\n\n    intrinsic_registry[self.name] = fn\n\n    return fn\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.register_intrinsic.__init__","title":"<code>__init__(name)</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    self.name = name\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.noop_intrinsic","title":"<code>noop_intrinsic(e)</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>@register_intrinsic(\"no-op\")\ndef noop_intrinsic(e: IntrinsicEvent) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/logger/","title":"logger","text":"<p>This module defines the logging interface for storing system logs.</p>"},{"location":"reference/logger/#logger.__all__","title":"<code>__all__ = ['logger']</code>  <code>module-attribute</code>","text":""},{"location":"reference/logger/#logger.default_log_filter","title":"<code>default_log_filter = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/logger/#logger.module_names","title":"<code>module_names = [name for (_, name, _) in pkgutil.iter_modules(['roc'])]</code>  <code>module-attribute</code>","text":""},{"location":"reference/logger/#logger.DebugModuleLevel","title":"<code>DebugModuleLevel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A Pydantic model for storing the logging level. Used primarily for setting per-module logging levels.</p> Source code in <code>roc/logger.py</code> <pre><code>class DebugModuleLevel(BaseModel):\n    \"\"\"A Pydantic model for storing the logging level. Used primarily for\n    setting per-module logging levels.\"\"\"\n\n    module_name: str\n    log_level: str = Field(pattern=r\"TRACE|DEBUG|INFO|SUCCESS|WARNING|ERROR|CRITICAL\")\n\n    @field_validator(\"module_name\", mode=\"before\")\n    @classmethod\n    def validate_module_name(cls, name: str) -&gt; str:\n        assert (\n            name in module_names\n        ), f\"Module name '{name}' not a valid module name. Must be one of {module_names}\"\n\n        return name\n</code></pre>"},{"location":"reference/logger/#logger.DebugModuleLevel.log_level","title":"<code>log_level: str = Field(pattern='TRACE|DEBUG|INFO|SUCCESS|WARNING|ERROR|CRITICAL')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/logger/#logger.DebugModuleLevel.module_name","title":"<code>module_name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/logger/#logger.DebugModuleLevel.validate_module_name","title":"<code>validate_module_name(name)</code>  <code>classmethod</code>","text":"Source code in <code>roc/logger.py</code> <pre><code>@field_validator(\"module_name\", mode=\"before\")\n@classmethod\ndef validate_module_name(cls, name: str) -&gt; str:\n    assert (\n        name in module_names\n    ), f\"Module name '{name}' not a valid module name. Must be one of {module_names}\"\n\n    return name\n</code></pre>"},{"location":"reference/logger/#logger.LogFilter","title":"<code>LogFilter</code>","text":"<p>A Callable filter that determines if the loguru record should be logged or not.</p> Source code in <code>roc/logger.py</code> <pre><code>class LogFilter:\n    \"\"\"A Callable filter that determines if the loguru record should be logged\n    or not.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        level: str | None = None,\n        log_modules: str | None = None,\n        enabled: bool = True,\n        use_module_settings: bool = True,\n    ):\n        settings = Config.get()\n        self.level = level or settings.log_level\n        self.level_num = logger.level(self.level).no\n        if not isinstance(log_modules, str):\n            if use_module_settings:\n                log_modules = settings.log_modules\n            else:\n                log_modules = \"\"\n        mod_list = self.parse_module_str(log_modules)\n        self.module_levels = {mod_lvl.module_name: mod_lvl.log_level for mod_lvl in mod_list}\n\n    def __call__(self, record: Any) -&gt; bool:\n        # TODO: this would be more effecient as a dict rather than a loop (O(1) rather than O(n))\n\n        if record[\"module\"] in self.module_levels:\n            mod_log_level = self.module_levels[record[\"module\"]]\n            mod_level_num = logger.level(mod_log_level).no\n            if record[\"level\"].no &gt;= mod_level_num:\n                return True\n            else:\n                return False\n\n        if record[\"level\"].no &gt;= self.level_num:\n            return True\n\n        return False\n\n    @classmethod\n    def parse_module_str(cls, s: str) -&gt; list[DebugModuleLevel]:\n        s = s.strip()\n\n        mod_list = s.split(\";\")\n        # empty str\n        if mod_list == [\"\"]:\n            return []\n\n        mod_lvl_list: list[dict[str, str]] = []\n        for mod in mod_list:\n            mod_parts = mod.split(\":\")\n            mod_lvl_list.append({\"module_name\": mod_parts[0], \"log_level\": mod_parts[1]})\n\n        debug_module_list = TypeAdapter(list[DebugModuleLevel])\n        return debug_module_list.validate_python(mod_lvl_list)\n</code></pre>"},{"location":"reference/logger/#logger.LogFilter.level","title":"<code>level = level or settings.log_level</code>  <code>instance-attribute</code>","text":""},{"location":"reference/logger/#logger.LogFilter.level_num","title":"<code>level_num = logger.level(self.level).no</code>  <code>instance-attribute</code>","text":""},{"location":"reference/logger/#logger.LogFilter.module_levels","title":"<code>module_levels = {mod_lvl.module_name: mod_lvl.log_levelfor mod_lvl in mod_list}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/logger/#logger.LogFilter.__call__","title":"<code>__call__(record)</code>","text":"Source code in <code>roc/logger.py</code> <pre><code>def __call__(self, record: Any) -&gt; bool:\n    # TODO: this would be more effecient as a dict rather than a loop (O(1) rather than O(n))\n\n    if record[\"module\"] in self.module_levels:\n        mod_log_level = self.module_levels[record[\"module\"]]\n        mod_level_num = logger.level(mod_log_level).no\n        if record[\"level\"].no &gt;= mod_level_num:\n            return True\n        else:\n            return False\n\n    if record[\"level\"].no &gt;= self.level_num:\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/logger/#logger.LogFilter.__init__","title":"<code>__init__(*, level=None, log_modules=None, enabled=True, use_module_settings=True)</code>","text":"Source code in <code>roc/logger.py</code> <pre><code>def __init__(\n    self,\n    *,\n    level: str | None = None,\n    log_modules: str | None = None,\n    enabled: bool = True,\n    use_module_settings: bool = True,\n):\n    settings = Config.get()\n    self.level = level or settings.log_level\n    self.level_num = logger.level(self.level).no\n    if not isinstance(log_modules, str):\n        if use_module_settings:\n            log_modules = settings.log_modules\n        else:\n            log_modules = \"\"\n    mod_list = self.parse_module_str(log_modules)\n    self.module_levels = {mod_lvl.module_name: mod_lvl.log_level for mod_lvl in mod_list}\n</code></pre>"},{"location":"reference/logger/#logger.LogFilter.parse_module_str","title":"<code>parse_module_str(s)</code>  <code>classmethod</code>","text":"Source code in <code>roc/logger.py</code> <pre><code>@classmethod\ndef parse_module_str(cls, s: str) -&gt; list[DebugModuleLevel]:\n    s = s.strip()\n\n    mod_list = s.split(\";\")\n    # empty str\n    if mod_list == [\"\"]:\n        return []\n\n    mod_lvl_list: list[dict[str, str]] = []\n    for mod in mod_list:\n        mod_parts = mod.split(\":\")\n        mod_lvl_list.append({\"module_name\": mod_parts[0], \"log_level\": mod_parts[1]})\n\n    debug_module_list = TypeAdapter(list[DebugModuleLevel])\n    return debug_module_list.validate_python(mod_lvl_list)\n</code></pre>"},{"location":"reference/logger/#logger.init","title":"<code>init()</code>","text":"<p>Initializes the logging module. Installs the filter, fetches the settings, etc.</p> Source code in <code>roc/logger.py</code> <pre><code>def init() -&gt; None:\n    \"\"\"Initializes the logging module. Installs the filter, fetches the\n    settings, etc.\"\"\"\n\n    global default_log_filter\n    default_log_filter = LogFilter()\n\n    logger.remove()\n    settings = Config.get()\n    if settings.log_enable:\n        logger.add(sys.stderr, level=0, filter=default_log_filter)\n</code></pre>"},{"location":"reference/perception/","title":"perception","text":"<p>The Perception system breaks down the environment into features that can be re-assembled as concepts.</p>"},{"location":"reference/perception/#perception.Grid","title":"<code>Grid = tuple[tuple[int | str, ...], ...]</code>  <code>module-attribute</code>","text":""},{"location":"reference/perception/#perception.NONE_FEATURE","title":"<code>NONE_FEATURE: Feature = cast(Feature, NoneFeature())</code>  <code>module-attribute</code>","text":""},{"location":"reference/perception/#perception.PerceptionData","title":"<code>PerceptionData = VisionData | FeatureData</code>  <code>module-attribute</code>","text":""},{"location":"reference/perception/#perception.PerceptionEvent","title":"<code>PerceptionEvent = Event[PerceptionData]</code>  <code>module-attribute</code>","text":""},{"location":"reference/perception/#perception.Feature","title":"<code>Feature</code>","text":"<p>             Bases: <code>Hashable</code></p> <p>An abstract feature for communicating features that have been detected.</p> Source code in <code>roc/perception.py</code> <pre><code>class Feature(Hashable):\n    \"\"\"An abstract feature for communicating features that have been detected.\"\"\"\n\n    origin: Component\n\n    def __init__(self, origin: Component) -&gt; None:\n        self.origin = origin\n</code></pre>"},{"location":"reference/perception/#perception.Feature.origin","title":"<code>origin: Component = origin</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Feature.__init__","title":"<code>__init__(origin)</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __init__(self, origin: Component) -&gt; None:\n    self.origin = origin\n</code></pre>"},{"location":"reference/perception/#perception.FeatureData","title":"<code>FeatureData</code>  <code>dataclass</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@dataclass\nclass FeatureData:\n    feature: Feature\n</code></pre>"},{"location":"reference/perception/#perception.FeatureData.feature","title":"<code>feature: Feature</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.FeatureExtractor","title":"<code>FeatureExtractor</code>","text":"<p>             Bases: <code>Perception</code>, <code>ABC</code></p> Source code in <code>roc/perception.py</code> <pre><code>class FeatureExtractor(Perception, ABC):\n    def __init__(self) -&gt; None:\n        super().__init__()\n\n    def do_perception(self, e: PerceptionEvent) -&gt; None:\n        f = self.get_feature(e)\n        if f is None:\n            f = NONE_FEATURE\n\n        feature_data = FeatureData(feature=f)\n        self.pb_conn.send(feature_data)\n\n    @abstractmethod\n    def get_feature(self, e: PerceptionEvent) -&gt; Feature | None:\n        ...\n</code></pre>"},{"location":"reference/perception/#perception.FeatureExtractor.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n</code></pre>"},{"location":"reference/perception/#perception.FeatureExtractor.do_perception","title":"<code>do_perception(e)</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def do_perception(self, e: PerceptionEvent) -&gt; None:\n    f = self.get_feature(e)\n    if f is None:\n        f = NONE_FEATURE\n\n    feature_data = FeatureData(feature=f)\n    self.pb_conn.send(feature_data)\n</code></pre>"},{"location":"reference/perception/#perception.FeatureExtractor.get_feature","title":"<code>get_feature(e)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@abstractmethod\ndef get_feature(self, e: PerceptionEvent) -&gt; Feature | None:\n    ...\n</code></pre>"},{"location":"reference/perception/#perception.HashingNoneFeature","title":"<code>HashingNoneFeature</code>","text":"<p>             Bases: <code>Exception</code></p> Source code in <code>roc/perception.py</code> <pre><code>class HashingNoneFeature(Exception):\n    pass\n</code></pre>"},{"location":"reference/perception/#perception.NoneFeature","title":"<code>NoneFeature</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>class NoneFeature:\n    def __hash__(self) -&gt; int:\n        raise HashingNoneFeature(\"Attempting to hash None feature\")\n</code></pre>"},{"location":"reference/perception/#perception.NoneFeature.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __hash__(self) -&gt; int:\n    raise HashingNoneFeature(\"Attempting to hash None feature\")\n</code></pre>"},{"location":"reference/perception/#perception.Perception","title":"<code>Perception</code>","text":"<p>             Bases: <code>Component</code>, <code>ABC</code></p> <p>The abstract class for Perception components. Handles perception bus connections and corresponding clean-up.</p> Source code in <code>roc/perception.py</code> <pre><code>class Perception(Component, ABC):\n    \"\"\"The abstract class for Perception components. Handles perception bus\n    connections and corresponding clean-up.\"\"\"\n\n    bus = EventBus[PerceptionData](\"perception\")\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.pb_conn = self.connect_bus(Perception.bus)\n        self.pb_conn.listen(self.do_perception)\n\n    @abstractmethod\n    def do_perception(self, e: PerceptionEvent) -&gt; None:\n        ...\n\n    @classmethod\n    def init(cls) -&gt; None:\n        global perception_bus\n        cls.bus = EventBus[PerceptionData](\"perception\")\n</code></pre>"},{"location":"reference/perception/#perception.Perception.bus","title":"<code>bus = EventBus[PerceptionData]('perception')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Perception.pb_conn","title":"<code>pb_conn = self.connect_bus(Perception.bus)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Perception.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.pb_conn = self.connect_bus(Perception.bus)\n    self.pb_conn.listen(self.do_perception)\n</code></pre>"},{"location":"reference/perception/#perception.Perception.do_perception","title":"<code>do_perception(e)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@abstractmethod\ndef do_perception(self, e: PerceptionEvent) -&gt; None:\n    ...\n</code></pre>"},{"location":"reference/perception/#perception.Perception.init","title":"<code>init()</code>  <code>classmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@classmethod\ndef init(cls) -&gt; None:\n    global perception_bus\n    cls.bus = EventBus[PerceptionData](\"perception\")\n</code></pre>"},{"location":"reference/perception/#perception.VisionData","title":"<code>VisionData</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A Pydantic model for the vision perception data.</p> Source code in <code>roc/perception.py</code> <pre><code>class VisionData(BaseModel):\n    \"\"\"A Pydantic model for the vision perception data.\"\"\"\n\n    # spectrum: tuple[tuple[tuple[int | str, ...], ...], ...]\n    screen: Grid\n</code></pre>"},{"location":"reference/perception/#perception.VisionData.screen","title":"<code>screen: Grid</code>  <code>instance-attribute</code>","text":""},{"location":"reference/script/","title":"script","text":"<p>This is a Python script that runs the Gym and agent, typically from the command-line. See the Makefile for how to run this script.</p>"},{"location":"reference/script/#script.pp","title":"<code>pp = pprint.PrettyPrinter(width=41, compact=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/script/#script.ascii_list","title":"<code>ascii_list(al)</code>","text":"Source code in <code>roc/script.py</code> <pre><code>def ascii_list(al: list[int]) -&gt; str:\n    result_string = \"\"\n\n    for ascii_value in al:\n        result_string += chr(ascii_value)\n\n    return result_string\n</code></pre>"},{"location":"reference/script/#script.cli","title":"<code>cli(arg)</code>","text":"Source code in <code>roc/script.py</code> <pre><code>@click.command\n@click.option(\"--arg\", default=1)\ndef cli(arg: Any) -&gt; None:\n    roc.init()\n    roc.start()\n</code></pre>"},{"location":"reference/script/#script.int_list","title":"<code>int_list(al)</code>","text":"Source code in <code>roc/script.py</code> <pre><code>def int_list(al: list[int]) -&gt; str:\n    result_string = \"\"\n\n    for ascii_value in al:\n        result_string += str(ascii_value) + \" \"\n\n    return result_string\n</code></pre>"},{"location":"reference/script/#script.print_screen","title":"<code>print_screen(screen, *, as_int=False)</code>","text":"Source code in <code>roc/script.py</code> <pre><code>def print_screen(screen: list[list[int]], *, as_int: bool = False) -&gt; None:\n    for row in screen:\n        if not as_int:\n            print(ascii_list(row))\n        else:\n            print(int_list(row))\n</code></pre>"},{"location":"reference/feature_extractors/delta/","title":"delta","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DiffList","title":"<code>DiffList = list[Diff]</code>  <code>module-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Delta","title":"<code>Delta</code>","text":"<p>             Bases: <code>FeatureExtractor</code></p> <p>A component for detecting changes in vision.</p> Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>@register_component(\"delta\", \"perception\")\nclass Delta(FeatureExtractor):\n    \"\"\"A component for detecting changes in vision.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.prev_grid: Grid | None = None\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        return isinstance(e.data, VisionData)\n\n    def get_feature(self, e: PerceptionEvent) -&gt; Feature | None:\n        logger.debug(f\"got perception event {e}\")\n        # assert isinstance(e, VisionData)\n        # reveal_type(e)\n        # reveal_type(e.data)\n        data = e.data\n        assert isinstance(data, VisionData)\n\n        prev = self.prev_grid\n        self.prev_grid = curr = data.screen\n\n        if prev is None:\n            return None\n\n        # roughly make sure that things are the same height\n        assert len(prev) == len(curr)\n        assert len(prev[0]) == len(curr[0])\n\n        width = len(curr)\n        height = len(curr[0])\n        diff_list: DiffList = []\n        for x in range(width):\n            for y in range(height):\n                if prev[x][y] != curr[x][y]:\n                    diff_list.append(\n                        Diff(\n                            x=x,\n                            y=y,\n                            val1=prev[x][y],\n                            val2=curr[x][y],\n                        )\n                    )\n\n        return DeltaFeature(self, diff_list)\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Delta.prev_grid","title":"<code>prev_grid: Grid | None = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Delta.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.prev_grid: Grid | None = None\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Delta.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    return isinstance(e.data, VisionData)\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Delta.get_feature","title":"<code>get_feature(e)</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def get_feature(self, e: PerceptionEvent) -&gt; Feature | None:\n    logger.debug(f\"got perception event {e}\")\n    # assert isinstance(e, VisionData)\n    # reveal_type(e)\n    # reveal_type(e.data)\n    data = e.data\n    assert isinstance(data, VisionData)\n\n    prev = self.prev_grid\n    self.prev_grid = curr = data.screen\n\n    if prev is None:\n        return None\n\n    # roughly make sure that things are the same height\n    assert len(prev) == len(curr)\n    assert len(prev[0]) == len(curr[0])\n\n    width = len(curr)\n    height = len(curr[0])\n    diff_list: DiffList = []\n    for x in range(width):\n        for y in range(height):\n            if prev[x][y] != curr[x][y]:\n                diff_list.append(\n                    Diff(\n                        x=x,\n                        y=y,\n                        val1=prev[x][y],\n                        val2=curr[x][y],\n                    )\n                )\n\n    return DeltaFeature(self, diff_list)\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaFeature","title":"<code>DeltaFeature</code>","text":"<p>             Bases: <code>Feature</code></p> <p>A feature for representing vision changes (deltas)</p> Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>class DeltaFeature(Feature):\n    \"\"\"A feature for representing vision changes (deltas)\"\"\"\n\n    def __init__(self, origin: Component, diff_list: DiffList) -&gt; None:\n        super().__init__(origin)\n        self.diff_list = diff_list\n\n    def __hash__(self) -&gt; int:\n        raise NotImplementedError(\"DeltaFeature hash not implemented\")\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaFeature.diff_list","title":"<code>diff_list = diff_list</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaFeature.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def __hash__(self) -&gt; int:\n    raise NotImplementedError(\"DeltaFeature hash not implemented\")\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaFeature.__init__","title":"<code>__init__(origin, diff_list)</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def __init__(self, origin: Component, diff_list: DiffList) -&gt; None:\n    super().__init__(origin)\n    self.diff_list = diff_list\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Diff","title":"<code>Diff</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A Pydantic model for representing a changes in vision.</p> Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>class Diff(BaseModel):\n    \"\"\"A Pydantic model for representing a changes in vision.\"\"\"\n\n    x: int\n    y: int\n    val1: str | int\n    val2: str | int\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Diff.val1","title":"<code>val1: str | int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Diff.val2","title":"<code>val2: str | int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Diff.x","title":"<code>x: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Diff.y","title":"<code>y: int</code>  <code>instance-attribute</code>","text":""}]}