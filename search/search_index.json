{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Main","text":"<p>Reinforcement Learning of Concepts</p>"},{"location":"#roc.ActionData","title":"<code>ActionData = Annotated[ActionCount | ActionGo, Field(discriminator='type')]</code>  <code>module-attribute</code>","text":""},{"location":"#roc.PerceptionData","title":"<code>PerceptionData = VisionData | Settled | Feature</code>  <code>module-attribute</code>","text":""},{"location":"#roc.__all__","title":"<code>__all__ = ['Component', 'GymComponent', 'Perception', 'PerceptionData', 'action_bus', 'ActionData']</code>  <code>module-attribute</code>","text":""},{"location":"#roc.action_bus","title":"<code>action_bus = EventBus[ActionData]('action')</code>  <code>module-attribute</code>","text":""},{"location":"#roc.Component","title":"<code>Component</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract component class for building pieces of ROC that will talk to each other.</p> Source code in <code>roc/component.py</code> <pre><code>class Component(ABC):\n    \"\"\"An abstract component class for building pieces of ROC that will talk to each other.\"\"\"\n\n    name: str = \"&lt;name unassigned&gt;\"\n    type: str = \"&lt;type unassigned&gt;\"\n\n    def __init__(self) -&gt; None:\n        global component_set\n        component_set.add(self)\n        self.bus_conns: dict[str, BusConnection[Any]] = {}\n        logger.trace(f\"++ incrementing component count: {self.name}:{self.type} {self}\")\n        # traceback.print_stack()\n\n    def __del__(self) -&gt; None:\n        global component_set\n        component_set.add(self)\n        logger.trace(f\"-- decrementing component count: {self.name}:{self.type} {self}\")\n\n    def connect_bus(self, bus: EventBus[T]) -&gt; BusConnection[T]:\n        \"\"\"Create a new bus connection for the component, storing the result for\n        later shutdown.\n\n        Args:\n            bus (EventBus[T]): The event bus to attach to\n\n        Raises:\n            ValueError: if the bus has already been connected to by this component\n\n        Returns:\n            BusConnection[T]: The bus connection for listening or sending events\n        \"\"\"\n        if bus.name in self.bus_conns:\n            raise ValueError(\n                f\"Component '{self.name}' attempting duplicate connection to bus '{bus.name}'\"\n            )\n\n        conn = bus.connect(self)\n        self.bus_conns[bus.name] = conn\n        return conn\n\n    def event_filter(self, e: Event[Any]) -&gt; bool:\n        \"\"\"A filter for any incoming events. By default it filters out events\n        sent by itself, but it is especially useful for creating new filters in\n        sub-classes.\n\n        Args:\n            e (Event[Any]): The event to be evaluated\n\n        Returns:\n            bool: True if the event should be sent, False if it should be dropped\n        \"\"\"\n        return e.src is not self\n\n    def shutdown(self) -&gt; None:\n        \"\"\"De-initializes the component, removing any bus connections and any\n        other clean-up that needs to be performed\n        \"\"\"\n        logger.debug(f\"Component {self.name}:{self.type} shutting down.\")\n\n        for conn in self.bus_conns:\n            for obs in self.bus_conns[conn].attached_bus.subject.observers:\n                obs.on_completed()\n\n    @staticmethod\n    def init() -&gt; None:\n        \"\"\"Loads all components registered as `auto` and perception components\n        in the `perception_components` config field.\n        \"\"\"\n        settings = Config.get()\n        component_list = default_components\n        component_list = component_list.union(settings.perception_components)\n        logger.debug(f\"Component.init: default components: {component_list}\")\n\n        # TODO: shutdown previously loaded components\n\n        for reg_str in component_list:\n            logger.trace(f\"Loading component: {reg_str} ...\")\n            (name, type) = reg_str.split(\":\")\n            loaded_components[reg_str] = Component.get(name, type)\n\n    @classmethod\n    def get(cls, name: str, type: str, *args: Any, **kwargs: Any) -&gt; Self:\n        \"\"\"Retreives a component with the specified name from the registry and\n        creates a new version of it with the specified args. Used by\n        `Config.init` and for testing.\n\n        Args:\n            name (str): The name of the component to get, as specified during\n                its registration\n            type (str): The type of the component to get, as specified during\n                its registration\n            args (Any): Fixed position arguments to pass to the Component\n                constructor\n            kwargs (Any): Keyword args to pass to the Component constructor\n\n        Returns:\n            Self: the component that was created, casted as the calling class.\n            (e.g. `Perception.get(...)` will return a Perception component and\n            `Action.get(...)` will return an Action component)\n        \"\"\"\n        reg_str = _component_registry_key(name, type)\n        return cast(Self, component_registry[reg_str](*args, **kwargs))\n\n    @staticmethod\n    def get_component_count() -&gt; int:\n        \"\"\"Returns the number of currently created Components. The number goes\n        up on __init__ and down on __del__. Primarily used for testing to ensure\n        Components are being shutdown appropriately.\n\n        Returns:\n            int: The number of currently active Component instances\n        \"\"\"\n        # global component_count\n        # return component_count\n        global component_set\n        return len(component_set)\n\n    @staticmethod\n    def deregister(name: str, type: str) -&gt; None:\n        \"\"\"Removes a component from the Component registry. Primarlly used for testing.\n\n        Args:\n            name (str): The name of the Component to deregister\n            type (str): The type of the Component to deregister\n        \"\"\"\n        reg_str = _component_registry_key(name, type)\n        del component_registry[reg_str]\n\n    @staticmethod\n    def reset() -&gt; None:\n        \"\"\"Shuts down all components\"\"\"\n        # shutdown all components\n        global loaded_components\n        for name in loaded_components:\n            logger.trace(f\"Shutting down component: {name}.\")\n            c = loaded_components[name]\n            c.shutdown()\n\n        loaded_components.clear()\n\n        global component_set\n        for c in component_set:\n            c.shutdown()\n</code></pre>"},{"location":"#roc.Component.bus_conns","title":"<code>bus_conns: dict[str, BusConnection[Any]] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"#roc.Component.name","title":"<code>name: str = '&lt;name unassigned&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#roc.Component.type","title":"<code>type: str = '&lt;type unassigned&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#roc.Component.__del__","title":"<code>__del__()</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __del__(self) -&gt; None:\n    global component_set\n    component_set.add(self)\n    logger.trace(f\"-- decrementing component count: {self.name}:{self.type} {self}\")\n</code></pre>"},{"location":"#roc.Component.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __init__(self) -&gt; None:\n    global component_set\n    component_set.add(self)\n    self.bus_conns: dict[str, BusConnection[Any]] = {}\n    logger.trace(f\"++ incrementing component count: {self.name}:{self.type} {self}\")\n</code></pre>"},{"location":"#roc.Component.connect_bus","title":"<code>connect_bus(bus)</code>","text":"<p>Create a new bus connection for the component, storing the result for later shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>EventBus[T]</code> <p>The event bus to attach to</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the bus has already been connected to by this component</p> <p>Returns:</p> Type Description <code>BusConnection[T]</code> <p>BusConnection[T]: The bus connection for listening or sending events</p> Source code in <code>roc/component.py</code> <pre><code>def connect_bus(self, bus: EventBus[T]) -&gt; BusConnection[T]:\n    \"\"\"Create a new bus connection for the component, storing the result for\n    later shutdown.\n\n    Args:\n        bus (EventBus[T]): The event bus to attach to\n\n    Raises:\n        ValueError: if the bus has already been connected to by this component\n\n    Returns:\n        BusConnection[T]: The bus connection for listening or sending events\n    \"\"\"\n    if bus.name in self.bus_conns:\n        raise ValueError(\n            f\"Component '{self.name}' attempting duplicate connection to bus '{bus.name}'\"\n        )\n\n    conn = bus.connect(self)\n    self.bus_conns[bus.name] = conn\n    return conn\n</code></pre>"},{"location":"#roc.Component.deregister","title":"<code>deregister(name, type)</code>  <code>staticmethod</code>","text":"<p>Removes a component from the Component registry. Primarlly used for testing.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the Component to deregister</p> required <code>type</code> <code>str</code> <p>The type of the Component to deregister</p> required Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef deregister(name: str, type: str) -&gt; None:\n    \"\"\"Removes a component from the Component registry. Primarlly used for testing.\n\n    Args:\n        name (str): The name of the Component to deregister\n        type (str): The type of the Component to deregister\n    \"\"\"\n    reg_str = _component_registry_key(name, type)\n    del component_registry[reg_str]\n</code></pre>"},{"location":"#roc.Component.event_filter","title":"<code>event_filter(e)</code>","text":"<p>A filter for any incoming events. By default it filters out events sent by itself, but it is especially useful for creating new filters in sub-classes.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Event[Any]</code> <p>The event to be evaluated</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the event should be sent, False if it should be dropped</p> Source code in <code>roc/component.py</code> <pre><code>def event_filter(self, e: Event[Any]) -&gt; bool:\n    \"\"\"A filter for any incoming events. By default it filters out events\n    sent by itself, but it is especially useful for creating new filters in\n    sub-classes.\n\n    Args:\n        e (Event[Any]): The event to be evaluated\n\n    Returns:\n        bool: True if the event should be sent, False if it should be dropped\n    \"\"\"\n    return e.src is not self\n</code></pre>"},{"location":"#roc.Component.get","title":"<code>get(name, type, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Retreives a component with the specified name from the registry and creates a new version of it with the specified args. Used by <code>Config.init</code> and for testing.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the component to get, as specified during its registration</p> required <code>type</code> <code>str</code> <p>The type of the component to get, as specified during its registration</p> required <code>args</code> <code>Any</code> <p>Fixed position arguments to pass to the Component constructor</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>Keyword args to pass to the Component constructor</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the component that was created, casted as the calling class.</p> <code>Self</code> <p>(e.g. <code>Perception.get(...)</code> will return a Perception component and</p> <code>Self</code> <p><code>Action.get(...)</code> will return an Action component)</p> Source code in <code>roc/component.py</code> <pre><code>@classmethod\ndef get(cls, name: str, type: str, *args: Any, **kwargs: Any) -&gt; Self:\n    \"\"\"Retreives a component with the specified name from the registry and\n    creates a new version of it with the specified args. Used by\n    `Config.init` and for testing.\n\n    Args:\n        name (str): The name of the component to get, as specified during\n            its registration\n        type (str): The type of the component to get, as specified during\n            its registration\n        args (Any): Fixed position arguments to pass to the Component\n            constructor\n        kwargs (Any): Keyword args to pass to the Component constructor\n\n    Returns:\n        Self: the component that was created, casted as the calling class.\n        (e.g. `Perception.get(...)` will return a Perception component and\n        `Action.get(...)` will return an Action component)\n    \"\"\"\n    reg_str = _component_registry_key(name, type)\n    return cast(Self, component_registry[reg_str](*args, **kwargs))\n</code></pre>"},{"location":"#roc.Component.get_component_count","title":"<code>get_component_count()</code>  <code>staticmethod</code>","text":"<p>Returns the number of currently created Components. The number goes up on init and down on del. Primarily used for testing to ensure Components are being shutdown appropriately.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of currently active Component instances</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef get_component_count() -&gt; int:\n    \"\"\"Returns the number of currently created Components. The number goes\n    up on __init__ and down on __del__. Primarily used for testing to ensure\n    Components are being shutdown appropriately.\n\n    Returns:\n        int: The number of currently active Component instances\n    \"\"\"\n    # global component_count\n    # return component_count\n    global component_set\n    return len(component_set)\n</code></pre>"},{"location":"#roc.Component.init","title":"<code>init()</code>  <code>staticmethod</code>","text":"<p>Loads all components registered as <code>auto</code> and perception components in the <code>perception_components</code> config field.</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef init() -&gt; None:\n    \"\"\"Loads all components registered as `auto` and perception components\n    in the `perception_components` config field.\n    \"\"\"\n    settings = Config.get()\n    component_list = default_components\n    component_list = component_list.union(settings.perception_components)\n    logger.debug(f\"Component.init: default components: {component_list}\")\n\n    # TODO: shutdown previously loaded components\n\n    for reg_str in component_list:\n        logger.trace(f\"Loading component: {reg_str} ...\")\n        (name, type) = reg_str.split(\":\")\n        loaded_components[reg_str] = Component.get(name, type)\n</code></pre>"},{"location":"#roc.Component.reset","title":"<code>reset()</code>  <code>staticmethod</code>","text":"<p>Shuts down all components</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef reset() -&gt; None:\n    \"\"\"Shuts down all components\"\"\"\n    # shutdown all components\n    global loaded_components\n    for name in loaded_components:\n        logger.trace(f\"Shutting down component: {name}.\")\n        c = loaded_components[name]\n        c.shutdown()\n\n    loaded_components.clear()\n\n    global component_set\n    for c in component_set:\n        c.shutdown()\n</code></pre>"},{"location":"#roc.Component.shutdown","title":"<code>shutdown()</code>","text":"<p>De-initializes the component, removing any bus connections and any other clean-up that needs to be performed</p> Source code in <code>roc/component.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"De-initializes the component, removing any bus connections and any\n    other clean-up that needs to be performed\n    \"\"\"\n    logger.debug(f\"Component {self.name}:{self.type} shutting down.\")\n\n    for conn in self.bus_conns:\n        for obs in self.bus_conns[conn].attached_bus.subject.observers:\n            obs.on_completed()\n</code></pre>"},{"location":"#roc.Perception","title":"<code>Perception</code>","text":"<p>               Bases: <code>Component</code>, <code>ABC</code></p> <p>The abstract class for Perception components. Handles perception bus connections and corresponding clean-up.</p> Source code in <code>roc/perception.py</code> <pre><code>class Perception(Component, ABC):\n    \"\"\"The abstract class for Perception components. Handles perception bus\n    connections and corresponding clean-up.\n    \"\"\"\n\n    bus = EventBus[PerceptionData](\"perception\")\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.pb_conn = self.connect_bus(Perception.bus)\n        self.pb_conn.listen(self.do_perception)\n\n    @abstractmethod\n    def do_perception(self, e: PerceptionEvent) -&gt; None: ...\n\n    @classmethod\n    def init(cls) -&gt; None:\n        global perception_bus\n        cls.bus = EventBus[PerceptionData](\"perception\")\n</code></pre>"},{"location":"#roc.Perception.bus","title":"<code>bus = EventBus[PerceptionData]('perception')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#roc.Perception.pb_conn","title":"<code>pb_conn = self.connect_bus(Perception.bus)</code>  <code>instance-attribute</code>","text":""},{"location":"#roc.Perception.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.pb_conn = self.connect_bus(Perception.bus)\n    self.pb_conn.listen(self.do_perception)\n</code></pre>"},{"location":"#roc.Perception.do_perception","title":"<code>do_perception(e)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@abstractmethod\ndef do_perception(self, e: PerceptionEvent) -&gt; None: ...\n</code></pre>"},{"location":"#roc.Perception.init","title":"<code>init()</code>  <code>classmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@classmethod\ndef init(cls) -&gt; None:\n    global perception_bus\n    cls.bus = EventBus[PerceptionData](\"perception\")\n</code></pre>"},{"location":"#roc.init","title":"<code>init(config=None)</code>","text":"<p>Initializes the agent before starting the agent.</p> Source code in <code>roc/__init__.py</code> <pre><code>def init(config: dict[str, Any] | None = None) -&gt; None:\n    \"\"\"Initializes the agent before starting the agent.\"\"\"\n    Config.init(config)\n    roc_logger.init()\n    Component.init()\n    # Gym.init()\n    RocJupyterMagics.init()\n</code></pre>"},{"location":"#roc.start","title":"<code>start()</code>","text":"<p>Starts the agent.</p> Source code in <code>roc/__init__.py</code> <pre><code>def start() -&gt; None:\n    \"\"\"Starts the agent.\"\"\"\n    g = NethackGym()\n\n    if is_jupyter():\n        # if running in Jupyter, start in a thread so that we can still inspect\n        # or debug from the iPython shell\n        roc_logger.logger.debug(\"Starting ROC: running in thread\")\n        t = Thread(target=g.start)\n        t.start()\n    else:\n        roc_logger.logger.debug(\"Starting ROC: NOT running in thread\")\n        g.start()\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>action</li> <li>attention</li> <li>breakpoint</li> <li>component</li> <li>config</li> <li>event</li> <li>feature_extractors<ul> <li>delta</li> <li>distance</li> <li>flood</li> <li>line</li> <li>motion</li> <li>single</li> </ul> </li> <li>graphdb</li> <li>gymnasium</li> <li>intrinsic</li> <li>jupyter<ul> <li>brk</li> <li>cont</li> <li>roc</li> <li>save</li> <li>state</li> <li>step</li> <li>utils</li> </ul> </li> <li>location</li> <li>logger</li> <li>perception</li> <li>script</li> </ul>"},{"location":"reference/action/","title":"action","text":"<p>The action module decides what action the agent should perform.</p>"},{"location":"reference/action/#action.ActionData","title":"<code>ActionData = Annotated[ActionCount | ActionGo, Field(discriminator='type')]</code>  <code>module-attribute</code>","text":""},{"location":"reference/action/#action.ActionEvent","title":"<code>ActionEvent = Event[ActionData]</code>  <code>module-attribute</code>","text":""},{"location":"reference/action/#action.ActionFn","title":"<code>ActionFn = Callable[[], int]</code>  <code>module-attribute</code>","text":""},{"location":"reference/action/#action.action_bus","title":"<code>action_bus = EventBus[ActionData]('action')</code>  <code>module-attribute</code>","text":""},{"location":"reference/action/#action.default_action_registry","title":"<code>default_action_registry: dict[str, ActionFn] = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/action/#action.Action","title":"<code>Action</code>","text":"<p>               Bases: <code>Component</code></p> <p>Component for determining which action to take.</p> Source code in <code>roc/action.py</code> <pre><code>@register_component(\"action\", \"action\", auto=True)\nclass Action(Component):\n    \"\"\"Component for determining which action to take.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.action_bus_conn = self.connect_bus(action_bus)\n\n        # XXX: function because you can't type annotate an inline lambda\n        def count_filter(e: ActionEvent) -&gt; bool:\n            return e.data.type == \"action_count\"\n\n        def go_filter(e: ActionEvent) -&gt; bool:\n            return e.data.type == \"action_go\"\n\n        # self.action_bus_conn.subject.pipe(\n        #     op.filter(count_filter),\n        # ).subscribe(self.recv_action_count)\n        self.action_bus_conn.listen(\n            listener=self.recv_action_count,\n            filter=count_filter,\n        )\n        self.action_count: None | int = None\n\n    def recv_action_count(self, e: ActionEvent) -&gt; None:\n        if e.data.type != \"action_count\":\n            raise Exception(\"bad data received in recv_action_count\")\n\n        self.action_count = e.data.action_count\n</code></pre>"},{"location":"reference/action/#action.Action.action_bus_conn","title":"<code>action_bus_conn = self.connect_bus(action_bus)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.Action.action_count","title":"<code>action_count: None | int = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.Action.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/action.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.action_bus_conn = self.connect_bus(action_bus)\n\n    # XXX: function because you can't type annotate an inline lambda\n    def count_filter(e: ActionEvent) -&gt; bool:\n        return e.data.type == \"action_count\"\n\n    def go_filter(e: ActionEvent) -&gt; bool:\n        return e.data.type == \"action_go\"\n\n    # self.action_bus_conn.subject.pipe(\n    #     op.filter(count_filter),\n    # ).subscribe(self.recv_action_count)\n    self.action_bus_conn.listen(\n        listener=self.recv_action_count,\n        filter=count_filter,\n    )\n    self.action_count: None | int = None\n</code></pre>"},{"location":"reference/action/#action.Action.recv_action_count","title":"<code>recv_action_count(e)</code>","text":"Source code in <code>roc/action.py</code> <pre><code>def recv_action_count(self, e: ActionEvent) -&gt; None:\n    if e.data.type != \"action_count\":\n        raise Exception(\"bad data received in recv_action_count\")\n\n    self.action_count = e.data.action_count\n</code></pre>"},{"location":"reference/action/#action.ActionCount","title":"<code>ActionCount</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A Pydantic model for communicating the number of actions that can be taken.</p> Source code in <code>roc/action.py</code> <pre><code>class ActionCount(BaseModel):\n    \"\"\"A Pydantic model for communicating the number of actions that can be\n    taken.\n    \"\"\"\n\n    type: Literal[\"action_count\"] = \"action_count\"\n    action_count: int\n</code></pre>"},{"location":"reference/action/#action.ActionCount.action_count","title":"<code>action_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.ActionCount.type","title":"<code>type: Literal['action_count'] = 'action_count'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.ActionGo","title":"<code>ActionGo</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A Pydantic model for communicating that the Gym is waiting for the agent to take an action.</p> Source code in <code>roc/action.py</code> <pre><code>class ActionGo(BaseModel):\n    \"\"\"A Pydantic model for communicating that the Gym is waiting for the agent\n    to take an action.\n    \"\"\"\n\n    type: Literal[\"action_go\"] = \"action_go\"\n    go: bool\n</code></pre>"},{"location":"reference/action/#action.ActionGo.go","title":"<code>go: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.ActionGo.type","title":"<code>type: Literal['action_go'] = 'action_go'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.register_default_action","title":"<code>register_default_action</code>","text":"<p>Decorator for registering potential default actions. Default actions are set in the configuration.</p> Source code in <code>roc/action.py</code> <pre><code>class register_default_action:\n    \"\"\"Decorator for registering potential default actions. Default actions are\n    set in the configuration.\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        self.name = name\n\n    def __call__(self, fn: ActionFn) -&gt; ActionFn:\n        if self.name in default_action_registry:\n            raise ValueError(f\"Registering duplicate default action '{self.name}'\")\n\n        default_action_registry[self.name] = fn\n\n        return fn\n</code></pre>"},{"location":"reference/action/#action.register_default_action.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/action/#action.register_default_action.__call__","title":"<code>__call__(fn)</code>","text":"Source code in <code>roc/action.py</code> <pre><code>def __call__(self, fn: ActionFn) -&gt; ActionFn:\n    if self.name in default_action_registry:\n        raise ValueError(f\"Registering duplicate default action '{self.name}'\")\n\n    default_action_registry[self.name] = fn\n\n    return fn\n</code></pre>"},{"location":"reference/action/#action.register_default_action.__init__","title":"<code>__init__(name)</code>","text":"Source code in <code>roc/action.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    self.name = name\n</code></pre>"},{"location":"reference/action/#action.default_pass","title":"<code>default_pass()</code>","text":"<p>Default action for Nethack that passes (the <code>.</code> character in the game)</p> Source code in <code>roc/action.py</code> <pre><code>@register_default_action(\"pass\")\ndef default_pass() -&gt; int:\n    \"\"\"Default action for Nethack that passes (the `.` character in the game)\"\"\"\n    return 19\n</code></pre>"},{"location":"reference/action/#action.default_random","title":"<code>default_random()</code>","text":"<p>A default action for taking random Nethack actions.</p> Source code in <code>roc/action.py</code> <pre><code>@register_default_action(\"random\")\ndef default_random() -&gt; int:\n    \"\"\"A default action for taking random Nethack actions.\"\"\"\n    c = Action.get(\"action\", \"action\")\n    if c.action_count is None:\n        raise ValueError(\"Trying to get action before actions have been configured\")\n\n    return randrange(c.action_count)\n</code></pre>"},{"location":"reference/attention/","title":"attention","text":"<p>Aggregates all Perception events and determines which locations / objects should received focus</p>"},{"location":"reference/attention/#attention.AttentionData","title":"<code>AttentionData = VisionAttentionData</code>  <code>module-attribute</code>","text":""},{"location":"reference/attention/#attention.Attention","title":"<code>Attention</code>","text":"<p>               Bases: <code>Component</code>, <code>ABC</code></p> Source code in <code>roc/attention.py</code> <pre><code>class Attention(Component, ABC):\n    bus = EventBus[AttentionData](\"attention\")\n    pass\n</code></pre>"},{"location":"reference/attention/#attention.Attention.bus","title":"<code>bus = EventBus[AttentionData]('attention')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.CrossModalAttention","title":"<code>CrossModalAttention</code>","text":"<p>               Bases: <code>Attention</code></p> Source code in <code>roc/attention.py</code> <pre><code>class CrossModalAttention(Attention):\n    # TODO: listen for attention events\n    # TODO: select and emit a single event\n    pass\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap","title":"<code>SaliencyMap</code>","text":"<p>               Bases: <code>NewGrid[list[Node]]</code></p> Source code in <code>roc/attention.py</code> <pre><code>class SaliencyMap(NewGrid[list[Node]]):\n    grid: IntGrid\n\n    def __new__(cls, grid: IntGrid) -&gt; Self:\n        width = grid.width\n        height = grid.height\n        # map: list[list[list[Node]]] = [[list() for col in range(width)] for row in range(height)]\n        # print(\"map\", map)\n        # obj = np.array(map).reshape((height, width)).view(SaliencyMap)\n        obj = np.ndarray((height, width), dtype=object).view(cls)\n        for row, col in np.ndindex((height, width)):\n            obj[row, col] = list()\n        obj.grid = grid\n        return obj\n\n    def __array_finalize__(self, obj: npt.NDArray[Any] | None) -&gt; None:\n        if obj is None:\n            return\n\n        # obj.grid = getattr(obj, \"grid\", None)\n\n    def clear(self) -&gt; None:\n        \"\"\"Clears out all values from the SaliencyMap.\"\"\"\n        for row, col in np.ndindex(self.shape):\n            self[row, col].clear()\n\n    @property\n    def size(self) -&gt; int:\n        sz = 0\n        for val in self:\n            sz = sz + len(val)\n\n        return sz\n\n    def add_val(self, x: int, y: int, val: Node) -&gt; None:\n        node_list = self.get_val(x, y)\n        node_list.append(val)\n\n    def get_max_strength(self) -&gt; int:\n        max = 0\n        for y in range(self.height):\n            for x in range(self.width):\n                curr = self.get_strength(x, y)\n                if max &lt; curr:\n                    max = curr\n\n        return max\n\n    def get_strength(self, x: int, y: int) -&gt; int:\n        node_list = self.get_val(x, y)\n        # TODO: not really sure that the strength should depend on the number of features\n        ret = len(node_list)\n\n        def add_strength(n: Node) -&gt; None:\n            nonlocal ret\n\n            # TODO: this is pretty arbitrary and might be biased based on my\n            # domain knowledge... I suspect I will come back and modify this\n            # based on object recognition and other factors at some point in\n            # the future\n            if \"Single\" in n.labels:\n                ret += 10\n            if \"Delta\" in n.labels:\n                ret += 15\n            if \"Motion\" in n.labels:\n                ret += 20\n\n        for n in node_list:\n            Node.walk(n, node_callback=add_strength, mode=\"dst\")\n\n        return ret\n\n    def get_focus(self) -&gt; None:\n        max_str = self.get_max_strength()\n        fkimg = np.array(\n            [\n                [self.get_strength(x, y) / max_str for y in range(self.height)]\n                for x in range(self.width)\n            ]\n        )\n\n        m = np.median(fkimg)\n        # print(\"fkimg\", fkimg[15:18, 4:7])\n        coordinates = peak_local_max(fkimg, min_distance=5, threshold_rel=m)\n        # print(\"coordinates\", coordinates)\n\n        for loc in coordinates:\n            # print(\"loc\", loc)\n            x = loc[0]\n            y = loc[1]\n            p = self.grid.get_point(x, y)\n            print(\"p\", p)  # noqa: T201\n\n        # return []\n\n    def __str__(self) -&gt; str:\n        dg = DebugGrid(self.grid)\n        max_str = self.get_max_strength()\n        for p in self.grid.points():\n            rel_strength = self.get_strength(p.x, p.y) / max_str\n            color = DebugGrid.blue_to_red_hue(rel_strength)\n            dg.set_style(p.x, p.y, back_brightness=1, back_hue=color)\n        return str(dg)\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.grid","title":"<code>grid: IntGrid</code>  <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.SaliencyMap.size","title":"<code>size: int</code>  <code>property</code>","text":""},{"location":"reference/attention/#attention.SaliencyMap.__array_finalize__","title":"<code>__array_finalize__(obj)</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def __array_finalize__(self, obj: npt.NDArray[Any] | None) -&gt; None:\n    if obj is None:\n        return\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.__new__","title":"<code>__new__(grid)</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def __new__(cls, grid: IntGrid) -&gt; Self:\n    width = grid.width\n    height = grid.height\n    # map: list[list[list[Node]]] = [[list() for col in range(width)] for row in range(height)]\n    # print(\"map\", map)\n    # obj = np.array(map).reshape((height, width)).view(SaliencyMap)\n    obj = np.ndarray((height, width), dtype=object).view(cls)\n    for row, col in np.ndindex((height, width)):\n        obj[row, col] = list()\n    obj.grid = grid\n    return obj\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def __str__(self) -&gt; str:\n    dg = DebugGrid(self.grid)\n    max_str = self.get_max_strength()\n    for p in self.grid.points():\n        rel_strength = self.get_strength(p.x, p.y) / max_str\n        color = DebugGrid.blue_to_red_hue(rel_strength)\n        dg.set_style(p.x, p.y, back_brightness=1, back_hue=color)\n    return str(dg)\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.add_val","title":"<code>add_val(x, y, val)</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def add_val(self, x: int, y: int, val: Node) -&gt; None:\n    node_list = self.get_val(x, y)\n    node_list.append(val)\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.clear","title":"<code>clear()</code>","text":"<p>Clears out all values from the SaliencyMap.</p> Source code in <code>roc/attention.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clears out all values from the SaliencyMap.\"\"\"\n    for row, col in np.ndindex(self.shape):\n        self[row, col].clear()\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.get_focus","title":"<code>get_focus()</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def get_focus(self) -&gt; None:\n    max_str = self.get_max_strength()\n    fkimg = np.array(\n        [\n            [self.get_strength(x, y) / max_str for y in range(self.height)]\n            for x in range(self.width)\n        ]\n    )\n\n    m = np.median(fkimg)\n    # print(\"fkimg\", fkimg[15:18, 4:7])\n    coordinates = peak_local_max(fkimg, min_distance=5, threshold_rel=m)\n    # print(\"coordinates\", coordinates)\n\n    for loc in coordinates:\n        # print(\"loc\", loc)\n        x = loc[0]\n        y = loc[1]\n        p = self.grid.get_point(x, y)\n        print(\"p\", p)  # noqa: T201\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.get_max_strength","title":"<code>get_max_strength()</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def get_max_strength(self) -&gt; int:\n    max = 0\n    for y in range(self.height):\n        for x in range(self.width):\n            curr = self.get_strength(x, y)\n            if max &lt; curr:\n                max = curr\n\n    return max\n</code></pre>"},{"location":"reference/attention/#attention.SaliencyMap.get_strength","title":"<code>get_strength(x, y)</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def get_strength(self, x: int, y: int) -&gt; int:\n    node_list = self.get_val(x, y)\n    # TODO: not really sure that the strength should depend on the number of features\n    ret = len(node_list)\n\n    def add_strength(n: Node) -&gt; None:\n        nonlocal ret\n\n        # TODO: this is pretty arbitrary and might be biased based on my\n        # domain knowledge... I suspect I will come back and modify this\n        # based on object recognition and other factors at some point in\n        # the future\n        if \"Single\" in n.labels:\n            ret += 10\n        if \"Delta\" in n.labels:\n            ret += 15\n        if \"Motion\" in n.labels:\n            ret += 20\n\n    for n in node_list:\n        Node.walk(n, node_callback=add_strength, mode=\"dst\")\n\n    return ret\n</code></pre>"},{"location":"reference/attention/#attention.VisionAttention","title":"<code>VisionAttention</code>","text":"<p>               Bases: <code>Attention</code></p> Source code in <code>roc/attention.py</code> <pre><code>@register_component(\"vision\", \"attention\")\nclass VisionAttention(Attention):\n    saliency_map: SaliencyMap | None\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.pb_conn = self.connect_bus(Perception.bus)\n        self.pb_conn.listen(self.do_attention)\n        self.att_conn = self.connect_bus(Attention.bus)\n        self.saliency_map: SaliencyMap | None = None\n        self.settled: set[str] = set()\n\n    # def get_all_feature_extractors(self) -&gt; list[FeatureExtractor]:\n    #     self.pb_conn.attached_bus\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        # print(\"attention.event_filter\", e)\n        allow = (\n            isinstance(e.data, Feature)\n            or isinstance(e.data, Settled)\n            or isinstance(e.data, VisionData)\n        )\n        # print(\"attention.event_filter passing:\", allow)\n        return allow\n\n    def do_attention(self, e: PerceptionEvent) -&gt; None:\n        # create right-sized SaliencyMap based on VisionData\n        if isinstance(e.data, VisionData):\n            grid = IntGrid(e.data.chars)\n            if self.saliency_map is None:\n                self.saliency_map = SaliencyMap(grid)\n            else:\n                self.saliency_map.grid = grid\n            return\n\n        # check to see if all feature extractors have settled\n        if isinstance(e.data, Settled):\n            self.settled.add(f\"{e.src.name}:{e.src.type}\")\n\n            unsettled = set(FeatureExtractor.list()) - self.settled\n            if len(unsettled) == 0:\n                # self.att_conn.send(Settled())\n                self.settled.clear()\n                assert self.saliency_map is not None\n                self.saliency_map.get_focus()\n                # print(\"done!\")\n                # self.saliency_map.clear()\n\n            return\n\n        # register each location in the saliency map\n        assert isinstance(e.data, Node)\n        f = e.data\n\n        def try_add_loc(n: Node) -&gt; None:\n            if isinstance(n, ElementPoint):\n                assert self.saliency_map is not None\n                self.saliency_map.add_val(n.x, n.y, n)\n\n        # create saliency map\n        Node.walk(f, node_callback=try_add_loc)\n</code></pre>"},{"location":"reference/attention/#attention.VisionAttention.att_conn","title":"<code>att_conn = self.connect_bus(Attention.bus)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.VisionAttention.pb_conn","title":"<code>pb_conn = self.connect_bus(Perception.bus)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.VisionAttention.saliency_map","title":"<code>saliency_map: SaliencyMap | None = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.VisionAttention.settled","title":"<code>settled: set[str] = set()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/attention/#attention.VisionAttention.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.pb_conn = self.connect_bus(Perception.bus)\n    self.pb_conn.listen(self.do_attention)\n    self.att_conn = self.connect_bus(Attention.bus)\n    self.saliency_map: SaliencyMap | None = None\n    self.settled: set[str] = set()\n</code></pre>"},{"location":"reference/attention/#attention.VisionAttention.do_attention","title":"<code>do_attention(e)</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def do_attention(self, e: PerceptionEvent) -&gt; None:\n    # create right-sized SaliencyMap based on VisionData\n    if isinstance(e.data, VisionData):\n        grid = IntGrid(e.data.chars)\n        if self.saliency_map is None:\n            self.saliency_map = SaliencyMap(grid)\n        else:\n            self.saliency_map.grid = grid\n        return\n\n    # check to see if all feature extractors have settled\n    if isinstance(e.data, Settled):\n        self.settled.add(f\"{e.src.name}:{e.src.type}\")\n\n        unsettled = set(FeatureExtractor.list()) - self.settled\n        if len(unsettled) == 0:\n            # self.att_conn.send(Settled())\n            self.settled.clear()\n            assert self.saliency_map is not None\n            self.saliency_map.get_focus()\n            # print(\"done!\")\n            # self.saliency_map.clear()\n\n        return\n\n    # register each location in the saliency map\n    assert isinstance(e.data, Node)\n    f = e.data\n\n    def try_add_loc(n: Node) -&gt; None:\n        if isinstance(n, ElementPoint):\n            assert self.saliency_map is not None\n            self.saliency_map.add_val(n.x, n.y, n)\n\n    # create saliency map\n    Node.walk(f, node_callback=try_add_loc)\n</code></pre>"},{"location":"reference/attention/#attention.VisionAttention.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/attention.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    # print(\"attention.event_filter\", e)\n    allow = (\n        isinstance(e.data, Feature)\n        or isinstance(e.data, Settled)\n        or isinstance(e.data, VisionData)\n    )\n    # print(\"attention.event_filter passing:\", allow)\n    return allow\n</code></pre>"},{"location":"reference/attention/#attention.VisionAttentionData","title":"<code>VisionAttentionData</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>roc/attention.py</code> <pre><code>class VisionAttentionData(BaseModel):\n    foo: str\n</code></pre>"},{"location":"reference/attention/#attention.VisionAttentionData.foo","title":"<code>foo: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/breakpoint/","title":"breakpoint","text":"<p>Execution control for ROC, primarily used in Jupyter notebooks</p>"},{"location":"reference/breakpoint/#breakpoint.ConditionFn","title":"<code>ConditionFn: TypeAlias = Callable[[], bool]</code>  <code>module-attribute</code>","text":""},{"location":"reference/breakpoint/#breakpoint.breakpoints","title":"<code>breakpoints = Breakpoint()</code>  <code>module-attribute</code>","text":""},{"location":"reference/breakpoint/#breakpoint.Breakpoint","title":"<code>Breakpoint</code>","text":"<p>Controls the state of breakpoints and program execution. This should probably be renamed to <code>BreakpointControl</code>. :)</p> Source code in <code>roc/breakpoint.py</code> <pre><code>class Breakpoint:\n    \"\"\"Controls the state of breakpoints and program execution. This should\n    probably be renamed to `BreakpointControl`. :)\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.brk = False\n        self.trigger: str | None = None\n        self.lock = Lock()\n\n    def __len__(self) -&gt; int:\n        global _breakpoints_dict\n\n        return len(_breakpoints_dict)\n\n    def __contains__(self, key: str) -&gt; bool:\n        global _breakpoints_dict\n\n        return key in _breakpoints_dict\n\n    def __str__(self) -&gt; str:\n        global _breakpoints_dict\n\n        def mkrow(k: str) -&gt; list[str | bool]:\n            fn = _breakpoints_dict[k].fn\n            src = _breakpoints_dict[k].src\n            if not src:\n                filename = inspect.getfile(fn).split(os.path.sep)[-1]\n                line = inspect.getsourcelines(fn)[1]\n                src = f\"{filename}:{line}\"\n            triggered = \" \" if (self.trigger is None or self.trigger != k) else \"*\"\n            return [triggered, k, src]\n\n        rows = map(mkrow, _breakpoints_dict.keys())\n\n        hdr = f\"{self.count} breakpoint(s). State: {self.state}.\"\n        tbl = (\n            \"\"\n            if self.count == 0\n            else \"\\n\\n\"\n            + tabulate(\n                rows, headers=[\" \", \"Breakpoints\", \"Source\"], showindex=\"always\", tablefmt=\"simple\"\n            )\n        )\n\n        return f\"{hdr}{tbl}\"\n\n    def add(\n        self,\n        fn: ConditionFn,\n        *,\n        name: str | None = None,\n        overwrite: Optional[bool] = False,\n        src: str | None = None,\n    ) -&gt; None:\n        \"\"\"Adds a new breakpoint\n\n        Args:\n            fn (ConditionFn): A function that returns True when program\n                execution should stop\n            name (str | None, optional): The name of this breakpoint. Defaults\n                to the __name__ of the specified function, or '&lt;unknown&gt;' if name\n                isn't specified and __name__ doesn't exist.\n            overwrite (bool, optional): If True, this will overwrite existing\n                breakpoints with the same name. Defaults to False.\n            src (str | None, optional): The source / sourcecode for the\n                breakpoint. If not specified, it will use the file and line\n                number of the specified function. Mostly used by the Jupyter\n                shell to pass in 'iPython' as the source for functions defined\n                in Jupyter, because knowing that the function is stored in a\n                tempfile isn't especially helpful.\n\n        Raises:\n            Exception: Raises an exception if the specified breakpoint name\n            already exists and overwrite is False.\n        \"\"\"\n        global _breakpoints_dict\n\n        if not name and hasattr(fn, \"__name__\"):\n            name = fn.__name__\n\n        if not name:\n            name = \"&lt;unknown&gt;\"\n\n        if name in _breakpoints_dict and not overwrite:\n            raise Exception(\n                f\"'{name}' already exists in breakpoints, call 'remove' first or specify 'overwrite=True' while adding\"\n            )\n\n        _breakpoints_dict[name] = BreakpointInfo(fn=fn, src=src)\n\n    def remove(self, name: str) -&gt; None:\n        \"\"\"Removes the breakpoint with the specified name\n\n        Args:\n            name (str): The name of the breakpoint to remove\n\n        Raises:\n            Exception: If the specified breakpoint doesn't exist\n        \"\"\"\n        global _breakpoints_dict\n\n        if name not in _breakpoints_dict:\n            raise Exception(f\"can't remove '{name}' from breakpoints because it doesn't exist\")\n\n        del _breakpoints_dict[name]\n\n    def clear(self) -&gt; None:\n        \"\"\"Removes all breakpoints\"\"\"\n        global _breakpoints_dict\n\n        _breakpoints_dict.clear()\n\n    @property\n    def count(self) -&gt; int:\n        \"\"\"The number of breakpoints that have been added.\"\"\"\n        return len(self)\n\n    @property\n    def state(self) -&gt; str:\n        \"\"\"The state of execution, either 'stopped' or 'running'\"\"\"\n        return \"stopped\" if self.brk else \"running\"\n\n    def list(self) -&gt; None:\n        \"\"\"Prints all current breakpoints and the state of execution\"\"\"\n        print(str(self))  # noqa: T201\n\n    def resume(self, quiet: Optional[bool] = False) -&gt; None:\n        \"\"\"If execution is currently stopped, this will resume execution. If not\n        stopped, this does nothing.\n\n        Args:\n            quiet (bool, optional): If True, this function won't log status\n                messages about resuming. Defaults to False.\n        \"\"\"\n        if not self.brk:\n            return\n\n        self.brk = False\n        self.trigger = None\n        self.lock.release()\n\n        if not quiet:\n            logger.info(\"resuming\")\n\n    def do_break(\n        self, trigger: Optional[str] = \"&lt;user request&gt;\", quiet: Optional[bool] = False\n    ) -&gt; None:\n        \"\"\"Sets the state of execution to 'stopped' and blocks further execution\n        until `resume` is called. This is typically called by `check` inside the\n        program, but may be called directly (e.g. by a Jupyter magic command) to\n        manually stop execution.\n\n        Args:\n            trigger (str, optional): The name of the breakpoint that caused the\n                break. Defaults to \"&lt;user request&gt;\".\n            quiet (bool, optional): If True, this function won't log status\n                messages about resuming. Defaults to False.\n        \"\"\"\n        if self.brk:\n            return\n\n        self.brk = True\n        self.trigger = trigger\n\n        if not quiet:\n            logger.info(f\"breaking due to: {trigger}\")\n\n        self.lock.acquire()\n\n    def check(self) -&gt; None:\n        \"\"\"Checks whether any breakpoints are currently triggered by calling the\n        functions that were submitted by `add`. If / when the first function\n        returns True, program execution stops and will only resume when `resume`\n        is called.\n\n        This function is intended to be included in a execution loop or any\n        place you want to check for breakpoints before continuing to execute code.\n        \"\"\"\n        global _breakpoints_dict\n\n        waslocked = False\n        if self.lock.locked():\n            waslocked = True\n\n        # stop here if we are in a break\n        with self.lock:\n            # if we were stopped and are continuing now, don't immediately stop\n            # again due to another breakpoint\n            if not waslocked:\n                for b in _breakpoints_dict:\n                    if _breakpoints_dict[b].fn():\n                        self.do_break(trigger=b)\n                        waslocked = True\n                        break\n\n        if waslocked:\n            logger.info(\"break done, continuing operations...\")\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.brk","title":"<code>brk = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/breakpoint/#breakpoint.Breakpoint.count","title":"<code>count: int</code>  <code>property</code>","text":"<p>The number of breakpoints that have been added.</p>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.lock","title":"<code>lock = Lock()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/breakpoint/#breakpoint.Breakpoint.state","title":"<code>state: str</code>  <code>property</code>","text":"<p>The state of execution, either 'stopped' or 'running'</p>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.trigger","title":"<code>trigger: str | None = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/breakpoint/#breakpoint.Breakpoint.__contains__","title":"<code>__contains__(key)</code>","text":"Source code in <code>roc/breakpoint.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n    global _breakpoints_dict\n\n    return key in _breakpoints_dict\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/breakpoint.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.brk = False\n    self.trigger: str | None = None\n    self.lock = Lock()\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.__len__","title":"<code>__len__()</code>","text":"Source code in <code>roc/breakpoint.py</code> <pre><code>def __len__(self) -&gt; int:\n    global _breakpoints_dict\n\n    return len(_breakpoints_dict)\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/breakpoint.py</code> <pre><code>def __str__(self) -&gt; str:\n    global _breakpoints_dict\n\n    def mkrow(k: str) -&gt; list[str | bool]:\n        fn = _breakpoints_dict[k].fn\n        src = _breakpoints_dict[k].src\n        if not src:\n            filename = inspect.getfile(fn).split(os.path.sep)[-1]\n            line = inspect.getsourcelines(fn)[1]\n            src = f\"{filename}:{line}\"\n        triggered = \" \" if (self.trigger is None or self.trigger != k) else \"*\"\n        return [triggered, k, src]\n\n    rows = map(mkrow, _breakpoints_dict.keys())\n\n    hdr = f\"{self.count} breakpoint(s). State: {self.state}.\"\n    tbl = (\n        \"\"\n        if self.count == 0\n        else \"\\n\\n\"\n        + tabulate(\n            rows, headers=[\" \", \"Breakpoints\", \"Source\"], showindex=\"always\", tablefmt=\"simple\"\n        )\n    )\n\n    return f\"{hdr}{tbl}\"\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.add","title":"<code>add(fn, *, name=None, overwrite=False, src=None)</code>","text":"<p>Adds a new breakpoint</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>ConditionFn</code> <p>A function that returns True when program execution should stop</p> required <code>name</code> <code>str | None</code> <p>The name of this breakpoint. Defaults to the name of the specified function, or '' if name isn't specified and name doesn't exist. <code>None</code> <code>overwrite</code> <code>bool</code> <p>If True, this will overwrite existing breakpoints with the same name. Defaults to False.</p> <code>False</code> <code>src</code> <code>str | None</code> <p>The source / sourcecode for the breakpoint. If not specified, it will use the file and line number of the specified function. Mostly used by the Jupyter shell to pass in 'iPython' as the source for functions defined in Jupyter, because knowing that the function is stored in a tempfile isn't especially helpful.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Raises an exception if the specified breakpoint name</p> Source code in <code>roc/breakpoint.py</code> <pre><code>def add(\n    self,\n    fn: ConditionFn,\n    *,\n    name: str | None = None,\n    overwrite: Optional[bool] = False,\n    src: str | None = None,\n) -&gt; None:\n    \"\"\"Adds a new breakpoint\n\n    Args:\n        fn (ConditionFn): A function that returns True when program\n            execution should stop\n        name (str | None, optional): The name of this breakpoint. Defaults\n            to the __name__ of the specified function, or '&lt;unknown&gt;' if name\n            isn't specified and __name__ doesn't exist.\n        overwrite (bool, optional): If True, this will overwrite existing\n            breakpoints with the same name. Defaults to False.\n        src (str | None, optional): The source / sourcecode for the\n            breakpoint. If not specified, it will use the file and line\n            number of the specified function. Mostly used by the Jupyter\n            shell to pass in 'iPython' as the source for functions defined\n            in Jupyter, because knowing that the function is stored in a\n            tempfile isn't especially helpful.\n\n    Raises:\n        Exception: Raises an exception if the specified breakpoint name\n        already exists and overwrite is False.\n    \"\"\"\n    global _breakpoints_dict\n\n    if not name and hasattr(fn, \"__name__\"):\n        name = fn.__name__\n\n    if not name:\n        name = \"&lt;unknown&gt;\"\n\n    if name in _breakpoints_dict and not overwrite:\n        raise Exception(\n            f\"'{name}' already exists in breakpoints, call 'remove' first or specify 'overwrite=True' while adding\"\n        )\n\n    _breakpoints_dict[name] = BreakpointInfo(fn=fn, src=src)\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.check","title":"<code>check()</code>","text":"<p>Checks whether any breakpoints are currently triggered by calling the functions that were submitted by <code>add</code>. If / when the first function returns True, program execution stops and will only resume when <code>resume</code> is called.</p> <p>This function is intended to be included in a execution loop or any place you want to check for breakpoints before continuing to execute code.</p> Source code in <code>roc/breakpoint.py</code> <pre><code>def check(self) -&gt; None:\n    \"\"\"Checks whether any breakpoints are currently triggered by calling the\n    functions that were submitted by `add`. If / when the first function\n    returns True, program execution stops and will only resume when `resume`\n    is called.\n\n    This function is intended to be included in a execution loop or any\n    place you want to check for breakpoints before continuing to execute code.\n    \"\"\"\n    global _breakpoints_dict\n\n    waslocked = False\n    if self.lock.locked():\n        waslocked = True\n\n    # stop here if we are in a break\n    with self.lock:\n        # if we were stopped and are continuing now, don't immediately stop\n        # again due to another breakpoint\n        if not waslocked:\n            for b in _breakpoints_dict:\n                if _breakpoints_dict[b].fn():\n                    self.do_break(trigger=b)\n                    waslocked = True\n                    break\n\n    if waslocked:\n        logger.info(\"break done, continuing operations...\")\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.clear","title":"<code>clear()</code>","text":"<p>Removes all breakpoints</p> Source code in <code>roc/breakpoint.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Removes all breakpoints\"\"\"\n    global _breakpoints_dict\n\n    _breakpoints_dict.clear()\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.do_break","title":"<code>do_break(trigger='&lt;user request&gt;', quiet=False)</code>","text":"<p>Sets the state of execution to 'stopped' and blocks further execution until <code>resume</code> is called. This is typically called by <code>check</code> inside the program, but may be called directly (e.g. by a Jupyter magic command) to manually stop execution.</p> <p>Parameters:</p> Name Type Description Default <code>trigger</code> <code>str</code> <p>The name of the breakpoint that caused the break. Defaults to \"\". <code>'&lt;user request&gt;'</code> <code>quiet</code> <code>bool</code> <p>If True, this function won't log status messages about resuming. Defaults to False.</p> <code>False</code> Source code in <code>roc/breakpoint.py</code> <pre><code>def do_break(\n    self, trigger: Optional[str] = \"&lt;user request&gt;\", quiet: Optional[bool] = False\n) -&gt; None:\n    \"\"\"Sets the state of execution to 'stopped' and blocks further execution\n    until `resume` is called. This is typically called by `check` inside the\n    program, but may be called directly (e.g. by a Jupyter magic command) to\n    manually stop execution.\n\n    Args:\n        trigger (str, optional): The name of the breakpoint that caused the\n            break. Defaults to \"&lt;user request&gt;\".\n        quiet (bool, optional): If True, this function won't log status\n            messages about resuming. Defaults to False.\n    \"\"\"\n    if self.brk:\n        return\n\n    self.brk = True\n    self.trigger = trigger\n\n    if not quiet:\n        logger.info(f\"breaking due to: {trigger}\")\n\n    self.lock.acquire()\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.list","title":"<code>list()</code>","text":"<p>Prints all current breakpoints and the state of execution</p> Source code in <code>roc/breakpoint.py</code> <pre><code>def list(self) -&gt; None:\n    \"\"\"Prints all current breakpoints and the state of execution\"\"\"\n    print(str(self))  # noqa: T201\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.remove","title":"<code>remove(name)</code>","text":"<p>Removes the breakpoint with the specified name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the breakpoint to remove</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the specified breakpoint doesn't exist</p> Source code in <code>roc/breakpoint.py</code> <pre><code>def remove(self, name: str) -&gt; None:\n    \"\"\"Removes the breakpoint with the specified name\n\n    Args:\n        name (str): The name of the breakpoint to remove\n\n    Raises:\n        Exception: If the specified breakpoint doesn't exist\n    \"\"\"\n    global _breakpoints_dict\n\n    if name not in _breakpoints_dict:\n        raise Exception(f\"can't remove '{name}' from breakpoints because it doesn't exist\")\n\n    del _breakpoints_dict[name]\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.Breakpoint.resume","title":"<code>resume(quiet=False)</code>","text":"<p>If execution is currently stopped, this will resume execution. If not stopped, this does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>quiet</code> <code>bool</code> <p>If True, this function won't log status messages about resuming. Defaults to False.</p> <code>False</code> Source code in <code>roc/breakpoint.py</code> <pre><code>def resume(self, quiet: Optional[bool] = False) -&gt; None:\n    \"\"\"If execution is currently stopped, this will resume execution. If not\n    stopped, this does nothing.\n\n    Args:\n        quiet (bool, optional): If True, this function won't log status\n            messages about resuming. Defaults to False.\n    \"\"\"\n    if not self.brk:\n        return\n\n    self.brk = False\n    self.trigger = None\n    self.lock.release()\n\n    if not quiet:\n        logger.info(\"resuming\")\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.BreakpointInfo","title":"<code>BreakpointInfo</code>  <code>dataclass</code>","text":"<p>Information about a specific breakpoint</p> Source code in <code>roc/breakpoint.py</code> <pre><code>@dataclass\nclass BreakpointInfo:\n    \"\"\"Information about a specific breakpoint\"\"\"\n\n    fn: ConditionFn\n    src: str | None\n</code></pre>"},{"location":"reference/breakpoint/#breakpoint.BreakpointInfo.fn","title":"<code>fn: ConditionFn</code>  <code>instance-attribute</code>","text":""},{"location":"reference/breakpoint/#breakpoint.BreakpointInfo.src","title":"<code>src: str | None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/breakpoint/#breakpoint.BreakpointInfo.__init__","title":"<code>__init__(fn, src)</code>","text":""},{"location":"reference/component/","title":"component","text":"<p>This module defines the Component base class, which is instantiated for nearly every part of the system. It implements interfaces for communications, initialization, shutdown, etc.</p>"},{"location":"reference/component/#component.T","title":"<code>T = TypeVar('T')</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.WrappedComponentBase","title":"<code>WrappedComponentBase = TypeVar('WrappedComponentBase', bound=Component)</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.component_registry","title":"<code>component_registry: dict[str, type[Component]] = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.component_set","title":"<code>component_set: WeakSet[Component] = WeakSet()</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.default_components","title":"<code>default_components: set[str] = set()</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.loaded_components","title":"<code>loaded_components: dict[str, Component] = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/component/#component.Component","title":"<code>Component</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract component class for building pieces of ROC that will talk to each other.</p> Source code in <code>roc/component.py</code> <pre><code>class Component(ABC):\n    \"\"\"An abstract component class for building pieces of ROC that will talk to each other.\"\"\"\n\n    name: str = \"&lt;name unassigned&gt;\"\n    type: str = \"&lt;type unassigned&gt;\"\n\n    def __init__(self) -&gt; None:\n        global component_set\n        component_set.add(self)\n        self.bus_conns: dict[str, BusConnection[Any]] = {}\n        logger.trace(f\"++ incrementing component count: {self.name}:{self.type} {self}\")\n        # traceback.print_stack()\n\n    def __del__(self) -&gt; None:\n        global component_set\n        component_set.add(self)\n        logger.trace(f\"-- decrementing component count: {self.name}:{self.type} {self}\")\n\n    def connect_bus(self, bus: EventBus[T]) -&gt; BusConnection[T]:\n        \"\"\"Create a new bus connection for the component, storing the result for\n        later shutdown.\n\n        Args:\n            bus (EventBus[T]): The event bus to attach to\n\n        Raises:\n            ValueError: if the bus has already been connected to by this component\n\n        Returns:\n            BusConnection[T]: The bus connection for listening or sending events\n        \"\"\"\n        if bus.name in self.bus_conns:\n            raise ValueError(\n                f\"Component '{self.name}' attempting duplicate connection to bus '{bus.name}'\"\n            )\n\n        conn = bus.connect(self)\n        self.bus_conns[bus.name] = conn\n        return conn\n\n    def event_filter(self, e: Event[Any]) -&gt; bool:\n        \"\"\"A filter for any incoming events. By default it filters out events\n        sent by itself, but it is especially useful for creating new filters in\n        sub-classes.\n\n        Args:\n            e (Event[Any]): The event to be evaluated\n\n        Returns:\n            bool: True if the event should be sent, False if it should be dropped\n        \"\"\"\n        return e.src is not self\n\n    def shutdown(self) -&gt; None:\n        \"\"\"De-initializes the component, removing any bus connections and any\n        other clean-up that needs to be performed\n        \"\"\"\n        logger.debug(f\"Component {self.name}:{self.type} shutting down.\")\n\n        for conn in self.bus_conns:\n            for obs in self.bus_conns[conn].attached_bus.subject.observers:\n                obs.on_completed()\n\n    @staticmethod\n    def init() -&gt; None:\n        \"\"\"Loads all components registered as `auto` and perception components\n        in the `perception_components` config field.\n        \"\"\"\n        settings = Config.get()\n        component_list = default_components\n        component_list = component_list.union(settings.perception_components)\n        logger.debug(f\"Component.init: default components: {component_list}\")\n\n        # TODO: shutdown previously loaded components\n\n        for reg_str in component_list:\n            logger.trace(f\"Loading component: {reg_str} ...\")\n            (name, type) = reg_str.split(\":\")\n            loaded_components[reg_str] = Component.get(name, type)\n\n    @classmethod\n    def get(cls, name: str, type: str, *args: Any, **kwargs: Any) -&gt; Self:\n        \"\"\"Retreives a component with the specified name from the registry and\n        creates a new version of it with the specified args. Used by\n        `Config.init` and for testing.\n\n        Args:\n            name (str): The name of the component to get, as specified during\n                its registration\n            type (str): The type of the component to get, as specified during\n                its registration\n            args (Any): Fixed position arguments to pass to the Component\n                constructor\n            kwargs (Any): Keyword args to pass to the Component constructor\n\n        Returns:\n            Self: the component that was created, casted as the calling class.\n            (e.g. `Perception.get(...)` will return a Perception component and\n            `Action.get(...)` will return an Action component)\n        \"\"\"\n        reg_str = _component_registry_key(name, type)\n        return cast(Self, component_registry[reg_str](*args, **kwargs))\n\n    @staticmethod\n    def get_component_count() -&gt; int:\n        \"\"\"Returns the number of currently created Components. The number goes\n        up on __init__ and down on __del__. Primarily used for testing to ensure\n        Components are being shutdown appropriately.\n\n        Returns:\n            int: The number of currently active Component instances\n        \"\"\"\n        # global component_count\n        # return component_count\n        global component_set\n        return len(component_set)\n\n    @staticmethod\n    def deregister(name: str, type: str) -&gt; None:\n        \"\"\"Removes a component from the Component registry. Primarlly used for testing.\n\n        Args:\n            name (str): The name of the Component to deregister\n            type (str): The type of the Component to deregister\n        \"\"\"\n        reg_str = _component_registry_key(name, type)\n        del component_registry[reg_str]\n\n    @staticmethod\n    def reset() -&gt; None:\n        \"\"\"Shuts down all components\"\"\"\n        # shutdown all components\n        global loaded_components\n        for name in loaded_components:\n            logger.trace(f\"Shutting down component: {name}.\")\n            c = loaded_components[name]\n            c.shutdown()\n\n        loaded_components.clear()\n\n        global component_set\n        for c in component_set:\n            c.shutdown()\n</code></pre>"},{"location":"reference/component/#component.Component.bus_conns","title":"<code>bus_conns: dict[str, BusConnection[Any]] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.Component.name","title":"<code>name: str = '&lt;name unassigned&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.Component.type","title":"<code>type: str = '&lt;type unassigned&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.Component.__del__","title":"<code>__del__()</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __del__(self) -&gt; None:\n    global component_set\n    component_set.add(self)\n    logger.trace(f\"-- decrementing component count: {self.name}:{self.type} {self}\")\n</code></pre>"},{"location":"reference/component/#component.Component.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __init__(self) -&gt; None:\n    global component_set\n    component_set.add(self)\n    self.bus_conns: dict[str, BusConnection[Any]] = {}\n    logger.trace(f\"++ incrementing component count: {self.name}:{self.type} {self}\")\n</code></pre>"},{"location":"reference/component/#component.Component.connect_bus","title":"<code>connect_bus(bus)</code>","text":"<p>Create a new bus connection for the component, storing the result for later shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>EventBus[T]</code> <p>The event bus to attach to</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the bus has already been connected to by this component</p> <p>Returns:</p> Type Description <code>BusConnection[T]</code> <p>BusConnection[T]: The bus connection for listening or sending events</p> Source code in <code>roc/component.py</code> <pre><code>def connect_bus(self, bus: EventBus[T]) -&gt; BusConnection[T]:\n    \"\"\"Create a new bus connection for the component, storing the result for\n    later shutdown.\n\n    Args:\n        bus (EventBus[T]): The event bus to attach to\n\n    Raises:\n        ValueError: if the bus has already been connected to by this component\n\n    Returns:\n        BusConnection[T]: The bus connection for listening or sending events\n    \"\"\"\n    if bus.name in self.bus_conns:\n        raise ValueError(\n            f\"Component '{self.name}' attempting duplicate connection to bus '{bus.name}'\"\n        )\n\n    conn = bus.connect(self)\n    self.bus_conns[bus.name] = conn\n    return conn\n</code></pre>"},{"location":"reference/component/#component.Component.deregister","title":"<code>deregister(name, type)</code>  <code>staticmethod</code>","text":"<p>Removes a component from the Component registry. Primarlly used for testing.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the Component to deregister</p> required <code>type</code> <code>str</code> <p>The type of the Component to deregister</p> required Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef deregister(name: str, type: str) -&gt; None:\n    \"\"\"Removes a component from the Component registry. Primarlly used for testing.\n\n    Args:\n        name (str): The name of the Component to deregister\n        type (str): The type of the Component to deregister\n    \"\"\"\n    reg_str = _component_registry_key(name, type)\n    del component_registry[reg_str]\n</code></pre>"},{"location":"reference/component/#component.Component.event_filter","title":"<code>event_filter(e)</code>","text":"<p>A filter for any incoming events. By default it filters out events sent by itself, but it is especially useful for creating new filters in sub-classes.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Event[Any]</code> <p>The event to be evaluated</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the event should be sent, False if it should be dropped</p> Source code in <code>roc/component.py</code> <pre><code>def event_filter(self, e: Event[Any]) -&gt; bool:\n    \"\"\"A filter for any incoming events. By default it filters out events\n    sent by itself, but it is especially useful for creating new filters in\n    sub-classes.\n\n    Args:\n        e (Event[Any]): The event to be evaluated\n\n    Returns:\n        bool: True if the event should be sent, False if it should be dropped\n    \"\"\"\n    return e.src is not self\n</code></pre>"},{"location":"reference/component/#component.Component.get","title":"<code>get(name, type, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Retreives a component with the specified name from the registry and creates a new version of it with the specified args. Used by <code>Config.init</code> and for testing.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the component to get, as specified during its registration</p> required <code>type</code> <code>str</code> <p>The type of the component to get, as specified during its registration</p> required <code>args</code> <code>Any</code> <p>Fixed position arguments to pass to the Component constructor</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>Keyword args to pass to the Component constructor</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the component that was created, casted as the calling class.</p> <code>Self</code> <p>(e.g. <code>Perception.get(...)</code> will return a Perception component and</p> <code>Self</code> <p><code>Action.get(...)</code> will return an Action component)</p> Source code in <code>roc/component.py</code> <pre><code>@classmethod\ndef get(cls, name: str, type: str, *args: Any, **kwargs: Any) -&gt; Self:\n    \"\"\"Retreives a component with the specified name from the registry and\n    creates a new version of it with the specified args. Used by\n    `Config.init` and for testing.\n\n    Args:\n        name (str): The name of the component to get, as specified during\n            its registration\n        type (str): The type of the component to get, as specified during\n            its registration\n        args (Any): Fixed position arguments to pass to the Component\n            constructor\n        kwargs (Any): Keyword args to pass to the Component constructor\n\n    Returns:\n        Self: the component that was created, casted as the calling class.\n        (e.g. `Perception.get(...)` will return a Perception component and\n        `Action.get(...)` will return an Action component)\n    \"\"\"\n    reg_str = _component_registry_key(name, type)\n    return cast(Self, component_registry[reg_str](*args, **kwargs))\n</code></pre>"},{"location":"reference/component/#component.Component.get_component_count","title":"<code>get_component_count()</code>  <code>staticmethod</code>","text":"<p>Returns the number of currently created Components. The number goes up on init and down on del. Primarily used for testing to ensure Components are being shutdown appropriately.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of currently active Component instances</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef get_component_count() -&gt; int:\n    \"\"\"Returns the number of currently created Components. The number goes\n    up on __init__ and down on __del__. Primarily used for testing to ensure\n    Components are being shutdown appropriately.\n\n    Returns:\n        int: The number of currently active Component instances\n    \"\"\"\n    # global component_count\n    # return component_count\n    global component_set\n    return len(component_set)\n</code></pre>"},{"location":"reference/component/#component.Component.init","title":"<code>init()</code>  <code>staticmethod</code>","text":"<p>Loads all components registered as <code>auto</code> and perception components in the <code>perception_components</code> config field.</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef init() -&gt; None:\n    \"\"\"Loads all components registered as `auto` and perception components\n    in the `perception_components` config field.\n    \"\"\"\n    settings = Config.get()\n    component_list = default_components\n    component_list = component_list.union(settings.perception_components)\n    logger.debug(f\"Component.init: default components: {component_list}\")\n\n    # TODO: shutdown previously loaded components\n\n    for reg_str in component_list:\n        logger.trace(f\"Loading component: {reg_str} ...\")\n        (name, type) = reg_str.split(\":\")\n        loaded_components[reg_str] = Component.get(name, type)\n</code></pre>"},{"location":"reference/component/#component.Component.reset","title":"<code>reset()</code>  <code>staticmethod</code>","text":"<p>Shuts down all components</p> Source code in <code>roc/component.py</code> <pre><code>@staticmethod\ndef reset() -&gt; None:\n    \"\"\"Shuts down all components\"\"\"\n    # shutdown all components\n    global loaded_components\n    for name in loaded_components:\n        logger.trace(f\"Shutting down component: {name}.\")\n        c = loaded_components[name]\n        c.shutdown()\n\n    loaded_components.clear()\n\n    global component_set\n    for c in component_set:\n        c.shutdown()\n</code></pre>"},{"location":"reference/component/#component.Component.shutdown","title":"<code>shutdown()</code>","text":"<p>De-initializes the component, removing any bus connections and any other clean-up that needs to be performed</p> Source code in <code>roc/component.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"De-initializes the component, removing any bus connections and any\n    other clean-up that needs to be performed\n    \"\"\"\n    logger.debug(f\"Component {self.name}:{self.type} shutting down.\")\n\n    for conn in self.bus_conns:\n        for obs in self.bus_conns[conn].attached_bus.subject.observers:\n            obs.on_completed()\n</code></pre>"},{"location":"reference/component/#component.register_component","title":"<code>register_component</code>","text":"Source code in <code>roc/component.py</code> <pre><code>class register_component:\n    def __init__(self, name: str, type: str, *, auto: bool = False) -&gt; None:\n        self.name = name\n        self.type = type\n        self.auto = auto\n\n    def __call__(self, cls: type[Component]) -&gt; type[Component]:\n        global register_component\n        global component_registry\n\n        logger.trace(f\"Registering component: {self.name}:{self.type} (auto={self.auto})\")\n\n        reg_str = _component_registry_key(self.name, self.type)\n        if reg_str in component_registry:\n            raise ValueError(f\"Registering duplicate component name: '{self.name}'\")\n\n        if self.auto:\n            global default_components\n            default_components.add(reg_str)\n\n        component_registry[reg_str] = cls\n        cls.name = self.name\n        cls.type = self.type\n\n        return cls\n</code></pre>"},{"location":"reference/component/#component.register_component.auto","title":"<code>auto = auto</code>  <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.register_component.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.register_component.type","title":"<code>type = type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/component/#component.register_component.__call__","title":"<code>__call__(cls)</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __call__(self, cls: type[Component]) -&gt; type[Component]:\n    global register_component\n    global component_registry\n\n    logger.trace(f\"Registering component: {self.name}:{self.type} (auto={self.auto})\")\n\n    reg_str = _component_registry_key(self.name, self.type)\n    if reg_str in component_registry:\n        raise ValueError(f\"Registering duplicate component name: '{self.name}'\")\n\n    if self.auto:\n        global default_components\n        default_components.add(reg_str)\n\n    component_registry[reg_str] = cls\n    cls.name = self.name\n    cls.type = self.type\n\n    return cls\n</code></pre>"},{"location":"reference/component/#component.register_component.__init__","title":"<code>__init__(name, type, *, auto=False)</code>","text":"Source code in <code>roc/component.py</code> <pre><code>def __init__(self, name: str, type: str, *, auto: bool = False) -&gt; None:\n    self.name = name\n    self.type = type\n    self.auto = auto\n</code></pre>"},{"location":"reference/config/","title":"config","text":"<p>This module contains all the settings for the system.</p>"},{"location":"reference/config/#config.config_settings","title":"<code>config_settings = {'env_prefix': 'roc_', 'env_file': '.env'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/config/#config.Config","title":"<code>Config</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>A Pydantic settings model for configuration of the agent.</p> Source code in <code>roc/config.py</code> <pre><code>class Config(BaseSettings):\n    \"\"\"A Pydantic settings model for configuration of the agent.\"\"\"\n\n    global config_settings\n    model_config = SettingsConfigDict(\n        # XXX: can't do **config_settings 'cause of TypedDict?\n        env_prefix=config_settings[\"env_prefix\"],\n        env_file=config_settings[\"env_file\"],\n        extra=\"forbid\",\n    )\n    db_host: str = Field(default=\"127.0.0.1\")\n    db_port: int = Field(default=7687)\n    db_conn_encrypted: bool = Field(default=False)\n    db_username: str = Field(default=\"\")\n    db_password: str = Field(default=\"\")\n    db_lazy: bool = Field(default=False)\n    node_cache_size: int = Field(default=2**30)\n    edge_cache_size: int = Field(default=2**30)\n    log_enable: bool = Field(default=True)\n    log_level: str = Field(default=\"INFO\")\n    log_modules: str = Field(default=\"\")\n    default_action: str = Field(default=\"pass\")\n    perception_components: list[str] = Field(default=[\"delta:perception\"])\n    enable_gym_dump_env: bool = Field(default=False)\n    max_dump_frames: int = Field(default=10)\n\n    @staticmethod\n    def get() -&gt; Config:\n        global _config_singleton\n        if _config_singleton is None:\n            warnings.warn(\n                \"Getting settings before config module was initialized. Please call init() first\",\n                ConfigInitWarning,\n            )\n            Config.init()\n            assert _config_singleton is not None\n        return _config_singleton\n\n    @staticmethod\n    def init(\n        config: dict[str, Any] | None = None,\n        *,\n        force: bool = False,\n        use_secrets: bool = True,\n    ) -&gt; None:\n        \"\"\"Initializes the settings by reading the configuration files and environment variables\"\"\"\n        global _config_singleton\n        initialized = _config_singleton is not None\n        if initialized and not force:\n            warnings.warn(\n                \"Config already initialized, returning existing configuration.\",\n                ConfigInitWarning,\n            )\n            return\n\n        passed_conf = config or {}\n        _config_singleton = Config(**passed_conf)\n\n    @staticmethod\n    def reset() -&gt; None:\n        global _config_singleton\n        _config_singleton = None\n</code></pre>"},{"location":"reference/config/#config.Config.db_conn_encrypted","title":"<code>db_conn_encrypted: bool = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_host","title":"<code>db_host: str = Field(default='127.0.0.1')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_lazy","title":"<code>db_lazy: bool = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_password","title":"<code>db_password: str = Field(default='')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_port","title":"<code>db_port: int = Field(default=7687)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.db_username","title":"<code>db_username: str = Field(default='')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.default_action","title":"<code>default_action: str = Field(default='pass')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.edge_cache_size","title":"<code>edge_cache_size: int = Field(default=2 ** 30)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.enable_gym_dump_env","title":"<code>enable_gym_dump_env: bool = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.log_enable","title":"<code>log_enable: bool = Field(default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.log_level","title":"<code>log_level: str = Field(default='INFO')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.log_modules","title":"<code>log_modules: str = Field(default='')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.max_dump_frames","title":"<code>max_dump_frames: int = Field(default=10)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.model_config","title":"<code>model_config = SettingsConfigDict(env_prefix=config_settings['env_prefix'], env_file=config_settings['env_file'], extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.node_cache_size","title":"<code>node_cache_size: int = Field(default=2 ** 30)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.perception_components","title":"<code>perception_components: list[str] = Field(default=['delta:perception'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.get","title":"<code>get()</code>  <code>staticmethod</code>","text":"Source code in <code>roc/config.py</code> <pre><code>@staticmethod\ndef get() -&gt; Config:\n    global _config_singleton\n    if _config_singleton is None:\n        warnings.warn(\n            \"Getting settings before config module was initialized. Please call init() first\",\n            ConfigInitWarning,\n        )\n        Config.init()\n        assert _config_singleton is not None\n    return _config_singleton\n</code></pre>"},{"location":"reference/config/#config.Config.init","title":"<code>init(config=None, *, force=False, use_secrets=True)</code>  <code>staticmethod</code>","text":"<p>Initializes the settings by reading the configuration files and environment variables</p> Source code in <code>roc/config.py</code> <pre><code>@staticmethod\ndef init(\n    config: dict[str, Any] | None = None,\n    *,\n    force: bool = False,\n    use_secrets: bool = True,\n) -&gt; None:\n    \"\"\"Initializes the settings by reading the configuration files and environment variables\"\"\"\n    global _config_singleton\n    initialized = _config_singleton is not None\n    if initialized and not force:\n        warnings.warn(\n            \"Config already initialized, returning existing configuration.\",\n            ConfigInitWarning,\n        )\n        return\n\n    passed_conf = config or {}\n    _config_singleton = Config(**passed_conf)\n</code></pre>"},{"location":"reference/config/#config.Config.reset","title":"<code>reset()</code>  <code>staticmethod</code>","text":"Source code in <code>roc/config.py</code> <pre><code>@staticmethod\ndef reset() -&gt; None:\n    global _config_singleton\n    _config_singleton = None\n</code></pre>"},{"location":"reference/config/#config.ConfigInitWarning","title":"<code>ConfigInitWarning</code>","text":"<p>               Bases: <code>Warning</code></p> <p>A Warning for when attempting to access config before it has been initialized.</p> Source code in <code>roc/config.py</code> <pre><code>class ConfigInitWarning(Warning):\n    \"\"\"A Warning for when attempting to access config before it has been initialized.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/event/","title":"event","text":"<p>This module defines all the communications and eventing interfaces for the system.</p>"},{"location":"reference/event/#event.EventData","title":"<code>EventData = TypeVar('EventData')</code>  <code>module-attribute</code>","text":""},{"location":"reference/event/#event.EventFilter","title":"<code>EventFilter = Callable[[Event[EventData]], bool]</code>  <code>module-attribute</code>","text":""},{"location":"reference/event/#event.EventListener","title":"<code>EventListener = Callable[[Event[EventData]], None]</code>  <code>module-attribute</code>","text":""},{"location":"reference/event/#event.eventbus_names","title":"<code>eventbus_names: set[str] = set()</code>  <code>module-attribute</code>","text":""},{"location":"reference/event/#event.BusConnection","title":"<code>BusConnection</code>","text":"<p>               Bases: <code>Generic[EventData]</code></p> <p>A connection between an EventBus and a Component, used to send Events</p> <p>Parameters:</p> Name Type Description Default <code>Generic</code> <code>EventData</code> <p>The data type that will be sent over this connection</p> required Source code in <code>roc/event.py</code> <pre><code>class BusConnection(Generic[EventData]):\n    \"\"\"A connection between an EventBus and a Component, used to send Events\n\n    Args:\n        Generic (EventData): The data type that will be sent over this connection\n    \"\"\"\n\n    def __init__(self, bus: EventBus[EventData], component: Component):\n        logger.debug(f\"{component.name}:{component.type} attaching to bus {bus.name}\")\n        self.attached_bus = bus\n        self.attached_component = component\n        self.subject: rx.Subject[Event[EventData]] = self.attached_bus.subject\n        self.subscribers: list[Disposable] = []\n\n    def send(self, data: EventData) -&gt; None:\n        \"\"\"Send data over the EventBus. Internally, the data is converted to an Event\n        with the relevant data (such as the source Component).\n\n        Args:\n            data (EventData): The data type of the data to be sent\n        \"\"\"\n        e = Event[EventData](data, self.attached_component, self.attached_bus)\n        logger.trace(f\"&gt;&gt;&gt; Sending {e}\")\n        self.attached_bus.subject.on_next(e)\n\n    def listen(\n        self,\n        listener: EventListener[EventData],\n        *,\n        filter: EventFilter[EventData] | None = None,\n    ) -&gt; None:\n        pipe_args: list[Callable[[Any], Observable[Event[EventData]]]] = [\n            # op.filter(lambda e: e.src is not self.attached_component),\n            # op.do_action(lambda e: print(\"before filter\", e)),\n            op.filter(self.attached_component.event_filter),\n        ]\n        if filter is not None:\n            pipe_args.append(op.filter(filter))\n\n        sub = self.subject.pipe(*pipe_args).subscribe(listener)\n        self.subscribers.append(sub)\n\n    def close(self) -&gt; None:\n        logger.trace(\n            f\"Closing connection {self.attached_component.name} -&gt; {self.attached_bus.name}\"\n        )\n\n        for sub in self.subscribers:\n            sub.dispose()\n</code></pre>"},{"location":"reference/event/#event.BusConnection.attached_bus","title":"<code>attached_bus = bus</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.BusConnection.attached_component","title":"<code>attached_component = component</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.BusConnection.subject","title":"<code>subject: rx.Subject[Event[EventData]] = self.attached_bus.subject</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.BusConnection.subscribers","title":"<code>subscribers: list[Disposable] = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.BusConnection.__init__","title":"<code>__init__(bus, component)</code>","text":"Source code in <code>roc/event.py</code> <pre><code>def __init__(self, bus: EventBus[EventData], component: Component):\n    logger.debug(f\"{component.name}:{component.type} attaching to bus {bus.name}\")\n    self.attached_bus = bus\n    self.attached_component = component\n    self.subject: rx.Subject[Event[EventData]] = self.attached_bus.subject\n    self.subscribers: list[Disposable] = []\n</code></pre>"},{"location":"reference/event/#event.BusConnection.close","title":"<code>close()</code>","text":"Source code in <code>roc/event.py</code> <pre><code>def close(self) -&gt; None:\n    logger.trace(\n        f\"Closing connection {self.attached_component.name} -&gt; {self.attached_bus.name}\"\n    )\n\n    for sub in self.subscribers:\n        sub.dispose()\n</code></pre>"},{"location":"reference/event/#event.BusConnection.listen","title":"<code>listen(listener, *, filter=None)</code>","text":"Source code in <code>roc/event.py</code> <pre><code>def listen(\n    self,\n    listener: EventListener[EventData],\n    *,\n    filter: EventFilter[EventData] | None = None,\n) -&gt; None:\n    pipe_args: list[Callable[[Any], Observable[Event[EventData]]]] = [\n        # op.filter(lambda e: e.src is not self.attached_component),\n        # op.do_action(lambda e: print(\"before filter\", e)),\n        op.filter(self.attached_component.event_filter),\n    ]\n    if filter is not None:\n        pipe_args.append(op.filter(filter))\n\n    sub = self.subject.pipe(*pipe_args).subscribe(listener)\n    self.subscribers.append(sub)\n</code></pre>"},{"location":"reference/event/#event.BusConnection.send","title":"<code>send(data)</code>","text":"<p>Send data over the EventBus. Internally, the data is converted to an Event with the relevant data (such as the source Component).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>EventData</code> <p>The data type of the data to be sent</p> required Source code in <code>roc/event.py</code> <pre><code>def send(self, data: EventData) -&gt; None:\n    \"\"\"Send data over the EventBus. Internally, the data is converted to an Event\n    with the relevant data (such as the source Component).\n\n    Args:\n        data (EventData): The data type of the data to be sent\n    \"\"\"\n    e = Event[EventData](data, self.attached_component, self.attached_bus)\n    logger.trace(f\"&gt;&gt;&gt; Sending {e}\")\n    self.attached_bus.subject.on_next(e)\n</code></pre>"},{"location":"reference/event/#event.Event","title":"<code>Event</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[EventData]</code></p> <p>An abstract event class for sending messages between Components over an EventBus</p> <p>Parameters:</p> Name Type Description Default <code>ABC</code> <code>ABC</code> <p>Abstract base class</p> required <code>Generic</code> <code>EventData</code> <p>The data to be carried by the event</p> required Source code in <code>roc/event.py</code> <pre><code>class Event(ABC, Generic[EventData]):\n    \"\"\"An abstract event class for sending messages between Components over an EventBus\n\n    Args:\n        ABC (ABC): Abstract base class\n        Generic (EventData): The data to be carried by the event\n    \"\"\"\n\n    def __init__(self, data: EventData, src: Component, bus: EventBus[EventData]):\n        \"\"\"The initializer for the Event\n\n        Args:\n            data (EventData): The data for this event\n            src (Component): The Component sending the event\n            bus (EventBus): The EventBus that the event is being sent over\n        \"\"\"\n        self.data = data\n        self.src = src\n        self.bus = bus\n\n    def __repr__(self) -&gt; str:\n        data_str = pretty_repr(\n            self.data,\n            # max_depth=4, # Maximum depth of nested data structure\n            max_length=5,  # Maximum length of containers before abbreviating\n            max_string=60,  # Maximum length of string before truncating\n            expand_all=False,  # Expand all containers regardless of available width\n            max_width=120,\n        )\n        if \"\\n\" in data_str:\n            data_str = \"\\n\" + data_str\n        return f\"[EVENT: {self.src.name} &gt;&gt;&gt; {self.bus.name}]: {data_str}\"\n</code></pre>"},{"location":"reference/event/#event.Event.bus","title":"<code>bus = bus</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.Event.data","title":"<code>data = data</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.Event.src","title":"<code>src = src</code>  <code>instance-attribute</code>","text":""},{"location":"reference/event/#event.Event.__init__","title":"<code>__init__(data, src, bus)</code>","text":"<p>The initializer for the Event</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>EventData</code> <p>The data for this event</p> required <code>src</code> <code>Component</code> <p>The Component sending the event</p> required <code>bus</code> <code>EventBus</code> <p>The EventBus that the event is being sent over</p> required Source code in <code>roc/event.py</code> <pre><code>def __init__(self, data: EventData, src: Component, bus: EventBus[EventData]):\n    \"\"\"The initializer for the Event\n\n    Args:\n        data (EventData): The data for this event\n        src (Component): The Component sending the event\n        bus (EventBus): The EventBus that the event is being sent over\n    \"\"\"\n    self.data = data\n    self.src = src\n    self.bus = bus\n</code></pre>"},{"location":"reference/event/#event.Event.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>roc/event.py</code> <pre><code>def __repr__(self) -&gt; str:\n    data_str = pretty_repr(\n        self.data,\n        # max_depth=4, # Maximum depth of nested data structure\n        max_length=5,  # Maximum length of containers before abbreviating\n        max_string=60,  # Maximum length of string before truncating\n        expand_all=False,  # Expand all containers regardless of available width\n        max_width=120,\n    )\n    if \"\\n\" in data_str:\n        data_str = \"\\n\" + data_str\n    return f\"[EVENT: {self.src.name} &gt;&gt;&gt; {self.bus.name}]: {data_str}\"\n</code></pre>"},{"location":"reference/event/#event.EventBus","title":"<code>EventBus</code>","text":"<p>               Bases: <code>Generic[EventData]</code></p> <p>A communication channel for sending events between Components</p> <p>Parameters:</p> Name Type Description Default <code>Generic</code> <code>EventData</code> <p>The data type that is allowed to be sent over the bus</p> required Source code in <code>roc/event.py</code> <pre><code>class EventBus(Generic[EventData]):\n    \"\"\"A communication channel for sending events between Components\n\n    Args:\n        Generic (EventData): The data type that is allowed to be sent over the bus\n    \"\"\"\n\n    name: str\n    \"\"\"The name of the bus. Used to ensure uniqueness.\"\"\"\n    subject: rx.Subject[Event[EventData]]\n    \"\"\"The RxPy Subject that the bus uses to communicate.\"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        if name in eventbus_names:\n            raise Exception(f\"Duplicate EventBus name: {name}\")\n        self.name = name\n        eventbus_names.add(name)\n        self.subject = rx.Subject[Event[EventData]]()\n\n    def connect(self, component: Component) -&gt; BusConnection[EventData]:\n        \"\"\"Creates a connection between an EventBus and a Component for sending Events\n\n        Args:\n            component (Component): The Component to connect to the bus\n\n        Returns:\n            BusConnection[EventData]: A new connection that can be used to send data\n        \"\"\"\n        return BusConnection[EventData](self, component)\n\n    @staticmethod\n    def clear_names() -&gt; None:\n        \"\"\"Clears all EventBusses that have been registered, mostly used for testing.\"\"\"\n        eventbus_names.clear()\n</code></pre>"},{"location":"reference/event/#event.EventBus.name","title":"<code>name: str = name</code>  <code>instance-attribute</code>","text":"<p>The name of the bus. Used to ensure uniqueness.</p>"},{"location":"reference/event/#event.EventBus.subject","title":"<code>subject: rx.Subject[Event[EventData]] = rx.Subject[Event[EventData]]()</code>  <code>instance-attribute</code>","text":"<p>The RxPy Subject that the bus uses to communicate.</p>"},{"location":"reference/event/#event.EventBus.__init__","title":"<code>__init__(name)</code>","text":"Source code in <code>roc/event.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    if name in eventbus_names:\n        raise Exception(f\"Duplicate EventBus name: {name}\")\n    self.name = name\n    eventbus_names.add(name)\n    self.subject = rx.Subject[Event[EventData]]()\n</code></pre>"},{"location":"reference/event/#event.EventBus.clear_names","title":"<code>clear_names()</code>  <code>staticmethod</code>","text":"<p>Clears all EventBusses that have been registered, mostly used for testing.</p> Source code in <code>roc/event.py</code> <pre><code>@staticmethod\ndef clear_names() -&gt; None:\n    \"\"\"Clears all EventBusses that have been registered, mostly used for testing.\"\"\"\n    eventbus_names.clear()\n</code></pre>"},{"location":"reference/event/#event.EventBus.connect","title":"<code>connect(component)</code>","text":"<p>Creates a connection between an EventBus and a Component for sending Events</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>Component</code> <p>The Component to connect to the bus</p> required <p>Returns:</p> Type Description <code>BusConnection[EventData]</code> <p>BusConnection[EventData]: A new connection that can be used to send data</p> Source code in <code>roc/event.py</code> <pre><code>def connect(self, component: Component) -&gt; BusConnection[EventData]:\n    \"\"\"Creates a connection between an EventBus and a Component for sending Events\n\n    Args:\n        component (Component): The Component to connect to the bus\n\n    Returns:\n        BusConnection[EventData]: A new connection that can be used to send data\n    \"\"\"\n    return BusConnection[EventData](self, component)\n</code></pre>"},{"location":"reference/graphdb/","title":"graphdb","text":"<p>This module is a wrapper around a graph database and abstracts away all the database-specific features as various classes (GraphDB, Node, Edge, etc)</p>"},{"location":"reference/graphdb/#graphdb.CacheDefault","title":"<code>CacheDefault = TypeVar('CacheDefault')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.CacheId","title":"<code>CacheId = TypeVar('CacheId')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.CacheKey","title":"<code>CacheKey = TypeVar('CacheKey')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.CacheType","title":"<code>CacheType = TypeVar('CacheType')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.CacheValue","title":"<code>CacheValue = TypeVar('CacheValue')</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeCache","title":"<code>EdgeCache = GraphCache[EdgeId, Edge]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeCallbackFn","title":"<code>EdgeCallbackFn = Callable[[Edge], None]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeFilter","title":"<code>EdgeFilter = Callable[[Edge], bool] | str | EdgeId | None</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeFilterFn","title":"<code>EdgeFilterFn = Callable[[Edge], bool]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeId","title":"<code>EdgeId = NewType('EdgeId', int)</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.NodeCache","title":"<code>NodeCache = GraphCache[NodeId, Node]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.NodeCallbackFn","title":"<code>NodeCallbackFn = Callable[[Node], None]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.NodeFilterFn","title":"<code>NodeFilterFn = Callable[[Node], bool]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.NodeId","title":"<code>NodeId = NewType('NodeId', int)</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.ProgressFn","title":"<code>ProgressFn = Callable[[list[Node]], None]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.RecordFn","title":"<code>RecordFn = Callable[[str, Iterator[Any]], None]</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.WalkMode","title":"<code>WalkMode = Literal['src', 'dst', 'both']</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.edge_cache","title":"<code>edge_cache: EdgeCache | None = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.graph_db_singleton","title":"<code>graph_db_singleton: GraphDB | None = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.next_new_edge","title":"<code>next_new_edge: EdgeId = cast(EdgeId, -1)</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.next_new_node","title":"<code>next_new_node: NodeId = cast(NodeId, -1)</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.node_cache","title":"<code>node_cache: NodeCache | None = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge","title":"<code>Edge</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An edge (a.k.a. Relationship or Connection) between two Nodes. An edge obect automatically implements all phases of CRUD in the underlying graph database. This is a directional relationship with a \"source\" and \"destination\". The source and destination properties are dynamically loaded through property getters when they are called, and may trigger a graph database query if they don't already exist in the edge cache.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class Edge(BaseModel, extra=\"allow\"):\n    \"\"\"An edge (a.k.a. Relationship or Connection) between two Nodes. An edge obect automatically\n    implements all phases of CRUD in the underlying graph database. This is a directional\n    relationship with a \"source\" and \"destination\". The source and destination properties\n    are dynamically loaded through property getters when they are called, and may trigger\n    a graph database query if they don't already exist in the edge cache.\n    \"\"\"\n\n    id: EdgeId = Field(exclude=True)\n    # XXX: type, src_id, and dst_id used to be pydantic literals, but updating\n    # the pydantic version broke them\n    type: str = Field(exclude=True)\n    src_id: NodeId = Field(exclude=True)\n    dst_id: NodeId = Field(exclude=True)\n    _no_save = False\n    _new = False\n    _deleted = False\n\n    @field_validator(\"id\", mode=\"before\")\n    def default_id(cls, id: EdgeId | None) -&gt; EdgeId:\n        if isinstance(id, int):\n            return id\n\n        return get_next_new_edge_id()\n\n    @property\n    def src(self) -&gt; Node:\n        return Node.get(self.src_id)\n\n    @property\n    def dst(self) -&gt; Node:\n        return Node.get(self.dst_id)\n\n    @property\n    def new(self) -&gt; bool:\n        return self._new\n\n    def __init__(\n        self,\n        src_id: NodeId,\n        dst_id: NodeId,\n        type: str,\n        *,\n        id: EdgeId | None = None,\n        data: dict[Any, Any] | None = None,\n    ):\n        data = data or {}\n        super().__init__(\n            src_id=src_id,\n            dst_id=dst_id,\n            type=type,\n            id=id,\n            **data,\n        )\n\n        if self.id &lt; 0:\n            self._new = True\n            Edge.get_cache()[self.id] = self\n\n    def __del__(self) -&gt; None:\n        # print(\"Edge.__del__:\", self)\n        Edge.save(self)\n\n    def __repr__(self) -&gt; str:\n        return f\"Edge({self.id} [{self.src_id}&gt;&gt;{self.dst_id}])\"\n\n    @classmethod\n    def get_cache(self) -&gt; EdgeCache:\n        global edge_cache\n        if edge_cache is None:\n            settings = Config.get()\n            edge_cache = EdgeCache(maxsize=settings.edge_cache_size)\n\n        return edge_cache\n\n    @classmethod\n    def get(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Looks up an Edge based on it's ID. If the Edge is cached, the cached edge is returned;\n        otherwise the Edge is queried from the graph database based the ID provided and a new\n        Edge is returned and cached.\n\n        Args:\n            id (EdgeId): the unique identifier for the Edge\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: returns the Edge requested by the id\n        \"\"\"\n        cache = Edge.get_cache()\n        e = cache.get(id)\n        if not e:\n            e = cls.load(id, db=db)\n            cache[id] = e\n\n        return cast(Self, e)\n\n    @classmethod\n    def load(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Loads an Edge from the graph database without attempting to check if the Edge\n        already exists in the cache. Typically this is only called by Edge.get()\n\n        Args:\n            id (EdgeId): the unique identifier of the Edge to fetch\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            EdgeNotFound: if the specified ID does not exist in the cache or the database\n\n        Returns:\n            Self: returns the Edge requested by the id\n        \"\"\"\n        db = db or GraphDB.singleton()\n        edge_list = list(db.raw_fetch(f\"MATCH (n)-[e]-(m) WHERE id(e) = {id} RETURN e LIMIT 1\"))\n        if not len(edge_list) == 1:\n            raise EdgeNotFound(f\"Couldn't find edge ID: {id}\")\n\n        e = edge_list[0][\"e\"]\n        props = None\n        if hasattr(e, \"properties\"):\n            props = e.properties\n        return cls(\n            e.start_id,\n            e.end_id,\n            id=id,\n            data=props,\n            type=e.type,\n        )\n\n    @classmethod\n    def save(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Saves the edge to the database. Calls Edge.create if the edge is new, or Edge.update if\n        edge already exists in the database.\n\n        Args:\n            e (Self): The edge to save\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: The same edge that was passed in, for convenience. The Edge may be updated with a\n            new identifier if it was newly created in the database.\n        \"\"\"\n        if e._new:\n            return cls.create(e, db=db)\n        else:\n            return cls.update(e, db=db)\n\n    @classmethod\n    def create(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Creates a new edge in the database. Typically only called by Edge.save\n\n        Args:\n            e (Self): The edge to create\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            EdgeCreateFailed: Failed to write the edge to the database, for eample\n                if the ID is wrong.\n\n        Returns:\n            Self: the edge that was created, with an updated identifier and other chagned attributes\n        \"\"\"\n        if e._no_save or e.src._no_save or e.dst._no_save:\n            return e\n\n        db = db or GraphDB.singleton()\n        old_id = e.id\n\n        if e.src._new:\n            Node.save(e.src)\n\n        if e.dst._new:\n            Node.save(e.dst)\n\n        params = {\"props\": Edge.to_dict(e)}\n\n        ret = list(\n            db.raw_fetch(\n                f\"\"\"\n                MATCH (src), (dst)\n                WHERE id(src) = {e.src_id} AND id(dst) = {e.dst_id} \n                CREATE (src)-[e:{e.type} $props]-&gt;(dst)\n                RETURN id(e) as e_id\n                \"\"\",\n                params=params,\n            )\n        )\n\n        if len(ret) != 1:\n            raise EdgeCreateFailed(\"failed to create new edge\")\n\n        e.id = ret[0][\"e_id\"]\n        e._new = False\n        # update the cache; if being called during __del__ then the cache entry may not exist\n        try:\n            cache = Edge.get_cache()\n            del cache[old_id]\n            cache[e.id] = e\n        except KeyError:\n            pass\n        # update references to edge id\n        e.src.src_edges.replace(old_id, e.id)\n        e.dst.dst_edges.replace(old_id, e.id)\n\n        return e\n\n    @classmethod\n    def update(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Updates the edge in the database. Typically only called by Edge.save\n\n        Args:\n            e (Self): The edge to update\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: The same edge that was passed in, for convenience\n        \"\"\"\n        if e._no_save:\n            return e\n\n        db = db or GraphDB.singleton()\n\n        params = {\"props\": Edge.to_dict(e)}\n\n        db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} SET e = $props\", params=params)\n\n        return e\n\n    @staticmethod\n    def delete(e: Edge, *, db: GraphDB | None = None) -&gt; None:\n        \"\"\"Deletes the specified edge from the database. If the edge has not already been persisted\n        to the database, this marks the edge as deleted and returns.\n\n        Args:\n            e (Edge): The edge to delete\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n        \"\"\"\n        e._deleted = True\n        e._no_save = True\n        db = db or GraphDB.singleton()\n\n        # remove e from src and dst nodes\n        e.src.src_edges.discard(e)\n        e.dst.dst_edges.discard(e)\n\n        # remove from cache\n        edge_cache = Edge.get_cache()\n        if e.id in edge_cache:\n            del edge_cache[e.id]\n\n        # delete from db\n        if not e._new:\n            db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} DELETE e\")\n\n    @staticmethod\n    def to_dict(e: Edge, include_type: bool = False) -&gt; dict[str, Any]:\n        \"\"\"Convert a Edge to a Python dictionary\"\"\"\n        ret = e.model_dump()\n        if include_type and hasattr(e, \"type\"):\n            ret[\"type\"] = e.type\n        return ret\n\n    @staticmethod\n    def to_id(e: Edge | EdgeId) -&gt; EdgeId:\n        if isinstance(e, Edge):\n            return e.id\n        else:\n            return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.dst","title":"<code>dst: Node</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.dst_id","title":"<code>dst_id: NodeId = Field(exclude=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.id","title":"<code>id: EdgeId = Field(exclude=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.new","title":"<code>new: bool</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.src","title":"<code>src: Node</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.src_id","title":"<code>src_id: NodeId = Field(exclude=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.type","title":"<code>type: str = Field(exclude=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Edge.__del__","title":"<code>__del__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __del__(self) -&gt; None:\n    # print(\"Edge.__del__:\", self)\n    Edge.save(self)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.__init__","title":"<code>__init__(src_id, dst_id, type, *, id=None, data=None)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(\n    self,\n    src_id: NodeId,\n    dst_id: NodeId,\n    type: str,\n    *,\n    id: EdgeId | None = None,\n    data: dict[Any, Any] | None = None,\n):\n    data = data or {}\n    super().__init__(\n        src_id=src_id,\n        dst_id=dst_id,\n        type=type,\n        id=id,\n        **data,\n    )\n\n    if self.id &lt; 0:\n        self._new = True\n        Edge.get_cache()[self.id] = self\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"Edge({self.id} [{self.src_id}&gt;&gt;{self.dst_id}])\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.create","title":"<code>create(e, *, db=None)</code>  <code>classmethod</code>","text":"<p>Creates a new edge in the database. Typically only called by Edge.save</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Self</code> <p>The edge to create</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>EdgeCreateFailed</code> <p>Failed to write the edge to the database, for eample if the ID is wrong.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the edge that was created, with an updated identifier and other chagned attributes</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef create(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Creates a new edge in the database. Typically only called by Edge.save\n\n    Args:\n        e (Self): The edge to create\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        EdgeCreateFailed: Failed to write the edge to the database, for eample\n            if the ID is wrong.\n\n    Returns:\n        Self: the edge that was created, with an updated identifier and other chagned attributes\n    \"\"\"\n    if e._no_save or e.src._no_save or e.dst._no_save:\n        return e\n\n    db = db or GraphDB.singleton()\n    old_id = e.id\n\n    if e.src._new:\n        Node.save(e.src)\n\n    if e.dst._new:\n        Node.save(e.dst)\n\n    params = {\"props\": Edge.to_dict(e)}\n\n    ret = list(\n        db.raw_fetch(\n            f\"\"\"\n            MATCH (src), (dst)\n            WHERE id(src) = {e.src_id} AND id(dst) = {e.dst_id} \n            CREATE (src)-[e:{e.type} $props]-&gt;(dst)\n            RETURN id(e) as e_id\n            \"\"\",\n            params=params,\n        )\n    )\n\n    if len(ret) != 1:\n        raise EdgeCreateFailed(\"failed to create new edge\")\n\n    e.id = ret[0][\"e_id\"]\n    e._new = False\n    # update the cache; if being called during __del__ then the cache entry may not exist\n    try:\n        cache = Edge.get_cache()\n        del cache[old_id]\n        cache[e.id] = e\n    except KeyError:\n        pass\n    # update references to edge id\n    e.src.src_edges.replace(old_id, e.id)\n    e.dst.dst_edges.replace(old_id, e.id)\n\n    return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.default_id","title":"<code>default_id(id)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@field_validator(\"id\", mode=\"before\")\ndef default_id(cls, id: EdgeId | None) -&gt; EdgeId:\n    if isinstance(id, int):\n        return id\n\n    return get_next_new_edge_id()\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.delete","title":"<code>delete(e, *, db=None)</code>  <code>staticmethod</code>","text":"<p>Deletes the specified edge from the database. If the edge has not already been persisted to the database, this marks the edge as deleted and returns.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Edge</code> <p>The edge to delete</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef delete(e: Edge, *, db: GraphDB | None = None) -&gt; None:\n    \"\"\"Deletes the specified edge from the database. If the edge has not already been persisted\n    to the database, this marks the edge as deleted and returns.\n\n    Args:\n        e (Edge): The edge to delete\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n    \"\"\"\n    e._deleted = True\n    e._no_save = True\n    db = db or GraphDB.singleton()\n\n    # remove e from src and dst nodes\n    e.src.src_edges.discard(e)\n    e.dst.dst_edges.discard(e)\n\n    # remove from cache\n    edge_cache = Edge.get_cache()\n    if e.id in edge_cache:\n        del edge_cache[e.id]\n\n    # delete from db\n    if not e._new:\n        db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} DELETE e\")\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.get","title":"<code>get(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Looks up an Edge based on it's ID. If the Edge is cached, the cached edge is returned; otherwise the Edge is queried from the graph database based the ID provided and a new Edge is returned and cached.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>EdgeId</code> <p>the unique identifier for the Edge</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>returns the Edge requested by the id</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Looks up an Edge based on it's ID. If the Edge is cached, the cached edge is returned;\n    otherwise the Edge is queried from the graph database based the ID provided and a new\n    Edge is returned and cached.\n\n    Args:\n        id (EdgeId): the unique identifier for the Edge\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: returns the Edge requested by the id\n    \"\"\"\n    cache = Edge.get_cache()\n    e = cache.get(id)\n    if not e:\n        e = cls.load(id, db=db)\n        cache[id] = e\n\n    return cast(Self, e)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.get_cache","title":"<code>get_cache()</code>  <code>classmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get_cache(self) -&gt; EdgeCache:\n    global edge_cache\n    if edge_cache is None:\n        settings = Config.get()\n        edge_cache = EdgeCache(maxsize=settings.edge_cache_size)\n\n    return edge_cache\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.load","title":"<code>load(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Loads an Edge from the graph database without attempting to check if the Edge already exists in the cache. Typically this is only called by Edge.get()</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>EdgeId</code> <p>the unique identifier of the Edge to fetch</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>EdgeNotFound</code> <p>if the specified ID does not exist in the cache or the database</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>returns the Edge requested by the id</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef load(cls, id: EdgeId, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Loads an Edge from the graph database without attempting to check if the Edge\n    already exists in the cache. Typically this is only called by Edge.get()\n\n    Args:\n        id (EdgeId): the unique identifier of the Edge to fetch\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        EdgeNotFound: if the specified ID does not exist in the cache or the database\n\n    Returns:\n        Self: returns the Edge requested by the id\n    \"\"\"\n    db = db or GraphDB.singleton()\n    edge_list = list(db.raw_fetch(f\"MATCH (n)-[e]-(m) WHERE id(e) = {id} RETURN e LIMIT 1\"))\n    if not len(edge_list) == 1:\n        raise EdgeNotFound(f\"Couldn't find edge ID: {id}\")\n\n    e = edge_list[0][\"e\"]\n    props = None\n    if hasattr(e, \"properties\"):\n        props = e.properties\n    return cls(\n        e.start_id,\n        e.end_id,\n        id=id,\n        data=props,\n        type=e.type,\n    )\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.save","title":"<code>save(e, *, db=None)</code>  <code>classmethod</code>","text":"<p>Saves the edge to the database. Calls Edge.create if the edge is new, or Edge.update if edge already exists in the database.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Self</code> <p>The edge to save</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The same edge that was passed in, for convenience. The Edge may be updated with a</p> <code>Self</code> <p>new identifier if it was newly created in the database.</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef save(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Saves the edge to the database. Calls Edge.create if the edge is new, or Edge.update if\n    edge already exists in the database.\n\n    Args:\n        e (Self): The edge to save\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: The same edge that was passed in, for convenience. The Edge may be updated with a\n        new identifier if it was newly created in the database.\n    \"\"\"\n    if e._new:\n        return cls.create(e, db=db)\n    else:\n        return cls.update(e, db=db)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.to_dict","title":"<code>to_dict(e, include_type=False)</code>  <code>staticmethod</code>","text":"<p>Convert a Edge to a Python dictionary</p> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef to_dict(e: Edge, include_type: bool = False) -&gt; dict[str, Any]:\n    \"\"\"Convert a Edge to a Python dictionary\"\"\"\n    ret = e.model_dump()\n    if include_type and hasattr(e, \"type\"):\n        ret[\"type\"] = e.type\n    return ret\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.to_id","title":"<code>to_id(e)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef to_id(e: Edge | EdgeId) -&gt; EdgeId:\n    if isinstance(e, Edge):\n        return e.id\n    else:\n        return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Edge.update","title":"<code>update(e, *, db=None)</code>  <code>classmethod</code>","text":"<p>Updates the edge in the database. Typically only called by Edge.save</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Self</code> <p>The edge to update</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The same edge that was passed in, for convenience</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef update(cls, e: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Updates the edge in the database. Typically only called by Edge.save\n\n    Args:\n        e (Self): The edge to update\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: The same edge that was passed in, for convenience\n    \"\"\"\n    if e._no_save:\n        return e\n\n    db = db or GraphDB.singleton()\n\n    params = {\"props\": Edge.to_dict(e)}\n\n    db.raw_execute(f\"MATCH ()-[e]-&gt;() WHERE id(e) = {e.id} SET e = $props\", params=params)\n\n    return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeCreateFailed","title":"<code>EdgeCreateFailed</code>","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeCreateFailed(Exception):\n    pass\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator","title":"<code>EdgeFetchIterator</code>","text":"<p>The implementation of an iterator for an EdgeList. Only intended to be used internally by EdgeList.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeFetchIterator:\n    \"\"\"The implementation of an iterator for an EdgeList. Only intended to be used internally by\n    EdgeList.\n    \"\"\"\n\n    def __init__(self, edge_list: list[EdgeId]):\n        self.__edge_list = edge_list\n        self.cur = 0\n\n    def __iter__(self) -&gt; EdgeFetchIterator:\n        return self\n\n    def __next__(self) -&gt; Edge:\n        if self.cur &gt;= len(self.__edge_list):\n            raise StopIteration\n\n        id = self.__edge_list[self.cur]\n        self.cur = self.cur + 1\n        return Edge.get(id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator.__edge_list","title":"<code>__edge_list = edge_list</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator.cur","title":"<code>cur = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator.__init__","title":"<code>__init__(edge_list)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, edge_list: list[EdgeId]):\n    self.__edge_list = edge_list\n    self.cur = 0\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __iter__(self) -&gt; EdgeFetchIterator:\n    return self\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeFetchIterator.__next__","title":"<code>__next__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __next__(self) -&gt; Edge:\n    if self.cur &gt;= len(self.__edge_list):\n        raise StopIteration\n\n    id = self.__edge_list[self.cur]\n    self.cur = self.cur + 1\n    return Edge.get(id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList","title":"<code>EdgeList</code>","text":"<p>               Bases: <code>MutableSet[Edge | EdgeId]</code>, <code>Mapping[int, Edge]</code></p> <p>A list of Edges that is used by Node for keeping track of the connections it has. Implements interfaces for both a MutableSet (i.e. set()) and a Mapping (i.e. read-only list())</p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeList(MutableSet[Edge | EdgeId], Mapping[int, Edge]):\n    \"\"\"A list of Edges that is used by Node for keeping track of the connections it has.\n    Implements interfaces for both a MutableSet (i.e. set()) and a Mapping (i.e. read-only list())\n    \"\"\"\n\n    def __init__(self, ids: list[EdgeId] | set[EdgeId]):\n        self.__edges: list[EdgeId] = list(ids)\n\n    def __iter__(self) -&gt; EdgeFetchIterator:\n        return EdgeFetchIterator(self.__edges)\n\n    def __getitem__(self, key: int) -&gt; Edge:\n        return Edge.get(self.__edges[key])\n\n    def __len__(self) -&gt; int:\n        return len(self.__edges)\n\n    def __contains__(self, e: Any) -&gt; bool:\n        if isinstance(e, Edge) or isinstance(e, int):\n            e_id = Edge.to_id(e)  # type: ignore\n        else:\n            return False\n\n        return e_id in self.__edges\n\n    def add(self, e: Edge | EdgeId) -&gt; None:\n        \"\"\"Adds a new Edge to the list\"\"\"\n        e_id = Edge.to_id(e)\n\n        if e_id in self.__edges:\n            return\n\n        self.__edges.append(e_id)\n\n    def discard(self, e: Edge | EdgeId) -&gt; None:\n        \"\"\"Removes an edge to the list\"\"\"\n        e_id = Edge.to_id(e)\n\n        self.__edges.remove(e_id)\n\n    def replace(self, old: Edge | EdgeId, new: Edge | EdgeId) -&gt; None:\n        \"\"\"Replaces all instances of an old Edge with a new Edge. Useful for when an Edge is\n        persisted to the graph database and its permanent ID is assigned\n        \"\"\"\n        old_id = Edge.to_id(old)\n        new_id = Edge.to_id(new)\n        for i in range(len(self.__edges)):\n            if self.__edges[i] == old_id:\n                self.__edges[i] = new_id\n\n    def count(self, f: EdgeFilter = None) -&gt; int:\n        return len(self.get_edges(f))\n\n    def get_edges(self, f: EdgeFilter = None) -&gt; list[Edge]:\n        if not f:\n            return list(self.__iter__())\n\n        if isinstance(f, str):\n            s = f\n            f = lambda e: e.type == s  # noqa: E731\n\n        if isinstance(f, int):\n            n = f\n            f = lambda e: e.id == n  # noqa: E731\n\n        return list(filter(f, self.__iter__()))\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__edges","title":"<code>__edges: list[EdgeId] = list(ids)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.EdgeList.__contains__","title":"<code>__contains__(e)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __contains__(self, e: Any) -&gt; bool:\n    if isinstance(e, Edge) or isinstance(e, int):\n        e_id = Edge.to_id(e)  # type: ignore\n    else:\n        return False\n\n    return e_id in self.__edges\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__getitem__","title":"<code>__getitem__(key)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __getitem__(self, key: int) -&gt; Edge:\n    return Edge.get(self.__edges[key])\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__init__","title":"<code>__init__(ids)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, ids: list[EdgeId] | set[EdgeId]):\n    self.__edges: list[EdgeId] = list(ids)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __iter__(self) -&gt; EdgeFetchIterator:\n    return EdgeFetchIterator(self.__edges)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.__len__","title":"<code>__len__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.__edges)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.add","title":"<code>add(e)</code>","text":"<p>Adds a new Edge to the list</p> Source code in <code>roc/graphdb.py</code> <pre><code>def add(self, e: Edge | EdgeId) -&gt; None:\n    \"\"\"Adds a new Edge to the list\"\"\"\n    e_id = Edge.to_id(e)\n\n    if e_id in self.__edges:\n        return\n\n    self.__edges.append(e_id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.count","title":"<code>count(f=None)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def count(self, f: EdgeFilter = None) -&gt; int:\n    return len(self.get_edges(f))\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.discard","title":"<code>discard(e)</code>","text":"<p>Removes an edge to the list</p> Source code in <code>roc/graphdb.py</code> <pre><code>def discard(self, e: Edge | EdgeId) -&gt; None:\n    \"\"\"Removes an edge to the list\"\"\"\n    e_id = Edge.to_id(e)\n\n    self.__edges.remove(e_id)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.get_edges","title":"<code>get_edges(f=None)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def get_edges(self, f: EdgeFilter = None) -&gt; list[Edge]:\n    if not f:\n        return list(self.__iter__())\n\n    if isinstance(f, str):\n        s = f\n        f = lambda e: e.type == s  # noqa: E731\n\n    if isinstance(f, int):\n        n = f\n        f = lambda e: e.id == n  # noqa: E731\n\n    return list(filter(f, self.__iter__()))\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeList.replace","title":"<code>replace(old, new)</code>","text":"<p>Replaces all instances of an old Edge with a new Edge. Useful for when an Edge is persisted to the graph database and its permanent ID is assigned</p> Source code in <code>roc/graphdb.py</code> <pre><code>def replace(self, old: Edge | EdgeId, new: Edge | EdgeId) -&gt; None:\n    \"\"\"Replaces all instances of an old Edge with a new Edge. Useful for when an Edge is\n    persisted to the graph database and its permanent ID is assigned\n    \"\"\"\n    old_id = Edge.to_id(old)\n    new_id = Edge.to_id(new)\n    for i in range(len(self.__edges)):\n        if self.__edges[i] == old_id:\n            self.__edges[i] = new_id\n</code></pre>"},{"location":"reference/graphdb/#graphdb.EdgeNotFound","title":"<code>EdgeNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>roc/graphdb.py</code> <pre><code>class EdgeNotFound(Exception):\n    pass\n</code></pre>"},{"location":"reference/graphdb/#graphdb.ErrorSavingDuringDelWarning","title":"<code>ErrorSavingDuringDelWarning</code>","text":"<p>               Bases: <code>Warning</code></p> <p>An error that occurs while saving a Node during del</p> Source code in <code>roc/graphdb.py</code> <pre><code>class ErrorSavingDuringDelWarning(Warning):\n    \"\"\"An error that occurs while saving a Node during __del__\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphCache","title":"<code>GraphCache</code>","text":"<p>               Bases: <code>LRUCache[CacheKey, CacheValue]</code>, <code>Generic[CacheKey, CacheValue]</code></p> <p>A generic cache that is used for both the Node cache and the Edge cache</p> Source code in <code>roc/graphdb.py</code> <pre><code>class GraphCache(LRUCache[CacheKey, CacheValue], Generic[CacheKey, CacheValue]):\n    \"\"\"A generic cache that is used for both the Node cache and the Edge cache\"\"\"\n\n    def __init__(self, maxsize: int):\n        super().__init__(maxsize=maxsize)\n        self.hits = 0\n        self.misses = 0\n\n    def __str__(self) -&gt; str:\n        return f\"Size: {self.currsize}/{self.maxsize} ({self.currsize/self.maxsize*100:1.2f}%), Hits: {self.hits}, Misses: {self.misses}\"\n\n    def get(  # type: ignore [override]\n        self,\n        key: CacheKey,\n        /,\n        default: CacheValue | None = None,\n    ) -&gt; CacheValue | None:\n        \"\"\"Uses the specified CacheKey to fetch an object from the cache.\n\n        Args:\n            key (CacheKey): The key to use to fetch the object\n            default (CacheValue | None, optional): If the object isn't found,\n                the default value to return. Defaults to None.\n\n        Returns:\n            CacheValue | None: The object from the cache, or None if not found.\n        \"\"\"\n        v = super().get(key)\n        if not v:\n            self.misses = self.misses + 1\n            if self.currsize == self.maxsize:\n                logger.warning(\n                    f\"Cache miss and cache is full ({self.currsize}/{self.maxsize}). Cache may start thrashing and performance may be impaired.\"\n                )\n        else:\n            self.hits = self.hits + 1\n        return v\n\n    def clear(self) -&gt; None:\n        \"\"\"Clears out all items from the cache and resets the cache\n        statistics\n        \"\"\"\n        super().clear()\n        self.hits = 0\n        self.misses = 0\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphCache.hits","title":"<code>hits = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphCache.misses","title":"<code>misses = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphCache.__init__","title":"<code>__init__(maxsize)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self, maxsize: int):\n    super().__init__(maxsize=maxsize)\n    self.hits = 0\n    self.misses = 0\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphCache.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"Size: {self.currsize}/{self.maxsize} ({self.currsize/self.maxsize*100:1.2f}%), Hits: {self.hits}, Misses: {self.misses}\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphCache.clear","title":"<code>clear()</code>","text":"<p>Clears out all items from the cache and resets the cache statistics</p> Source code in <code>roc/graphdb.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clears out all items from the cache and resets the cache\n    statistics\n    \"\"\"\n    super().clear()\n    self.hits = 0\n    self.misses = 0\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphCache.get","title":"<code>get(key, /, default=None)</code>","text":"<p>Uses the specified CacheKey to fetch an object from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>CacheKey</code> <p>The key to use to fetch the object</p> required <code>default</code> <code>CacheValue | None</code> <p>If the object isn't found, the default value to return. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>CacheValue | None</code> <p>CacheValue | None: The object from the cache, or None if not found.</p> Source code in <code>roc/graphdb.py</code> <pre><code>def get(  # type: ignore [override]\n    self,\n    key: CacheKey,\n    /,\n    default: CacheValue | None = None,\n) -&gt; CacheValue | None:\n    \"\"\"Uses the specified CacheKey to fetch an object from the cache.\n\n    Args:\n        key (CacheKey): The key to use to fetch the object\n        default (CacheValue | None, optional): If the object isn't found,\n            the default value to return. Defaults to None.\n\n    Returns:\n        CacheValue | None: The object from the cache, or None if not found.\n    \"\"\"\n    v = super().get(key)\n    if not v:\n        self.misses = self.misses + 1\n        if self.currsize == self.maxsize:\n            logger.warning(\n                f\"Cache miss and cache is full ({self.currsize}/{self.maxsize}). Cache may start thrashing and performance may be impaired.\"\n            )\n    else:\n        self.hits = self.hits + 1\n    return v\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB","title":"<code>GraphDB</code>","text":"<p>A graph database singleton. Settings for the graph database come from the config module.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class GraphDB:\n    \"\"\"A graph database singleton. Settings for the graph database come from the config module.\"\"\"\n\n    def __init__(self) -&gt; None:\n        settings = Config.get()\n        self.host = settings.db_host\n        self.port = settings.db_port\n        self.encrypted = settings.db_conn_encrypted\n        self.username = settings.db_username\n        self.password = settings.db_password\n        self.lazy = settings.db_lazy\n        self.client_name = \"roc-graphdb-client\"\n        self.db_conn = self.connect()\n        self.closed = False\n\n    def raw_fetch(\n        self, query: str, *, params: dict[str, Any] | None = None\n    ) -&gt; Iterator[dict[str, Any]]:\n        \"\"\"Executes a Cypher query and returns the results as an iterator of\n        dictionaries. Used for any query that has a 'RETURN' clause.\n\n        Args:\n            query (str): The Cypher query to execute\n            params (dict[str, Any] | None, optional): Any parameters to pass to\n                the query. Defaults to None. See also: https://memgraph.com/docs/querying/expressions#parameters\n\n        Yields:\n            Iterator[dict[str, Any]]: An iterator of the results from the database.\n        \"\"\"\n        params = params or {}\n        logger.trace(f\"raw_fetch: '{query}' *** with params: *** '{params}\")\n\n        cursor = self.db_conn.cursor()\n        cursor.execute(query, params)\n        while True:\n            row = cursor.fetchone()\n            if row is None:\n                break\n            yield {dsc.name: row[index] for index, dsc in enumerate(cursor.description)}\n\n    def raw_execute(self, query: str, *, params: dict[str, Any] | None = None) -&gt; None:\n        \"\"\"Executes a query with no return value. Used for 'SET', 'DELETE' or\n        other queries without a 'RETURN' clause.\n\n        Args:\n            query (str): The Cypher query to execute\n            params (dict[str, Any] | None, optional): Any parameters to pass to\n                the query. Defaults to None. See also: https://memgraph.com/docs/querying/expressions#parameters\n        \"\"\"\n        params = params or {}\n        logger.trace(f\"raw_execute: '{query}' *** with params: *** '{params}'\")\n\n        cursor = self.db_conn.cursor()\n        cursor.execute(query, params)\n        cursor.fetchall()\n\n    def connected(self) -&gt; bool:\n        \"\"\"Returns True if the database is connected, False otherwise\"\"\"\n        return self.db_conn is not None and self.db_conn.status == mgclient.CONN_STATUS_READY\n\n    def connect(self) -&gt; mgclient.Connection:\n        \"\"\"Connects to the database and returns a Connection object\"\"\"\n        sslmode = mgclient.MG_SSLMODE_REQUIRE if self.encrypted else mgclient.MG_SSLMODE_DISABLE\n        connection = mgclient.connect(\n            host=self.host,\n            port=self.port,\n            username=self.username,\n            password=self.password,\n            sslmode=sslmode,\n            lazy=self.lazy,\n            client_name=self.client_name,\n        )\n        connection.autocommit = True\n        return connection\n\n    def close(self) -&gt; None:\n        \"\"\"Closes the connection to the database\"\"\"\n        self.db_conn.close()\n        self.closed = True\n\n    @classmethod\n    def singleton(cls) -&gt; GraphDB:\n        \"\"\"This returns a singleton object for the graph database. If the\n        singleton isn't created yet, it creates it.\n        \"\"\"\n        global graph_db_singleton\n        if not graph_db_singleton:\n            graph_db_singleton = GraphDB()\n\n        assert graph_db_singleton.closed is False\n        return graph_db_singleton\n\n    @staticmethod\n    def to_networkx(\n        db: GraphDB | None = None,\n        node_ids: set[NodeId] | None = None,\n        filter: NodeFilterFn | None = None,\n    ) -&gt; nx.DiGraph:\n        \"\"\"Converts the entire graph database (and local cache of objects) into\n        a NetworkX graph\n\n        Args:\n            db (GraphDB | None, optional): The database to convert to NetworkX.\n                Defaults to the GraphDB singleton if not specified.\n            node_ids (set[NodeId] | None, optional): The NodeIDs to add to the\n                NetworkX graph. Defaults to all IDs if not specified.\n            filter (NodeFilterFn | None, optional): A Node filter to filter out\n                nodes before adding them to the NetworkX graph. Also useful for a\n                callback that can be used for progress updates. Defaults to None.\n\n        Returns:\n            nx.DiGraph: _description_\n        \"\"\"\n        db = db or GraphDB.singleton()\n        node_ids = node_ids or Node.all_ids(db=db)\n        filter = filter or true_filter\n        G = nx.DiGraph()\n\n        def nx_add(n: Node) -&gt; None:\n            n_data = Node.to_dict(n, include_labels=True)\n\n            # TODO: this converts labels to a string, but maybe there's a better\n            # way to preserve the list so that it can be used for filtering in\n            # external programs\n            if \"labels\" in n_data and isinstance(n_data[\"labels\"], set):\n                n_data[\"labels\"] = \", \".join(n_data[\"labels\"])\n\n            G.add_node(n.id, **n_data)\n\n            for e in n.src_edges:\n                e_data = Edge.to_dict(e, include_type=True)\n                G.add_edge(e.src_id, e.dst_id, **e_data)\n\n        # iterate all specified node_ids, adding all of them to the nx graph\n        def nx_add_many(nodes: list[Node]) -&gt; None:\n            for n in nodes:\n                if filter(n):\n                    nx_add(n)\n\n        Node.get_many(node_ids, load_edges=True, progress_callback=nx_add_many)\n\n        return G\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.client_name","title":"<code>client_name = 'roc-graphdb-client'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.closed","title":"<code>closed = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.db_conn","title":"<code>db_conn = self.connect()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.encrypted","title":"<code>encrypted = settings.db_conn_encrypted</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.host","title":"<code>host = settings.db_host</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.lazy","title":"<code>lazy = settings.db_lazy</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.password","title":"<code>password = settings.db_password</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.port","title":"<code>port = settings.db_port</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.username","title":"<code>username = settings.db_username</code>  <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.GraphDB.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(self) -&gt; None:\n    settings = Config.get()\n    self.host = settings.db_host\n    self.port = settings.db_port\n    self.encrypted = settings.db_conn_encrypted\n    self.username = settings.db_username\n    self.password = settings.db_password\n    self.lazy = settings.db_lazy\n    self.client_name = \"roc-graphdb-client\"\n    self.db_conn = self.connect()\n    self.closed = False\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.close","title":"<code>close()</code>","text":"<p>Closes the connection to the database</p> Source code in <code>roc/graphdb.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Closes the connection to the database\"\"\"\n    self.db_conn.close()\n    self.closed = True\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.connect","title":"<code>connect()</code>","text":"<p>Connects to the database and returns a Connection object</p> Source code in <code>roc/graphdb.py</code> <pre><code>def connect(self) -&gt; mgclient.Connection:\n    \"\"\"Connects to the database and returns a Connection object\"\"\"\n    sslmode = mgclient.MG_SSLMODE_REQUIRE if self.encrypted else mgclient.MG_SSLMODE_DISABLE\n    connection = mgclient.connect(\n        host=self.host,\n        port=self.port,\n        username=self.username,\n        password=self.password,\n        sslmode=sslmode,\n        lazy=self.lazy,\n        client_name=self.client_name,\n    )\n    connection.autocommit = True\n    return connection\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.connected","title":"<code>connected()</code>","text":"<p>Returns True if the database is connected, False otherwise</p> Source code in <code>roc/graphdb.py</code> <pre><code>def connected(self) -&gt; bool:\n    \"\"\"Returns True if the database is connected, False otherwise\"\"\"\n    return self.db_conn is not None and self.db_conn.status == mgclient.CONN_STATUS_READY\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.raw_execute","title":"<code>raw_execute(query, *, params=None)</code>","text":"<p>Executes a query with no return value. Used for 'SET', 'DELETE' or other queries without a 'RETURN' clause.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The Cypher query to execute</p> required <code>params</code> <code>dict[str, Any] | None</code> <p>Any parameters to pass to the query. Defaults to None. See also: https://memgraph.com/docs/querying/expressions#parameters</p> <code>None</code> Source code in <code>roc/graphdb.py</code> <pre><code>def raw_execute(self, query: str, *, params: dict[str, Any] | None = None) -&gt; None:\n    \"\"\"Executes a query with no return value. Used for 'SET', 'DELETE' or\n    other queries without a 'RETURN' clause.\n\n    Args:\n        query (str): The Cypher query to execute\n        params (dict[str, Any] | None, optional): Any parameters to pass to\n            the query. Defaults to None. See also: https://memgraph.com/docs/querying/expressions#parameters\n    \"\"\"\n    params = params or {}\n    logger.trace(f\"raw_execute: '{query}' *** with params: *** '{params}'\")\n\n    cursor = self.db_conn.cursor()\n    cursor.execute(query, params)\n    cursor.fetchall()\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.raw_fetch","title":"<code>raw_fetch(query, *, params=None)</code>","text":"<p>Executes a Cypher query and returns the results as an iterator of dictionaries. Used for any query that has a 'RETURN' clause.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The Cypher query to execute</p> required <code>params</code> <code>dict[str, Any] | None</code> <p>Any parameters to pass to the query. Defaults to None. See also: https://memgraph.com/docs/querying/expressions#parameters</p> <code>None</code> <p>Yields:</p> Type Description <code>dict[str, Any]</code> <p>Iterator[dict[str, Any]]: An iterator of the results from the database.</p> Source code in <code>roc/graphdb.py</code> <pre><code>def raw_fetch(\n    self, query: str, *, params: dict[str, Any] | None = None\n) -&gt; Iterator[dict[str, Any]]:\n    \"\"\"Executes a Cypher query and returns the results as an iterator of\n    dictionaries. Used for any query that has a 'RETURN' clause.\n\n    Args:\n        query (str): The Cypher query to execute\n        params (dict[str, Any] | None, optional): Any parameters to pass to\n            the query. Defaults to None. See also: https://memgraph.com/docs/querying/expressions#parameters\n\n    Yields:\n        Iterator[dict[str, Any]]: An iterator of the results from the database.\n    \"\"\"\n    params = params or {}\n    logger.trace(f\"raw_fetch: '{query}' *** with params: *** '{params}\")\n\n    cursor = self.db_conn.cursor()\n    cursor.execute(query, params)\n    while True:\n        row = cursor.fetchone()\n        if row is None:\n            break\n        yield {dsc.name: row[index] for index, dsc in enumerate(cursor.description)}\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.singleton","title":"<code>singleton()</code>  <code>classmethod</code>","text":"<p>This returns a singleton object for the graph database. If the singleton isn't created yet, it creates it.</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef singleton(cls) -&gt; GraphDB:\n    \"\"\"This returns a singleton object for the graph database. If the\n    singleton isn't created yet, it creates it.\n    \"\"\"\n    global graph_db_singleton\n    if not graph_db_singleton:\n        graph_db_singleton = GraphDB()\n\n    assert graph_db_singleton.closed is False\n    return graph_db_singleton\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDB.to_networkx","title":"<code>to_networkx(db=None, node_ids=None, filter=None)</code>  <code>staticmethod</code>","text":"<p>Converts the entire graph database (and local cache of objects) into a NetworkX graph</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>GraphDB | None</code> <p>The database to convert to NetworkX. Defaults to the GraphDB singleton if not specified.</p> <code>None</code> <code>node_ids</code> <code>set[NodeId] | None</code> <p>The NodeIDs to add to the NetworkX graph. Defaults to all IDs if not specified.</p> <code>None</code> <code>filter</code> <code>NodeFilterFn | None</code> <p>A Node filter to filter out nodes before adding them to the NetworkX graph. Also useful for a callback that can be used for progress updates. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DiGraph</code> <p>nx.DiGraph: description</p> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef to_networkx(\n    db: GraphDB | None = None,\n    node_ids: set[NodeId] | None = None,\n    filter: NodeFilterFn | None = None,\n) -&gt; nx.DiGraph:\n    \"\"\"Converts the entire graph database (and local cache of objects) into\n    a NetworkX graph\n\n    Args:\n        db (GraphDB | None, optional): The database to convert to NetworkX.\n            Defaults to the GraphDB singleton if not specified.\n        node_ids (set[NodeId] | None, optional): The NodeIDs to add to the\n            NetworkX graph. Defaults to all IDs if not specified.\n        filter (NodeFilterFn | None, optional): A Node filter to filter out\n            nodes before adding them to the NetworkX graph. Also useful for a\n            callback that can be used for progress updates. Defaults to None.\n\n    Returns:\n        nx.DiGraph: _description_\n    \"\"\"\n    db = db or GraphDB.singleton()\n    node_ids = node_ids or Node.all_ids(db=db)\n    filter = filter or true_filter\n    G = nx.DiGraph()\n\n    def nx_add(n: Node) -&gt; None:\n        n_data = Node.to_dict(n, include_labels=True)\n\n        # TODO: this converts labels to a string, but maybe there's a better\n        # way to preserve the list so that it can be used for filtering in\n        # external programs\n        if \"labels\" in n_data and isinstance(n_data[\"labels\"], set):\n            n_data[\"labels\"] = \", \".join(n_data[\"labels\"])\n\n        G.add_node(n.id, **n_data)\n\n        for e in n.src_edges:\n            e_data = Edge.to_dict(e, include_type=True)\n            G.add_edge(e.src_id, e.dst_id, **e_data)\n\n    # iterate all specified node_ids, adding all of them to the nx graph\n    def nx_add_many(nodes: list[Node]) -&gt; None:\n        for n in nodes:\n            if filter(n):\n                nx_add(n)\n\n    Node.get_many(node_ids, load_edges=True, progress_callback=nx_add_many)\n\n    return G\n</code></pre>"},{"location":"reference/graphdb/#graphdb.GraphDBInternalError","title":"<code>GraphDBInternalError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>An generic exception for unexpected errors</p> Source code in <code>roc/graphdb.py</code> <pre><code>class GraphDBInternalError(Exception):\n    \"\"\"An generic exception for unexpected errors\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node","title":"<code>Node</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An graph database node that automatically handles CRUD for the underlying graph database objects</p> Source code in <code>roc/graphdb.py</code> <pre><code>class Node(BaseModel, extra=\"allow\"):\n    \"\"\"An graph database node that automatically handles CRUD for the underlying graph database objects\"\"\"\n\n    _id: NodeId\n    labels: set[str] = Field(exclude=True, default_factory=lambda: set())\n    _orig_labels: set[str]\n    _src_edges: EdgeList\n    _dst_edges: EdgeList\n    _db: GraphDB\n    _new = False\n    _no_save = False\n    _deleted = False\n\n    @property\n    def id(self) -&gt; NodeId:\n        return self._id\n\n    @property\n    def src_edges(self) -&gt; EdgeList:\n        return self._src_edges\n\n    @property\n    def dst_edges(self) -&gt; EdgeList:\n        return self._dst_edges\n\n    @property\n    def new(self) -&gt; bool:\n        return self._new\n\n    def __init__(\n        self,\n        **kwargs: Any,\n    ):\n        super().__init__(**kwargs)\n\n        # set passed-in private values or their defaults\n        self._db = kwargs[\"_db\"] if \"_db\" in kwargs else GraphDB.singleton()\n        self._id = kwargs[\"_id\"] if \"_id\" in kwargs else get_next_new_node_id()\n        self._src_edges = kwargs[\"_src_edges\"] if \"_src_edges\" in kwargs else EdgeList([])\n        self._dst_edges = kwargs[\"_dst_edges\"] if \"_dst_edges\" in kwargs else EdgeList([])\n\n        if self.id &lt; 0:\n            self._new = True  # TODO: derived?\n            Node.get_cache()[self.id] = self\n\n        self._orig_labels = self.labels.copy()\n\n    def __del__(self) -&gt; None:\n        # print(\"Node.__del__:\", self)\n        try:\n            self.__class__.save(self, db=self._db)\n        except Exception as e:\n            err_msg = f\"error saving during del: {e}\"\n            # logger.warning(err_msg)\n            warnings.warn(err_msg, ErrorSavingDuringDelWarning)\n\n    def __repr__(self) -&gt; str:\n        return f\"Node({self.id})\"\n\n    def __str__(self) -&gt; str:\n        return f\"Node({self.id}, labels={self.labels})\"\n\n    @classmethod\n    def load(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Loads a node from the database. Use `Node.get` or other methods instead.\n\n        Args:\n            id (NodeId): The identifier of the node to fetch\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            NodeNotFound: The node specified by the identifier does not exist in the database\n            GraphDBInternalError: If the requested ID returns multiple nodes\n\n        Returns:\n            Self: The node from the database\n        \"\"\"\n        res = cls.load_many(\n            {\n                id,\n            },\n            db=db,\n        )\n\n        # print(\"RES\", res)\n\n        if len(res) &lt; 1:\n            raise NodeNotFound(f\"Couldn't find node ID: {id}\")\n\n        if len(res) &gt; 1:\n            raise GraphDBInternalError(\n                f\"Too many nodes returned while trying to load single node: {id}\"\n            )\n\n        return res[0]\n\n    @classmethod\n    def load_many(\n        cls, node_set: set[NodeId], db: GraphDB | None = NotImplemented, load_edges: bool = False\n    ) -&gt; list[Self]:\n        db = db or GraphDB.singleton()\n        node_ids = \",\".join(map(str, node_set))\n\n        if load_edges:\n            edge_fmt = \"e\"\n        else:\n            edge_fmt = \"{id: id(e), start: id(startNode(e)), end: id(endNode(e))}\"\n        res_iter = db.raw_fetch(\n            f\"\"\"\n                MATCH (n)-[e]-(m) WHERE id(n) IN [{node_ids}]\n                RETURN n, collect({edge_fmt}) AS edges\n                \"\"\",\n        )\n\n        # edges = list(\n        #     map(lambda r: {\"id\": r[\"e_id\"], \"start\": r[\"e_start\"], \"end\": r[\"e_end\"]}, res)\n        # )\n        # src_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"start\"] == id, edges)))\n        # dst_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"end\"] == id, edges)))\n\n        ret_list = list()\n        for r in res_iter:\n            n = r[\"n\"]\n            if n is None:\n                raise NodeNotFound(f\"Couldn't find node ID: {id}\")\n\n            if load_edges:\n                # XXX: memgraph converts edges to Relationship objects if you\n                # return the whole edge\n                src_edges = list()\n                dst_edges = list()\n                edge_cache = Edge.get_cache()\n                for e in r[\"edges\"]:\n                    # add edge_id to to the right list for the node creation below\n                    if n.id == e.start_id:\n                        src_edges.append(e.id)\n                    else:\n                        dst_edges.append(e.id)\n\n                    # edge already loaded, continue to next one\n                    if e.id in edge_cache:\n                        continue\n\n                    # create a new edge\n                    props = None\n                    if hasattr(e, \"properties\"):\n                        props = e.properties\n                    new_edge = Edge(\n                        e.start_id,\n                        e.end_id,\n                        id=e.id,\n                        data=props,\n                        type=e.type,\n                    )\n                    edge_cache[e.id] = new_edge\n            else:\n                src_edges = [e[\"id\"] for e in r[\"edges\"] if e[\"start\"] == n.id]\n                dst_edges = [e[\"id\"] for e in r[\"edges\"] if e[\"end\"] == n.id]\n            new_node = cls(\n                _id=n.id,\n                _src_edges=EdgeList(src_edges),\n                _dst_edges=EdgeList(dst_edges),\n                labels=n.labels,\n                **n.properties,\n            )\n            ret_list.append(new_node)\n\n        return ret_list\n\n    @classmethod\n    def get_many(\n        cls,\n        node_ids: set[NodeId],\n        *,\n        batch_size: int = 128,\n        db: GraphDB | None = None,\n        load_edges: bool = False,\n        return_nodes: bool = False,\n        progress_callback: ProgressFn | None = None,\n    ) -&gt; list[Node]:\n        db = db or GraphDB.singleton()\n\n        c = Node.get_cache()\n        if len(node_ids) &gt; c.maxsize:\n            raise GraphDBInternalError(\n                f\"get_many attempting to load more nodes than cache size ({len(node_ids)} &gt; {c.maxsize})\"\n            )\n\n        cache_ids = set(c.keys())\n        fetch_ids = node_ids - cache_ids\n\n        start = 0\n        curr = batch_size\n        ret_list = [c[nid] for nid in c]\n        if progress_callback:\n            progress_callback(ret_list)\n        while start &lt; len(fetch_ids):\n            id_set = set(islice(fetch_ids, start, curr))\n\n            res = cls.load_many(id_set, db=db, load_edges=load_edges)\n            for n in res:\n                c[n.id] = n\n\n            if progress_callback:\n                progress_callback(res)\n\n            ret_list.extend(res)\n            # import pprint\n            # pprint.pp(list(res))\n            # print(f\"got {len(list(res))} nodes\")\n\n            start = curr\n            curr += batch_size\n\n        assert len(ret_list) == len(node_ids)\n        return ret_list\n\n    @classmethod\n    def get_cache(cls) -&gt; NodeCache:\n        global node_cache\n        if node_cache is None:\n            settings = Config.get()\n            node_cache = NodeCache(settings.node_cache_size)\n\n        return node_cache\n\n    @classmethod\n    def get(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Returns a cached node with the specified id. If no node is cached, it is retrieved from\n        the database.\n\n\n        Args:\n            id (NodeId): The unique identifier of the node to fetch\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: the cached or newly retrieved node\n        \"\"\"\n        cache = Node.get_cache()\n        n = cache.get(id)\n        if not n:\n            n = cls.load(id, db=db)\n            cache[id] = n\n\n        return cast(Self, n)\n\n    @classmethod\n    def save(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Save a node to persistent storage\n\n        Writes the specified node to the GraphDB for persistent storage. If the node does not\n        already exist in storage, it is created via the `create` method. If the node does exist, it\n        is updated via the `update` method.\n\n        If the _no_save flag is True on the node, the save request will be silently ignored.\n\n        Args:\n            n (Self): The Node to be saved\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: As a convenience, the node that was stored is returned. This may be useful\n            since the the id of the node may change if it was created in the database.\n        \"\"\"\n        if n._new:\n            return cls.create(n, db=db)\n        else:\n            return cls.update(n, db=db)\n\n    @classmethod\n    def update(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Update an existing node in the GraphDB.\n\n        Calling `save` is preferred to using this method so that the caller doesn't need to know the\n        state of the node.\n\n        Args:\n            n (Self): The node to be updated\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Self: The node that was passed in, for convenience\n        \"\"\"\n        if n._no_save:\n            return n\n\n        db = db or GraphDB.singleton()\n\n        orig_labels = n._orig_labels\n        curr_labels = set(n.labels)\n        new_labels = curr_labels - orig_labels\n        rm_labels = orig_labels - curr_labels\n        set_label_str = Node.mklabels(new_labels)\n        if set_label_str:\n            set_query = f\"SET n{set_label_str}, n = $props\"\n        else:\n            set_query = \"SET n = $props\"\n        rm_label_str = Node.mklabels(rm_labels)\n        if rm_label_str:\n            rm_query = f\"REMOVE n{rm_label_str}\"\n        else:\n            rm_query = \"\"\n\n        params = {\"props\": Node.to_dict(n)}\n\n        db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} {set_query} {rm_query}\", params=params)\n\n        return n\n\n    @classmethod\n    def create(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n        \"\"\"Creates the specified node in the GraphDB.\n\n        Calling `save` is preferred to using this method so that the caller doesn't need to know the\n        state of the node.\n\n        Args:\n            n (Self): the node to be created\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Raises:\n            NodeCreationFailed: if creating the node failed in the database\n\n        Returns:\n            Self: the node that was passed in, albeit with a new `id` and potenitally other new\n            fields\n        \"\"\"\n        if n._no_save:\n            return n\n\n        db = db or GraphDB.singleton()\n        old_id = n.id\n\n        label_str = Node.mklabels(n.labels)\n        params = {\"props\": Node.to_dict(n)}\n\n        res = list(db.raw_fetch(f\"CREATE (n{label_str} $props) RETURN id(n) as id\", params=params))\n\n        if not len(res) &gt;= 1:\n            raise NodeCreationFailed(f\"Couldn't create node ID: {id}\")\n\n        new_id = res[0][\"id\"]\n        n._id = new_id\n        n._new = False\n        # update the cache; if being called during c then the cache entry may not exist\n        try:\n            cache = Node.get_cache()\n            del cache[old_id]\n            cache[new_id] = n\n        except KeyError:\n            pass\n\n        for e in n.src_edges:\n            assert e.src_id == old_id\n            e.src_id = new_id\n\n        for e in n.dst_edges:\n            assert e.dst_id == old_id\n            e.dst_id = new_id\n\n        return n\n\n    @classmethod\n    def connect(\n        cls,\n        src: NodeId | Self,\n        dst: NodeId | Self,\n        type: str,\n        *,\n        db: GraphDB | None = None,\n    ) -&gt; Edge:\n        \"\"\"Connects two nodes (creates an Edge between two nodes)\n\n        Args:\n            src (NodeId | Node): _description_\n            dst (NodeId | Node): _description_\n            type (str): _description_\n            db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n        Returns:\n            Edge: _description_\n        \"\"\"\n        if isinstance(src, Node):\n            src_id = src.id\n        else:\n            src_id = src\n\n        if isinstance(dst, Node):\n            dst_id = dst.id\n        else:\n            dst_id = dst\n\n        e = Edge(src_id, dst_id, type)\n        src_node = cls.get(src_id, db=db)\n        dst_node = cls.get(dst_id, db=db)\n        src_node.src_edges.add(e)\n        dst_node.dst_edges.add(e)\n        return e\n\n    @staticmethod\n    def delete(n: Node, *, db: GraphDB | None = None) -&gt; None:\n        db = db or GraphDB.singleton()\n\n        # remove edges\n        for e in n.src_edges:\n            Edge.delete(e)\n\n        for e in n.dst_edges:\n            Edge.delete(e)\n\n        # remove from cache\n        node_cache = Node.get_cache()\n        if n.id in node_cache:\n            del node_cache[n.id]\n\n        if not n._new:\n            db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} DELETE n\")\n\n        n._deleted = True\n        n._no_save = True\n\n    @staticmethod\n    def to_dict(n: Node, include_labels: bool = False) -&gt; dict[str, Any]:\n        \"\"\"Convert a Node to a Python dictionary\"\"\"\n        # XXX: the excluded fields below shouldn't have been included in the\n        # first place because Pythonic should exclude fields with underscores\n        ret = n.model_dump(exclude={\"_id\", \"_src_edges\", \"_dst_edges\"})\n\n        if include_labels and hasattr(n, \"labels\"):\n            ret[\"labels\"] = n.labels\n\n        return ret\n\n    @staticmethod\n    def mklabels(labels: set[str]) -&gt; str:\n        \"\"\"Converts a list of strings into proper Cypher syntax for a graph database query\"\"\"\n        labels_list = [i for i in labels]\n        labels_list.sort()\n        label_str = \":\".join(labels_list)\n        if len(label_str) &gt; 0:\n            label_str = \":\" + label_str\n        return label_str\n\n    @staticmethod\n    def all_ids(db: GraphDB | None = None) -&gt; set[NodeId]:\n        \"\"\"Returns an exhaustive Set of all NodeIds that exist in both the graph\n        database and the NodeCache\n        \"\"\"\n        db = db or GraphDB.singleton()\n\n        # get all NodeIds in the cache\n        c = Node.get_cache()\n        cached_ids = set(c.keys())\n\n        # get all NodeIds in the database\n        db_ids = {n[\"id\"] for n in db.raw_fetch(\"MATCH (n) RETURN id(n) as id\")}\n\n        # return the combination of both\n        return db_ids.union(cached_ids)\n\n    @staticmethod\n    def walk(\n        n: Node,\n        *,\n        mode: WalkMode = \"both\",\n        edge_filter: EdgeFilterFn | None = None,\n        # edge_callback: EdgeCallbackFn | None = None,\n        node_filter: NodeFilterFn | None = None,\n        node_callback: NodeCallbackFn | None = None,\n        _walk_history: set[int] | None = None,\n    ) -&gt; None:\n        # if we have walked this node before, just return\n        _walk_history = _walk_history or set()\n        if n.id in _walk_history:\n            return\n        _walk_history.add(n.id)\n\n        edge_filter = edge_filter or true_filter\n        node_filter = node_filter or true_filter\n        # edge_callback = edge_callback or no_callback\n        node_callback = node_callback or no_callback\n\n        # callback for this node, if not filtered\n        if node_filter(n):\n            node_callback(n)\n        else:\n            return\n\n        if mode == \"src\" or mode == \"both\":\n            for e in n.src_edges:\n                if edge_filter(e):\n                    Node.walk(\n                        e.dst,\n                        mode=mode,\n                        edge_filter=edge_filter,\n                        # edge_callback=edge_callback,\n                        node_filter=node_filter,\n                        node_callback=node_callback,\n                        _walk_history=_walk_history,\n                    )\n\n        if mode == \"dst\" or mode == \"both\":\n            for e in n.dst_edges:\n                if edge_filter(e):\n                    Node.walk(\n                        e.src,\n                        mode=mode,\n                        edge_filter=edge_filter,\n                        # edge_callback=edge_callback,\n                        node_filter=node_filter,\n                        node_callback=node_callback,\n                        _walk_history=_walk_history,\n                    )\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.dst_edges","title":"<code>dst_edges: EdgeList</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Node.id","title":"<code>id: NodeId</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Node.labels","title":"<code>labels: set[str] = Field(exclude=True, default_factory=lambda: set())</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/graphdb/#graphdb.Node.new","title":"<code>new: bool</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Node.src_edges","title":"<code>src_edges: EdgeList</code>  <code>property</code>","text":""},{"location":"reference/graphdb/#graphdb.Node.__del__","title":"<code>__del__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __del__(self) -&gt; None:\n    # print(\"Node.__del__:\", self)\n    try:\n        self.__class__.save(self, db=self._db)\n    except Exception as e:\n        err_msg = f\"error saving during del: {e}\"\n        # logger.warning(err_msg)\n        warnings.warn(err_msg, ErrorSavingDuringDelWarning)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.__init__","title":"<code>__init__(**kwargs)</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __init__(\n    self,\n    **kwargs: Any,\n):\n    super().__init__(**kwargs)\n\n    # set passed-in private values or their defaults\n    self._db = kwargs[\"_db\"] if \"_db\" in kwargs else GraphDB.singleton()\n    self._id = kwargs[\"_id\"] if \"_id\" in kwargs else get_next_new_node_id()\n    self._src_edges = kwargs[\"_src_edges\"] if \"_src_edges\" in kwargs else EdgeList([])\n    self._dst_edges = kwargs[\"_dst_edges\"] if \"_dst_edges\" in kwargs else EdgeList([])\n\n    if self.id &lt; 0:\n        self._new = True  # TODO: derived?\n        Node.get_cache()[self.id] = self\n\n    self._orig_labels = self.labels.copy()\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"Node({self.id})\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"Node({self.id}, labels={self.labels})\"\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.all_ids","title":"<code>all_ids(db=None)</code>  <code>staticmethod</code>","text":"<p>Returns an exhaustive Set of all NodeIds that exist in both the graph database and the NodeCache</p> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef all_ids(db: GraphDB | None = None) -&gt; set[NodeId]:\n    \"\"\"Returns an exhaustive Set of all NodeIds that exist in both the graph\n    database and the NodeCache\n    \"\"\"\n    db = db or GraphDB.singleton()\n\n    # get all NodeIds in the cache\n    c = Node.get_cache()\n    cached_ids = set(c.keys())\n\n    # get all NodeIds in the database\n    db_ids = {n[\"id\"] for n in db.raw_fetch(\"MATCH (n) RETURN id(n) as id\")}\n\n    # return the combination of both\n    return db_ids.union(cached_ids)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.connect","title":"<code>connect(src, dst, type, *, db=None)</code>  <code>classmethod</code>","text":"<p>Connects two nodes (creates an Edge between two nodes)</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>NodeId | Node</code> <p>description</p> required <code>dst</code> <code>NodeId | Node</code> <p>description</p> required <code>type</code> <code>str</code> <p>description</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Edge</code> <code>Edge</code> <p>description</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef connect(\n    cls,\n    src: NodeId | Self,\n    dst: NodeId | Self,\n    type: str,\n    *,\n    db: GraphDB | None = None,\n) -&gt; Edge:\n    \"\"\"Connects two nodes (creates an Edge between two nodes)\n\n    Args:\n        src (NodeId | Node): _description_\n        dst (NodeId | Node): _description_\n        type (str): _description_\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Edge: _description_\n    \"\"\"\n    if isinstance(src, Node):\n        src_id = src.id\n    else:\n        src_id = src\n\n    if isinstance(dst, Node):\n        dst_id = dst.id\n    else:\n        dst_id = dst\n\n    e = Edge(src_id, dst_id, type)\n    src_node = cls.get(src_id, db=db)\n    dst_node = cls.get(dst_id, db=db)\n    src_node.src_edges.add(e)\n    dst_node.dst_edges.add(e)\n    return e\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.create","title":"<code>create(n, *, db=None)</code>  <code>classmethod</code>","text":"<p>Creates the specified node in the GraphDB.</p> <p>Calling <code>save</code> is preferred to using this method so that the caller doesn't need to know the state of the node.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Self</code> <p>the node to be created</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>NodeCreationFailed</code> <p>if creating the node failed in the database</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the node that was passed in, albeit with a new <code>id</code> and potenitally other new</p> <code>Self</code> <p>fields</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef create(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Creates the specified node in the GraphDB.\n\n    Calling `save` is preferred to using this method so that the caller doesn't need to know the\n    state of the node.\n\n    Args:\n        n (Self): the node to be created\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        NodeCreationFailed: if creating the node failed in the database\n\n    Returns:\n        Self: the node that was passed in, albeit with a new `id` and potenitally other new\n        fields\n    \"\"\"\n    if n._no_save:\n        return n\n\n    db = db or GraphDB.singleton()\n    old_id = n.id\n\n    label_str = Node.mklabels(n.labels)\n    params = {\"props\": Node.to_dict(n)}\n\n    res = list(db.raw_fetch(f\"CREATE (n{label_str} $props) RETURN id(n) as id\", params=params))\n\n    if not len(res) &gt;= 1:\n        raise NodeCreationFailed(f\"Couldn't create node ID: {id}\")\n\n    new_id = res[0][\"id\"]\n    n._id = new_id\n    n._new = False\n    # update the cache; if being called during c then the cache entry may not exist\n    try:\n        cache = Node.get_cache()\n        del cache[old_id]\n        cache[new_id] = n\n    except KeyError:\n        pass\n\n    for e in n.src_edges:\n        assert e.src_id == old_id\n        e.src_id = new_id\n\n    for e in n.dst_edges:\n        assert e.dst_id == old_id\n        e.dst_id = new_id\n\n    return n\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.delete","title":"<code>delete(n, *, db=None)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef delete(n: Node, *, db: GraphDB | None = None) -&gt; None:\n    db = db or GraphDB.singleton()\n\n    # remove edges\n    for e in n.src_edges:\n        Edge.delete(e)\n\n    for e in n.dst_edges:\n        Edge.delete(e)\n\n    # remove from cache\n    node_cache = Node.get_cache()\n    if n.id in node_cache:\n        del node_cache[n.id]\n\n    if not n._new:\n        db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} DELETE n\")\n\n    n._deleted = True\n    n._no_save = True\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.get","title":"<code>get(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Returns a cached node with the specified id. If no node is cached, it is retrieved from the database.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>NodeId</code> <p>The unique identifier of the node to fetch</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the cached or newly retrieved node</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Returns a cached node with the specified id. If no node is cached, it is retrieved from\n    the database.\n\n\n    Args:\n        id (NodeId): The unique identifier of the node to fetch\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: the cached or newly retrieved node\n    \"\"\"\n    cache = Node.get_cache()\n    n = cache.get(id)\n    if not n:\n        n = cls.load(id, db=db)\n        cache[id] = n\n\n    return cast(Self, n)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.get_cache","title":"<code>get_cache()</code>  <code>classmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get_cache(cls) -&gt; NodeCache:\n    global node_cache\n    if node_cache is None:\n        settings = Config.get()\n        node_cache = NodeCache(settings.node_cache_size)\n\n    return node_cache\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.get_many","title":"<code>get_many(node_ids, *, batch_size=128, db=None, load_edges=False, return_nodes=False, progress_callback=None)</code>  <code>classmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef get_many(\n    cls,\n    node_ids: set[NodeId],\n    *,\n    batch_size: int = 128,\n    db: GraphDB | None = None,\n    load_edges: bool = False,\n    return_nodes: bool = False,\n    progress_callback: ProgressFn | None = None,\n) -&gt; list[Node]:\n    db = db or GraphDB.singleton()\n\n    c = Node.get_cache()\n    if len(node_ids) &gt; c.maxsize:\n        raise GraphDBInternalError(\n            f\"get_many attempting to load more nodes than cache size ({len(node_ids)} &gt; {c.maxsize})\"\n        )\n\n    cache_ids = set(c.keys())\n    fetch_ids = node_ids - cache_ids\n\n    start = 0\n    curr = batch_size\n    ret_list = [c[nid] for nid in c]\n    if progress_callback:\n        progress_callback(ret_list)\n    while start &lt; len(fetch_ids):\n        id_set = set(islice(fetch_ids, start, curr))\n\n        res = cls.load_many(id_set, db=db, load_edges=load_edges)\n        for n in res:\n            c[n.id] = n\n\n        if progress_callback:\n            progress_callback(res)\n\n        ret_list.extend(res)\n        # import pprint\n        # pprint.pp(list(res))\n        # print(f\"got {len(list(res))} nodes\")\n\n        start = curr\n        curr += batch_size\n\n    assert len(ret_list) == len(node_ids)\n    return ret_list\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.load","title":"<code>load(id, *, db=None)</code>  <code>classmethod</code>","text":"<p>Loads a node from the database. Use <code>Node.get</code> or other methods instead.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>NodeId</code> <p>The identifier of the node to fetch</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Raises:</p> Type Description <code>NodeNotFound</code> <p>The node specified by the identifier does not exist in the database</p> <code>GraphDBInternalError</code> <p>If the requested ID returns multiple nodes</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The node from the database</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef load(cls, id: NodeId, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Loads a node from the database. Use `Node.get` or other methods instead.\n\n    Args:\n        id (NodeId): The identifier of the node to fetch\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Raises:\n        NodeNotFound: The node specified by the identifier does not exist in the database\n        GraphDBInternalError: If the requested ID returns multiple nodes\n\n    Returns:\n        Self: The node from the database\n    \"\"\"\n    res = cls.load_many(\n        {\n            id,\n        },\n        db=db,\n    )\n\n    # print(\"RES\", res)\n\n    if len(res) &lt; 1:\n        raise NodeNotFound(f\"Couldn't find node ID: {id}\")\n\n    if len(res) &gt; 1:\n        raise GraphDBInternalError(\n            f\"Too many nodes returned while trying to load single node: {id}\"\n        )\n\n    return res[0]\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.load_many","title":"<code>load_many(node_set, db=NotImplemented, load_edges=False)</code>  <code>classmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef load_many(\n    cls, node_set: set[NodeId], db: GraphDB | None = NotImplemented, load_edges: bool = False\n) -&gt; list[Self]:\n    db = db or GraphDB.singleton()\n    node_ids = \",\".join(map(str, node_set))\n\n    if load_edges:\n        edge_fmt = \"e\"\n    else:\n        edge_fmt = \"{id: id(e), start: id(startNode(e)), end: id(endNode(e))}\"\n    res_iter = db.raw_fetch(\n        f\"\"\"\n            MATCH (n)-[e]-(m) WHERE id(n) IN [{node_ids}]\n            RETURN n, collect({edge_fmt}) AS edges\n            \"\"\",\n    )\n\n    # edges = list(\n    #     map(lambda r: {\"id\": r[\"e_id\"], \"start\": r[\"e_start\"], \"end\": r[\"e_end\"]}, res)\n    # )\n    # src_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"start\"] == id, edges)))\n    # dst_edges = list(map(lambda e: e[\"id\"], filter(lambda e: e[\"end\"] == id, edges)))\n\n    ret_list = list()\n    for r in res_iter:\n        n = r[\"n\"]\n        if n is None:\n            raise NodeNotFound(f\"Couldn't find node ID: {id}\")\n\n        if load_edges:\n            # XXX: memgraph converts edges to Relationship objects if you\n            # return the whole edge\n            src_edges = list()\n            dst_edges = list()\n            edge_cache = Edge.get_cache()\n            for e in r[\"edges\"]:\n                # add edge_id to to the right list for the node creation below\n                if n.id == e.start_id:\n                    src_edges.append(e.id)\n                else:\n                    dst_edges.append(e.id)\n\n                # edge already loaded, continue to next one\n                if e.id in edge_cache:\n                    continue\n\n                # create a new edge\n                props = None\n                if hasattr(e, \"properties\"):\n                    props = e.properties\n                new_edge = Edge(\n                    e.start_id,\n                    e.end_id,\n                    id=e.id,\n                    data=props,\n                    type=e.type,\n                )\n                edge_cache[e.id] = new_edge\n        else:\n            src_edges = [e[\"id\"] for e in r[\"edges\"] if e[\"start\"] == n.id]\n            dst_edges = [e[\"id\"] for e in r[\"edges\"] if e[\"end\"] == n.id]\n        new_node = cls(\n            _id=n.id,\n            _src_edges=EdgeList(src_edges),\n            _dst_edges=EdgeList(dst_edges),\n            labels=n.labels,\n            **n.properties,\n        )\n        ret_list.append(new_node)\n\n    return ret_list\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.mklabels","title":"<code>mklabels(labels)</code>  <code>staticmethod</code>","text":"<p>Converts a list of strings into proper Cypher syntax for a graph database query</p> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef mklabels(labels: set[str]) -&gt; str:\n    \"\"\"Converts a list of strings into proper Cypher syntax for a graph database query\"\"\"\n    labels_list = [i for i in labels]\n    labels_list.sort()\n    label_str = \":\".join(labels_list)\n    if len(label_str) &gt; 0:\n        label_str = \":\" + label_str\n    return label_str\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.save","title":"<code>save(n, *, db=None)</code>  <code>classmethod</code>","text":"<p>Save a node to persistent storage</p> <p>Writes the specified node to the GraphDB for persistent storage. If the node does not already exist in storage, it is created via the <code>create</code> method. If the node does exist, it is updated via the <code>update</code> method.</p> <p>If the _no_save flag is True on the node, the save request will be silently ignored.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Self</code> <p>The Node to be saved</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>As a convenience, the node that was stored is returned. This may be useful</p> <code>Self</code> <p>since the the id of the node may change if it was created in the database.</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef save(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Save a node to persistent storage\n\n    Writes the specified node to the GraphDB for persistent storage. If the node does not\n    already exist in storage, it is created via the `create` method. If the node does exist, it\n    is updated via the `update` method.\n\n    If the _no_save flag is True on the node, the save request will be silently ignored.\n\n    Args:\n        n (Self): The Node to be saved\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: As a convenience, the node that was stored is returned. This may be useful\n        since the the id of the node may change if it was created in the database.\n    \"\"\"\n    if n._new:\n        return cls.create(n, db=db)\n    else:\n        return cls.update(n, db=db)\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.to_dict","title":"<code>to_dict(n, include_labels=False)</code>  <code>staticmethod</code>","text":"<p>Convert a Node to a Python dictionary</p> Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef to_dict(n: Node, include_labels: bool = False) -&gt; dict[str, Any]:\n    \"\"\"Convert a Node to a Python dictionary\"\"\"\n    # XXX: the excluded fields below shouldn't have been included in the\n    # first place because Pythonic should exclude fields with underscores\n    ret = n.model_dump(exclude={\"_id\", \"_src_edges\", \"_dst_edges\"})\n\n    if include_labels and hasattr(n, \"labels\"):\n        ret[\"labels\"] = n.labels\n\n    return ret\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.update","title":"<code>update(n, *, db=None)</code>  <code>classmethod</code>","text":"<p>Update an existing node in the GraphDB.</p> <p>Calling <code>save</code> is preferred to using this method so that the caller doesn't need to know the state of the node.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Self</code> <p>The node to be updated</p> required <code>db</code> <code>GraphDB | None</code> <p>the graph database to use, or None to use the GraphDB singleton</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The node that was passed in, for convenience</p> Source code in <code>roc/graphdb.py</code> <pre><code>@classmethod\ndef update(cls, n: Self, *, db: GraphDB | None = None) -&gt; Self:\n    \"\"\"Update an existing node in the GraphDB.\n\n    Calling `save` is preferred to using this method so that the caller doesn't need to know the\n    state of the node.\n\n    Args:\n        n (Self): The node to be updated\n        db (GraphDB | None): the graph database to use, or None to use the GraphDB singleton\n\n    Returns:\n        Self: The node that was passed in, for convenience\n    \"\"\"\n    if n._no_save:\n        return n\n\n    db = db or GraphDB.singleton()\n\n    orig_labels = n._orig_labels\n    curr_labels = set(n.labels)\n    new_labels = curr_labels - orig_labels\n    rm_labels = orig_labels - curr_labels\n    set_label_str = Node.mklabels(new_labels)\n    if set_label_str:\n        set_query = f\"SET n{set_label_str}, n = $props\"\n    else:\n        set_query = \"SET n = $props\"\n    rm_label_str = Node.mklabels(rm_labels)\n    if rm_label_str:\n        rm_query = f\"REMOVE n{rm_label_str}\"\n    else:\n        rm_query = \"\"\n\n    params = {\"props\": Node.to_dict(n)}\n\n    db.raw_execute(f\"MATCH (n) WHERE id(n) = {n.id} {set_query} {rm_query}\", params=params)\n\n    return n\n</code></pre>"},{"location":"reference/graphdb/#graphdb.Node.walk","title":"<code>walk(n, *, mode='both', edge_filter=None, node_filter=None, node_callback=None, _walk_history=None)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>@staticmethod\ndef walk(\n    n: Node,\n    *,\n    mode: WalkMode = \"both\",\n    edge_filter: EdgeFilterFn | None = None,\n    # edge_callback: EdgeCallbackFn | None = None,\n    node_filter: NodeFilterFn | None = None,\n    node_callback: NodeCallbackFn | None = None,\n    _walk_history: set[int] | None = None,\n) -&gt; None:\n    # if we have walked this node before, just return\n    _walk_history = _walk_history or set()\n    if n.id in _walk_history:\n        return\n    _walk_history.add(n.id)\n\n    edge_filter = edge_filter or true_filter\n    node_filter = node_filter or true_filter\n    # edge_callback = edge_callback or no_callback\n    node_callback = node_callback or no_callback\n\n    # callback for this node, if not filtered\n    if node_filter(n):\n        node_callback(n)\n    else:\n        return\n\n    if mode == \"src\" or mode == \"both\":\n        for e in n.src_edges:\n            if edge_filter(e):\n                Node.walk(\n                    e.dst,\n                    mode=mode,\n                    edge_filter=edge_filter,\n                    # edge_callback=edge_callback,\n                    node_filter=node_filter,\n                    node_callback=node_callback,\n                    _walk_history=_walk_history,\n                )\n\n    if mode == \"dst\" or mode == \"both\":\n        for e in n.dst_edges:\n            if edge_filter(e):\n                Node.walk(\n                    e.src,\n                    mode=mode,\n                    edge_filter=edge_filter,\n                    # edge_callback=edge_callback,\n                    node_filter=node_filter,\n                    node_callback=node_callback,\n                    _walk_history=_walk_history,\n                )\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeCreationFailed","title":"<code>NodeCreationFailed</code>","text":"<p>               Bases: <code>Exception</code></p> <p>An exception raised when trying to create a Node in the graph database fails</p> Source code in <code>roc/graphdb.py</code> <pre><code>class NodeCreationFailed(Exception):\n    \"\"\"An exception raised when trying to create a Node in the graph database fails\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/graphdb/#graphdb.NodeNotFound","title":"<code>NodeNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>An exception raised when trying to retreive a Node that doesn't exist.</p> Source code in <code>roc/graphdb.py</code> <pre><code>class NodeNotFound(Exception):\n    \"\"\"An exception raised when trying to retreive a Node that doesn't exist.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/graphdb/#graphdb.get_next_new_edge_id","title":"<code>get_next_new_edge_id()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def get_next_new_edge_id() -&gt; EdgeId:\n    global next_new_edge\n    id = next_new_edge\n    next_new_edge = cast(EdgeId, next_new_edge - 1)\n\n    return id\n</code></pre>"},{"location":"reference/graphdb/#graphdb.get_next_new_node_id","title":"<code>get_next_new_node_id()</code>","text":"Source code in <code>roc/graphdb.py</code> <pre><code>def get_next_new_node_id() -&gt; NodeId:\n    global next_new_node\n    id = next_new_node\n    next_new_node = cast(NodeId, next_new_node - 1)\n    return id\n</code></pre>"},{"location":"reference/graphdb/#graphdb.no_callback","title":"<code>no_callback(_)</code>","text":"<p>Helper function that accepts any value and returns None. Great for default callback functions.</p> Source code in <code>roc/graphdb.py</code> <pre><code>def no_callback(_: Any) -&gt; None:\n    \"\"\"Helper function that accepts any value and returns None. Great for\n    default callback functions.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/graphdb/#graphdb.true_filter","title":"<code>true_filter(_)</code>","text":"<p>Helper function that accepts any value and returns True. Great for default filters.</p> Source code in <code>roc/graphdb.py</code> <pre><code>def true_filter(_: Any) -&gt; bool:\n    \"\"\"Helper function that accepts any value and returns True. Great for\n    default filters.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"reference/gymnasium/","title":"gymnasium","text":"<p>This module is a wrapper around the Gym / Gymnasium interfaces and drives all the interactions between the agent and the system, including the main event loop.</p>"},{"location":"reference/gymnasium/#gymnasium.count","title":"<code>count = 0</code>  <code>module-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.dump_env_file","title":"<code>dump_env_file: Any = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats","title":"<code>BottomlineStats</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A Pydantic model representing the Nethack bottom line statistics.</p> Source code in <code>roc/gymnasium.py</code> <pre><code>class BottomlineStats(BaseModel):\n    \"\"\"A Pydantic model representing the Nethack bottom line statistics.\"\"\"\n\n    X: int\n    Y: int\n    STR25: int\n    STR125: int\n    DEX: int\n    CON: int\n    INT: int\n    WIS: int\n    CHA: int\n    SCORE: int\n    HP: int\n    HPMAX: int\n    DEPTH: int\n    GOLD: int\n    ENE: int\n    ENEMAX: int\n    AC: int\n    HD: int\n    XP: int\n    EXP: int\n    TIME: int\n    HUNGER: int\n    CAP: int\n    DNUM: int\n    DLEVEL: int\n    CONDITION: int\n    ALIGN: int\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.AC","title":"<code>AC: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.ALIGN","title":"<code>ALIGN: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.CAP","title":"<code>CAP: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.CHA","title":"<code>CHA: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.CON","title":"<code>CON: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.CONDITION","title":"<code>CONDITION: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.DEPTH","title":"<code>DEPTH: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.DEX","title":"<code>DEX: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.DLEVEL","title":"<code>DLEVEL: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.DNUM","title":"<code>DNUM: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.ENE","title":"<code>ENE: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.ENEMAX","title":"<code>ENEMAX: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.EXP","title":"<code>EXP: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.GOLD","title":"<code>GOLD: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.HD","title":"<code>HD: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.HP","title":"<code>HP: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.HPMAX","title":"<code>HPMAX: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.HUNGER","title":"<code>HUNGER: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.INT","title":"<code>INT: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.SCORE","title":"<code>SCORE: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.STR125","title":"<code>STR125: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.STR25","title":"<code>STR25: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.TIME","title":"<code>TIME: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.WIS","title":"<code>WIS: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.X","title":"<code>X: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.XP","title":"<code>XP: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.BottomlineStats.Y","title":"<code>Y: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym","title":"<code>Gym</code>","text":"<p>               Bases: <code>Component</code>, <code>ABC</code></p> <p>A wrapper around an OpenAI Gym / Farama Gymnasium that drives the event loop and interfaces to the ROC agent.</p> Source code in <code>roc/gymnasium.py</code> <pre><code>class Gym(Component, ABC):\n    \"\"\"A wrapper around an OpenAI Gym / Farama Gymnasium that drives the event\n    loop and interfaces to the ROC agent.\n    \"\"\"\n\n    def __init__(self, gym_id: str, *, gym_opts: dict[str, Any] | None = None) -&gt; None:\n        super().__init__()\n        gym_opts = gym_opts or {}\n        self.env = gym.make(gym_id, **gym_opts)\n\n        # setup communications\n        self.env_bus = Perception.bus\n        self.action_bus = action_bus\n        self.env_bus_conn = self.env_bus.connect(self)\n        self.action_bus_conn = self.action_bus.connect(self)\n\n        # config actions\n        self.action_count = self.env.action_space.n\n        self.config_actions(self.action_count)\n\n        # TODO: config environment\n        # setup which features detectors to use on each bus\n\n    @abstractmethod\n    def send_obs(self, obs: Any) -&gt; None:\n        pass\n\n    @abstractmethod\n    def config_actions(self, action_count: int) -&gt; None:\n        pass\n\n    @logger.catch\n    def start(self) -&gt; None:\n        obs = self.env.reset()\n\n        done = False\n        _dump_env_start()\n\n        logger.info(\"Starting NLE loop...\")\n\n        # main environment loop\n        while not done:\n            # logger.trace(f\"Sending observation: {obs}\")\n            breakpoints.check()\n            self.send_obs(obs)\n            action = self.await_action()\n            logger.trace(f\"Doing action: {action}\")\n            step_res = self.env.step(action)\n            obs = step_res[0]\n            _dump_env_record(obs)\n\n            if len(step_res) == 5:\n                done = step_res[2] or step_res[3]\n            else:\n                done = step_res[2]\n\n            # self.env.render()\n            logger.trace(f\"Main loop done: {done}\")\n            states.loop.incr()\n\n        logger.info(\"NLE loop done.\")\n        _dump_env_end()\n\n    def decode_action(self, action: int) -&gt; Any:\n        return action\n\n    def await_action(self) -&gt; Any:\n        # TODO: self.action_bus_conn.subject.first()\n\n        # warnings.warn(\"await action not implemented, defaulting to '.' for every action\")\n\n        default_action = 19  # 19 = 46 = \".\" = do nothing\n        action = self.decode_action(default_action)\n        return action\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.action_bus","title":"<code>action_bus = action_bus</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.action_bus_conn","title":"<code>action_bus_conn = self.action_bus.connect(self)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.action_count","title":"<code>action_count = self.env.action_space.n</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.env","title":"<code>env = gym.make(gym_id, **gym_opts)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.env_bus","title":"<code>env_bus = Perception.bus</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.env_bus_conn","title":"<code>env_bus_conn = self.env_bus.connect(self)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.Gym.__init__","title":"<code>__init__(gym_id, *, gym_opts=None)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def __init__(self, gym_id: str, *, gym_opts: dict[str, Any] | None = None) -&gt; None:\n    super().__init__()\n    gym_opts = gym_opts or {}\n    self.env = gym.make(gym_id, **gym_opts)\n\n    # setup communications\n    self.env_bus = Perception.bus\n    self.action_bus = action_bus\n    self.env_bus_conn = self.env_bus.connect(self)\n    self.action_bus_conn = self.action_bus.connect(self)\n\n    # config actions\n    self.action_count = self.env.action_space.n\n    self.config_actions(self.action_count)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.await_action","title":"<code>await_action()</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def await_action(self) -&gt; Any:\n    # TODO: self.action_bus_conn.subject.first()\n\n    # warnings.warn(\"await action not implemented, defaulting to '.' for every action\")\n\n    default_action = 19  # 19 = 46 = \".\" = do nothing\n    action = self.decode_action(default_action)\n    return action\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.config_actions","title":"<code>config_actions(action_count)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>@abstractmethod\ndef config_actions(self, action_count: int) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.decode_action","title":"<code>decode_action(action)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def decode_action(self, action: int) -&gt; Any:\n    return action\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.send_obs","title":"<code>send_obs(obs)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>@abstractmethod\ndef send_obs(self, obs: Any) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.Gym.start","title":"<code>start()</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>@logger.catch\ndef start(self) -&gt; None:\n    obs = self.env.reset()\n\n    done = False\n    _dump_env_start()\n\n    logger.info(\"Starting NLE loop...\")\n\n    # main environment loop\n    while not done:\n        # logger.trace(f\"Sending observation: {obs}\")\n        breakpoints.check()\n        self.send_obs(obs)\n        action = self.await_action()\n        logger.trace(f\"Doing action: {action}\")\n        step_res = self.env.step(action)\n        obs = step_res[0]\n        _dump_env_record(obs)\n\n        if len(step_res) == 5:\n            done = step_res[2] or step_res[3]\n        else:\n            done = step_res[2]\n\n        # self.env.render()\n        logger.trace(f\"Main loop done: {done}\")\n        states.loop.incr()\n\n    logger.info(\"NLE loop done.\")\n    _dump_env_end()\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym","title":"<code>NethackGym</code>","text":"<p>               Bases: <code>Gym</code></p> <p>Wrapper around the Gym class for driving the Nethack interface to the ROC agent. Decodes Nethack specific data and sends it to the agent as Events.</p> Source code in <code>roc/gymnasium.py</code> <pre><code>class NethackGym(Gym):\n    \"\"\"Wrapper around the Gym class for driving the Nethack interface to the ROC\n    agent. Decodes Nethack specific data and sends it to the agent as Events.\n    \"\"\"\n\n    def __init__(self, *, gym_opts: dict[str, Any] | None = None) -&gt; None:\n        gym_opts = gym_opts or {}\n        super().__init__(\"NetHackScore-v0\", **gym_opts)\n\n    def config_actions(self, action_count: int) -&gt; None:\n        a = ActionCount(action_count=action_count)\n        self.action_bus_conn.send(a)\n\n    def send_obs(self, obs: Any) -&gt; None:\n        self.send_vision(obs)\n        self.send_intrinsics(obs)\n\n    def send_vision(self, obs: Any) -&gt; None:\n        self.env_bus_conn.send(VisionData.from_dict(obs))\n\n    def send_auditory(self) -&gt; None:\n        pass\n\n    def send_proprioceptive(self) -&gt; None:\n        pass\n\n    def send_intrinsics(self, obs: Any) -&gt; None:\n        pass\n        # NOTE: obs[\"blstats\"] is an ndarray object from numpy\n        bl = obs[\"blstats\"].tolist()\n        blstat_args = {e.name: bl[e.value] for e in blstat_offsets}\n        # print(\"blstat_args\", blstat_args)\n\n        blstats = BottomlineStats(**blstat_args)\n        # print(\"blstats\", blstats.model_dump())\n        blstat_conds = {bit.name for bit in condition_bits if blstats.CONDITION &amp; bit.value}\n        # TODO: remove... just curious if conditions ever get set\n        if len(blstat_conds):\n            logger.warning(\"!!! FOUND CONDITIONS\", blstat_conds)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.__init__","title":"<code>__init__(*, gym_opts=None)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def __init__(self, *, gym_opts: dict[str, Any] | None = None) -&gt; None:\n    gym_opts = gym_opts or {}\n    super().__init__(\"NetHackScore-v0\", **gym_opts)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.config_actions","title":"<code>config_actions(action_count)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def config_actions(self, action_count: int) -&gt; None:\n    a = ActionCount(action_count=action_count)\n    self.action_bus_conn.send(a)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.send_auditory","title":"<code>send_auditory()</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def send_auditory(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.send_intrinsics","title":"<code>send_intrinsics(obs)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def send_intrinsics(self, obs: Any) -&gt; None:\n    pass\n    # NOTE: obs[\"blstats\"] is an ndarray object from numpy\n    bl = obs[\"blstats\"].tolist()\n    blstat_args = {e.name: bl[e.value] for e in blstat_offsets}\n    # print(\"blstat_args\", blstat_args)\n\n    blstats = BottomlineStats(**blstat_args)\n    # print(\"blstats\", blstats.model_dump())\n    blstat_conds = {bit.name for bit in condition_bits if blstats.CONDITION &amp; bit.value}\n    # TODO: remove... just curious if conditions ever get set\n    if len(blstat_conds):\n        logger.warning(\"!!! FOUND CONDITIONS\", blstat_conds)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.send_obs","title":"<code>send_obs(obs)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def send_obs(self, obs: Any) -&gt; None:\n    self.send_vision(obs)\n    self.send_intrinsics(obs)\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.send_proprioceptive","title":"<code>send_proprioceptive()</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def send_proprioceptive(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.NethackGym.send_vision","title":"<code>send_vision(obs)</code>","text":"Source code in <code>roc/gymnasium.py</code> <pre><code>def send_vision(self, obs: Any) -&gt; None:\n    self.env_bus_conn.send(VisionData.from_dict(obs))\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.blstat_offsets","title":"<code>blstat_offsets</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>An enumeration of Nethack bottom line statistics (intelligence, strength, charisma, position, hit points, etc.)</p> Source code in <code>roc/gymnasium.py</code> <pre><code>class blstat_offsets(IntEnum):\n    \"\"\"An enumeration of Nethack bottom line statistics (intelligence, strength,\n    charisma, position, hit points, etc.)\n    \"\"\"\n\n    # fmt: off\n    X =         0\n    Y =         1\n    STR25 =     2\n    STR125 =    3\n    DEX =       4\n    CON =       5\n    INT =       6\n    WIS =       7\n    CHA =       8\n    SCORE =     9\n    HP =        10\n    HPMAX =     11\n    DEPTH =     12\n    GOLD =      13\n    ENE =       14\n    ENEMAX =    15\n    AC =        16\n    HD =        17\n    XP =        18\n    EXP =       19\n    TIME =      20\n    HUNGER =    21\n    CAP =       22\n    DNUM =      23\n    DLEVEL =    24\n    CONDITION = 25\n    ALIGN =     26\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.AC","title":"<code>AC = 16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.ALIGN","title":"<code>ALIGN = 26</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.CAP","title":"<code>CAP = 22</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.CHA","title":"<code>CHA = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.CON","title":"<code>CON = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.CONDITION","title":"<code>CONDITION = 25</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.DEPTH","title":"<code>DEPTH = 12</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.DEX","title":"<code>DEX = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.DLEVEL","title":"<code>DLEVEL = 24</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.DNUM","title":"<code>DNUM = 23</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.ENE","title":"<code>ENE = 14</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.ENEMAX","title":"<code>ENEMAX = 15</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.EXP","title":"<code>EXP = 19</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.GOLD","title":"<code>GOLD = 13</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.HD","title":"<code>HD = 17</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.HP","title":"<code>HP = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.HPMAX","title":"<code>HPMAX = 11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.HUNGER","title":"<code>HUNGER = 21</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.INT","title":"<code>INT = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.SCORE","title":"<code>SCORE = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.STR125","title":"<code>STR125 = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.STR25","title":"<code>STR25 = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.TIME","title":"<code>TIME = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.WIS","title":"<code>WIS = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.X","title":"<code>X = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.XP","title":"<code>XP = 18</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.blstat_offsets.Y","title":"<code>Y = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits","title":"<code>condition_bits</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Bits for decoding the <code>CONDITION</code> bottomline stat to determin if the player is flying, deaf, food poisoned, etc.</p> Source code in <code>roc/gymnasium.py</code> <pre><code>class condition_bits(IntEnum):\n    \"\"\"Bits for decoding the `CONDITION` bottomline stat to determin if the\n    player is flying, deaf, food poisoned, etc.\n    \"\"\"\n\n    # fmt: off\n    BAREH =     0x00000001\n    BLIND =     0x00000002\n    BUSY =      0x00000004\n    CONF =      0x00000008\n    DEAF =      0x00000010\n    ELF_IRON =  0x00000020\n    FLY =       0x00000040\n    FOODPOIS =  0x00000080\n    GLOWHANDS = 0x00000100\n    GRAB =      0x00000200\n    HALLU =     0x00000400\n    HELD =      0x00000800\n    ICY =       0x00001000\n    INLAVA =    0x00002000\n    LEV =       0x00004000\n    PARLYZ =    0x00008000\n    RIDE =      0x00010000\n    SLEEPING =  0x00020000\n    SLIME =     0x00040000\n    SLIPPERY =  0x00080000\n    STONE =     0x00100000\n    STRNGL =    0x00200000\n    STUN =      0x00400000\n    SUBMERGED = 0x00800000\n    TERMILL   = 0x01000000\n    TETHERED =  0x02000000\n    TRAPPED =   0x04000000\n    UNCONSC =   0x08000000\n    WOUNDEDL =  0x10000000\n    HOLDING =   0x20000000\n</code></pre>"},{"location":"reference/gymnasium/#gymnasium.condition_bits.BAREH","title":"<code>BAREH = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.BLIND","title":"<code>BLIND = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.BUSY","title":"<code>BUSY = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.CONF","title":"<code>CONF = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.DEAF","title":"<code>DEAF = 16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.ELF_IRON","title":"<code>ELF_IRON = 32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.FLY","title":"<code>FLY = 64</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.FOODPOIS","title":"<code>FOODPOIS = 128</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.GLOWHANDS","title":"<code>GLOWHANDS = 256</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.GRAB","title":"<code>GRAB = 512</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.HALLU","title":"<code>HALLU = 1024</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.HELD","title":"<code>HELD = 2048</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.HOLDING","title":"<code>HOLDING = 536870912</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.ICY","title":"<code>ICY = 4096</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.INLAVA","title":"<code>INLAVA = 8192</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.LEV","title":"<code>LEV = 16384</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.PARLYZ","title":"<code>PARLYZ = 32768</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.RIDE","title":"<code>RIDE = 65536</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.SLEEPING","title":"<code>SLEEPING = 131072</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.SLIME","title":"<code>SLIME = 262144</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.SLIPPERY","title":"<code>SLIPPERY = 524288</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.STONE","title":"<code>STONE = 1048576</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.STRNGL","title":"<code>STRNGL = 2097152</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.STUN","title":"<code>STUN = 4194304</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.SUBMERGED","title":"<code>SUBMERGED = 8388608</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.TERMILL","title":"<code>TERMILL = 16777216</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.TETHERED","title":"<code>TETHERED = 33554432</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.TRAPPED","title":"<code>TRAPPED = 67108864</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.UNCONSC","title":"<code>UNCONSC = 134217728</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/gymnasium/#gymnasium.condition_bits.WOUNDEDL","title":"<code>WOUNDEDL = 268435456</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/intrinsic/","title":"intrinsic","text":""},{"location":"reference/intrinsic/#intrinsic.IntrinsicEvent","title":"<code>IntrinsicEvent = Event[IntrinsicData]</code>  <code>module-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.IntrinsicFn","title":"<code>IntrinsicFn = Callable[[IntrinsicEvent], None]</code>  <code>module-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.intrinsic_registry","title":"<code>intrinsic_registry: dict[str, IntrinsicFn] = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.Intrinsic","title":"<code>Intrinsic</code>","text":"<p>               Bases: <code>Component</code></p> Source code in <code>roc/intrinsic.py</code> <pre><code>@register_component(\"intrinsic\", \"intrinsic\")\nclass Intrinsic(Component):\n    pass\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.IntrinsicData","title":"<code>IntrinsicData</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>roc/intrinsic.py</code> <pre><code>class IntrinsicData(BaseModel):\n    pass\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.register_intrinsic","title":"<code>register_intrinsic</code>","text":"<p>Decorator for registering intrinsics.</p> Source code in <code>roc/intrinsic.py</code> <pre><code>class register_intrinsic:\n    \"\"\"Decorator for registering intrinsics.\"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        self.name = name\n\n    def __call__(self, fn: IntrinsicFn) -&gt; IntrinsicFn:\n        if self.name in intrinsic_registry:\n            raise ValueError(f\"Registering duplicate intrinsic '{self.name}'\")\n\n        intrinsic_registry[self.name] = fn\n\n        return fn\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.register_intrinsic.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/intrinsic/#intrinsic.register_intrinsic.__call__","title":"<code>__call__(fn)</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>def __call__(self, fn: IntrinsicFn) -&gt; IntrinsicFn:\n    if self.name in intrinsic_registry:\n        raise ValueError(f\"Registering duplicate intrinsic '{self.name}'\")\n\n    intrinsic_registry[self.name] = fn\n\n    return fn\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.register_intrinsic.__init__","title":"<code>__init__(name)</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    self.name = name\n</code></pre>"},{"location":"reference/intrinsic/#intrinsic.noop_intrinsic","title":"<code>noop_intrinsic(e)</code>","text":"Source code in <code>roc/intrinsic.py</code> <pre><code>@register_intrinsic(\"no-op\")\ndef noop_intrinsic(e: IntrinsicEvent) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/location/","title":"location","text":""},{"location":"reference/location/#location.GridType","title":"<code>GridType = TypeVar('GridType')</code>  <code>module-attribute</code>","text":""},{"location":"reference/location/#location.LocationTuple","title":"<code>LocationTuple = tuple[int, int]</code>  <code>module-attribute</code>","text":""},{"location":"reference/location/#location.PointList","title":"<code>PointList = list[Point]</code>  <code>module-attribute</code>","text":""},{"location":"reference/location/#location.ValLocTuple","title":"<code>ValLocTuple = tuple[GridType, int, int]</code>  <code>module-attribute</code>","text":""},{"location":"reference/location/#location.ChangedPoint","title":"<code>ChangedPoint</code>","text":"<p>               Bases: <code>Point</code></p> <p>Represents a value changing from <code>old_val</code> to <code>val</code> at a given (x, y) location.</p> Source code in <code>roc/location.py</code> <pre><code>class ChangedPoint(Point):\n    \"\"\"Represents a value changing from `old_val` to `val` at a given (x, y) location.\"\"\"\n\n    def __init_(self, x: int, y: int, val: int, old_val: int) -&gt; None:\n        super().__init__(x, y, val)\n        self.old_val = old_val\n\n    def __repr__(self) -&gt; str:\n        return f\"({self.x}, {self.y}): {self.old_val} '{chr(self.old_val)}' -&gt; {self.val} '{chr(self.val)}'\"  # noqa: E501\n</code></pre>"},{"location":"reference/location/#location.ChangedPoint.__init_","title":"<code>__init_(x, y, val, old_val)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __init_(self, x: int, y: int, val: int, old_val: int) -&gt; None:\n    super().__init__(x, y, val)\n    self.old_val = old_val\n</code></pre>"},{"location":"reference/location/#location.ChangedPoint.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"({self.x}, {self.y}): {self.old_val} '{chr(self.old_val)}' -&gt; {self.val} '{chr(self.val)}'\"  # noqa: E501\n</code></pre>"},{"location":"reference/location/#location.DebugGrid","title":"<code>DebugGrid</code>","text":"<p>               Bases: <code>NewGrid[GridStyle]</code></p> Source code in <code>roc/location.py</code> <pre><code>class DebugGrid(NewGrid[GridStyle]):\n    def __new__(cls, grid: IntGrid) -&gt; DebugGrid:\n        # obj = np.ndarray((grid.height, grid.width), dtype=object).view(DebugGrid)\n        obj = np.array(\n            [\n                [\n                    GridStyle(\n                        front_hue=0,\n                        front_saturation=0,\n                        front_brightness=1,\n                        back_hue=0,\n                        back_saturation=1,\n                        back_brightness=0,\n                        val=chr(grid[row, col]),\n                        style=\"none\",\n                    )\n                    for col in range(grid.width)\n                ]\n                for row in range(grid.height)\n            ]\n        ).view(DebugGrid)\n        return obj\n\n    def __array_finalize__(self, obj: npt.NDArray[Any] | None) -&gt; None:\n        if obj is None:\n            return\n\n    # def __init__(self, grid: NewGrid[Any]) -&gt; None:\n    #     width = grid.width\n    #     height = grid.height\n    #     map: list[list[GridStyle]] = [\n    #         [\n    #             GridStyle(\n    #                 front_hue=0,\n    #                 front_saturation=0,\n    #                 front_brightness=1,\n    #                 back_hue=0,\n    #                 back_saturation=1,\n    #                 back_brightness=0,\n    #                 val=\" \",\n    #                 style=\"none\",\n    #             )\n    #             for col in range(width)\n    #         ]\n    #         for row in range(height)\n    #     ]\n    #     super().__init__(map)\n\n    #     # copy over all the values from the grid\n    #     for p in grid.points():\n    #         s = self.get_val(p.x, p.y)\n    #         s.val = chr(p.val)\n\n    def set_style(self, x: int, y: int, *, style: str | None = None, **kwargs: float) -&gt; None:\n        s = self.get_val(x, y)\n\n        if style:\n            s.style = style\n\n        for key, value in kwargs.items():\n            if value &lt; 0 or value &gt; 1:\n                raise Exception(\n                    f\"set_style expects values to be floats between 0 and 1, '{key}' was '{value}'\"\n                )\n\n            match key:\n                case \"front_hue\":\n                    s.front_hue = value\n                case \"front_brightness\":\n                    s.front_brightness = value\n                case \"front_saturation\":\n                    s.front_saturation = value\n                case \"back_hue\":\n                    s.back_hue = value\n                case \"back_brightness\":\n                    s.back_brightness = value\n                case \"back_saturation\":\n                    s.back_saturation = value\n                case _:\n                    raise Exception(f\"unknown key '{key}' in set_style\")\n\n    def get_front_rgb(self, x: int, y: int) -&gt; tuple[int, int, int]:\n        s = self.get_val(x, y)\n        rgb = hsv_to_rgb(s.front_hue, s.front_saturation, s.front_brightness)\n        ret = tuple(map(lambda c: round(c * 255), rgb))\n        assert len(ret) == 3\n        return ret\n\n    def get_back_rgb(self, x: int, y: int) -&gt; tuple[int, int, int]:\n        s = self.get_val(x, y)\n        rgb = hsv_to_rgb(s.back_hue, s.back_saturation, s.back_brightness)\n        ret = tuple(map(lambda c: round(c * 255), rgb))\n        assert len(ret) == 3\n        return ret\n\n    def __str__(self) -&gt; str:\n        ret = \"\"\n        for y in range(self.height):\n            for x in range(self.width):\n                s = self.get_val(x, y)\n                fr, fg, fb = self.get_front_rgb(x, y)\n                br, bg, bb = self.get_back_rgb(x, y)\n                ret += f\"{Fore.rgb(fr,fg,fb)}{Back.rgb(br,bg,bb)}{s.val}{Style.reset}\"\n            ret += \"\\n\"\n        return ret\n\n    @classmethod\n    def blue_to_red_hue(cls, val: float) -&gt; float:\n        \"\"\"Converts a floating point value to a point in a red-to-blue gradient,\n        where high values are red and lower values are blue. Good for\n        representing values in a range as a heat map for easy visualization of\n        higher values.\n\n        Args:\n            val (float): The value to convert.\n\n        Returns:\n            float: The hue in the red-to-blue gradient.\n        \"\"\"\n        # blue = 2/3\n        # blue to red spectrum = 2/3 through 3/3\n        # return value is a portion of the blue-to-red spectrum\n        return (2 / 3) + ((1 / 3) * val)\n\n    @classmethod\n    def five_color_hue(cls, val: float) -&gt; float:\n        \"\"\"Converts a value to a hue along a red-orange-yellow-green-blue\n        spectrum. Higher values are red, lower values are blue. Good for\n        visually differentiating a range of values.\n\n        Args:\n            val (float): The value to convert.\n\n        Returns:\n            float: The hue in the red-orange-yellow-green-blue gradient.\n        \"\"\"\n        # red = 0\n        # blue = 2/3\n        # red to blue spectrum = 0 through 2/3\n        # five colors = red, orange, yellow, green, blue\n        # return value is a portion of the red-to-blue spectrum\n        return (2 / 3) * (1 - val)\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.__array_finalize__","title":"<code>__array_finalize__(obj)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __array_finalize__(self, obj: npt.NDArray[Any] | None) -&gt; None:\n    if obj is None:\n        return\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.__new__","title":"<code>__new__(grid)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __new__(cls, grid: IntGrid) -&gt; DebugGrid:\n    # obj = np.ndarray((grid.height, grid.width), dtype=object).view(DebugGrid)\n    obj = np.array(\n        [\n            [\n                GridStyle(\n                    front_hue=0,\n                    front_saturation=0,\n                    front_brightness=1,\n                    back_hue=0,\n                    back_saturation=1,\n                    back_brightness=0,\n                    val=chr(grid[row, col]),\n                    style=\"none\",\n                )\n                for col in range(grid.width)\n            ]\n            for row in range(grid.height)\n        ]\n    ).view(DebugGrid)\n    return obj\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __str__(self) -&gt; str:\n    ret = \"\"\n    for y in range(self.height):\n        for x in range(self.width):\n            s = self.get_val(x, y)\n            fr, fg, fb = self.get_front_rgb(x, y)\n            br, bg, bb = self.get_back_rgb(x, y)\n            ret += f\"{Fore.rgb(fr,fg,fb)}{Back.rgb(br,bg,bb)}{s.val}{Style.reset}\"\n        ret += \"\\n\"\n    return ret\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.blue_to_red_hue","title":"<code>blue_to_red_hue(val)</code>  <code>classmethod</code>","text":"<p>Converts a floating point value to a point in a red-to-blue gradient, where high values are red and lower values are blue. Good for representing values in a range as a heat map for easy visualization of higher values.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>float</code> <p>The value to convert.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The hue in the red-to-blue gradient.</p> Source code in <code>roc/location.py</code> <pre><code>@classmethod\ndef blue_to_red_hue(cls, val: float) -&gt; float:\n    \"\"\"Converts a floating point value to a point in a red-to-blue gradient,\n    where high values are red and lower values are blue. Good for\n    representing values in a range as a heat map for easy visualization of\n    higher values.\n\n    Args:\n        val (float): The value to convert.\n\n    Returns:\n        float: The hue in the red-to-blue gradient.\n    \"\"\"\n    # blue = 2/3\n    # blue to red spectrum = 2/3 through 3/3\n    # return value is a portion of the blue-to-red spectrum\n    return (2 / 3) + ((1 / 3) * val)\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.five_color_hue","title":"<code>five_color_hue(val)</code>  <code>classmethod</code>","text":"<p>Converts a value to a hue along a red-orange-yellow-green-blue spectrum. Higher values are red, lower values are blue. Good for visually differentiating a range of values.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>float</code> <p>The value to convert.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The hue in the red-orange-yellow-green-blue gradient.</p> Source code in <code>roc/location.py</code> <pre><code>@classmethod\ndef five_color_hue(cls, val: float) -&gt; float:\n    \"\"\"Converts a value to a hue along a red-orange-yellow-green-blue\n    spectrum. Higher values are red, lower values are blue. Good for\n    visually differentiating a range of values.\n\n    Args:\n        val (float): The value to convert.\n\n    Returns:\n        float: The hue in the red-orange-yellow-green-blue gradient.\n    \"\"\"\n    # red = 0\n    # blue = 2/3\n    # red to blue spectrum = 0 through 2/3\n    # five colors = red, orange, yellow, green, blue\n    # return value is a portion of the red-to-blue spectrum\n    return (2 / 3) * (1 - val)\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.get_back_rgb","title":"<code>get_back_rgb(x, y)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def get_back_rgb(self, x: int, y: int) -&gt; tuple[int, int, int]:\n    s = self.get_val(x, y)\n    rgb = hsv_to_rgb(s.back_hue, s.back_saturation, s.back_brightness)\n    ret = tuple(map(lambda c: round(c * 255), rgb))\n    assert len(ret) == 3\n    return ret\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.get_front_rgb","title":"<code>get_front_rgb(x, y)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def get_front_rgb(self, x: int, y: int) -&gt; tuple[int, int, int]:\n    s = self.get_val(x, y)\n    rgb = hsv_to_rgb(s.front_hue, s.front_saturation, s.front_brightness)\n    ret = tuple(map(lambda c: round(c * 255), rgb))\n    assert len(ret) == 3\n    return ret\n</code></pre>"},{"location":"reference/location/#location.DebugGrid.set_style","title":"<code>set_style(x, y, *, style=None, **kwargs)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def set_style(self, x: int, y: int, *, style: str | None = None, **kwargs: float) -&gt; None:\n    s = self.get_val(x, y)\n\n    if style:\n        s.style = style\n\n    for key, value in kwargs.items():\n        if value &lt; 0 or value &gt; 1:\n            raise Exception(\n                f\"set_style expects values to be floats between 0 and 1, '{key}' was '{value}'\"\n            )\n\n        match key:\n            case \"front_hue\":\n                s.front_hue = value\n            case \"front_brightness\":\n                s.front_brightness = value\n            case \"front_saturation\":\n                s.front_saturation = value\n            case \"back_hue\":\n                s.back_hue = value\n            case \"back_brightness\":\n                s.back_brightness = value\n            case \"back_saturation\":\n                s.back_saturation = value\n            case _:\n                raise Exception(f\"unknown key '{key}' in set_style\")\n</code></pre>"},{"location":"reference/location/#location.GridStyle","title":"<code>GridStyle</code>  <code>dataclass</code>","text":"<p>A stylized point on a text grid, where the text can be printed in any foreground or background color or style. Colors can be set using hue, saturation, and brightness (HSV) so that independent variables can control what color, how saturated the color is, and how bright the color is. This gives at least six debugging degrees of freedom for each point in the grid (in addition to value and style).</p> Source code in <code>roc/location.py</code> <pre><code>@dataclass\nclass GridStyle:\n    \"\"\"A stylized point on a text grid, where the text can be printed in any\n    foreground or background color or style. Colors can be set using hue,\n    saturation, and brightness (HSV) so that independent variables can control\n    what color, how saturated the color is, and how bright the color is. This\n    gives at least six debugging degrees of freedom for each point in the grid\n    (in addition to value and style).\n    \"\"\"\n\n    front_hue: float\n    front_saturation: float\n    front_brightness: float\n    back_hue: float\n    back_saturation: float\n    back_brightness: float\n    style: str\n    val: str\n</code></pre>"},{"location":"reference/location/#location.GridStyle.back_brightness","title":"<code>back_brightness: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.back_hue","title":"<code>back_hue: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.back_saturation","title":"<code>back_saturation: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.front_brightness","title":"<code>front_brightness: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.front_hue","title":"<code>front_hue: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.front_saturation","title":"<code>front_saturation: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.style","title":"<code>style: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.val","title":"<code>val: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.GridStyle.__init__","title":"<code>__init__(front_hue, front_saturation, front_brightness, back_hue, back_saturation, back_brightness, style, val)</code>","text":""},{"location":"reference/location/#location.IntGrid","title":"<code>IntGrid</code>","text":"<p>               Bases: <code>NewGrid[int]</code></p> Source code in <code>roc/location.py</code> <pre><code>class IntGrid(NewGrid[int]):\n    def get_point(self, x: int, y: int) -&gt; Point:\n        return Point(x, y, self[y, x])\n\n    def points(self) -&gt; Iterator[Point]:\n        \"\"\"Iterate over all the points in the grid\"\"\"\n        for v, x, y in self:\n            yield Point(x, y, v)\n</code></pre>"},{"location":"reference/location/#location.IntGrid.get_point","title":"<code>get_point(x, y)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def get_point(self, x: int, y: int) -&gt; Point:\n    return Point(x, y, self[y, x])\n</code></pre>"},{"location":"reference/location/#location.IntGrid.points","title":"<code>points()</code>","text":"<p>Iterate over all the points in the grid</p> Source code in <code>roc/location.py</code> <pre><code>def points(self) -&gt; Iterator[Point]:\n    \"\"\"Iterate over all the points in the grid\"\"\"\n    for v, x, y in self:\n        yield Point(x, y, v)\n</code></pre>"},{"location":"reference/location/#location.NewGrid","title":"<code>NewGrid</code>","text":"<p>               Bases: <code>NDArray[Any]</code>, <code>Generic[GridType]</code></p> Source code in <code>roc/location.py</code> <pre><code>class NewGrid(npt.NDArray[Any], Generic[GridType]):\n    def __new__(cls, input_array: npt.ArrayLike) -&gt; Self:\n        obj = np.asarray(input_array).view(cls)\n        assert obj.ndim == 2\n        return obj\n\n    # def __array_finalize__(self, obj: npt.NDArray[Any] | None) -&gt; None:\n    #     if obj is None:\n    #         return\n\n    def __iter__(self) -&gt; Iterator[ValLocTuple[GridType]]:\n        for y, x in np.ndindex(self.shape):\n            yield (self[y, x], x, y)\n        # yield from np.nditer(self)\n\n    # def __init__(self, val_list: list[list[Any]] | np.ndarray) -&gt; None:\n    #     if not isinstance(val_list, np.ndarray):\n    #         val_list = np.array(val_list)\n    #     assert val_list.ndim == 2\n    #     self.val_list = val_list\n\n    def get_val(self, x: int, y: int) -&gt; GridType:\n        # XXX: not sure why I need to cast here, should this already be typed?\n        return cast(GridType, self[y, x])\n\n    def set_val(self, x: int, y: int, v: GridType) -&gt; None:\n        self[y, x] = v\n\n    @property\n    def width(self) -&gt; int:\n        return self.shape[1]\n\n    @property\n    def height(self) -&gt; int:\n        return self.shape[0]\n</code></pre>"},{"location":"reference/location/#location.NewGrid.height","title":"<code>height: int</code>  <code>property</code>","text":""},{"location":"reference/location/#location.NewGrid.width","title":"<code>width: int</code>  <code>property</code>","text":""},{"location":"reference/location/#location.NewGrid.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __iter__(self) -&gt; Iterator[ValLocTuple[GridType]]:\n    for y, x in np.ndindex(self.shape):\n        yield (self[y, x], x, y)\n</code></pre>"},{"location":"reference/location/#location.NewGrid.__new__","title":"<code>__new__(input_array)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __new__(cls, input_array: npt.ArrayLike) -&gt; Self:\n    obj = np.asarray(input_array).view(cls)\n    assert obj.ndim == 2\n    return obj\n</code></pre>"},{"location":"reference/location/#location.NewGrid.get_val","title":"<code>get_val(x, y)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def get_val(self, x: int, y: int) -&gt; GridType:\n    # XXX: not sure why I need to cast here, should this already be typed?\n    return cast(GridType, self[y, x])\n</code></pre>"},{"location":"reference/location/#location.NewGrid.set_val","title":"<code>set_val(x, y, v)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def set_val(self, x: int, y: int, v: GridType) -&gt; None:\n    self[y, x] = v\n</code></pre>"},{"location":"reference/location/#location.Point","title":"<code>Point</code>","text":"<p>Represents a int value at a 2D location (x, y)</p> Source code in <code>roc/location.py</code> <pre><code>class Point:\n    \"\"\"Represents a int value at a 2D location (x, y)\"\"\"\n\n    def __init__(self, x: int, y: int, val: int) -&gt; None:\n        self.x = x\n        self.y = y\n        self.val = val\n\n    def __hash__(self) -&gt; int:\n        return hash((self.x, self.y))\n\n    def __repr__(self) -&gt; str:\n        return f\"({self.x}, {self.y}): {self.val} '{chr(self.val)}'\"\n\n    def __eq__(self, p: Any) -&gt; bool:\n        if not isinstance(p, Point):\n            return False\n        return self.x == p.x and self.y == p.y and self.val == p.val\n\n    @staticmethod\n    def from_valloc(t: ValLocTuple[int]) -&gt; Point:\n        \"\"\"Converts a value / location tuple (x, y, value) to a Point.\n\n        Args:\n            t (ValLocTuple[int]): The tuple to convert\n\n        Returns:\n            Point: The new point that was created\n        \"\"\"\n        x, y, v = t\n        return Point(x, y, v)\n\n    @overload\n    @staticmethod\n    def isadjacent(*, x1: int, y1: int, x2: int, y2: int) -&gt; bool: ...\n\n    @overload\n    @staticmethod\n    def isadjacent(*, p1: Point, x2: int, y2: int) -&gt; bool: ...\n\n    @overload\n    @staticmethod\n    def isadjacent(*, p1: Point, p2: Point) -&gt; bool: ...\n\n    @staticmethod\n    def isadjacent(\n        # o1: int | Point, o2: int | Point, o3: int | None = None, o4: int | None = None\n        *,\n        x1: int | None = None,\n        y1: int | None = None,\n        x2: int | None = None,\n        y2: int | None = None,\n        p1: Point | None = None,\n        p2: Point | None = None,\n    ) -&gt; bool:\n        if isinstance(p1, Point):\n            x1 = p1.x\n            y1 = p1.y\n        elif not isinstance(x1, int) or not isinstance(y1, int):\n            raise TypeError(\"bad p1 arguments in isadjacent()\")\n\n        if isinstance(p2, Point):\n            x2 = p2.x\n            y2 = p2.y\n        elif not isinstance(x2, int) or not isinstance(y2, int):\n            raise TypeError(\"bad p2 arguments in isadjacent()\")\n\n        dx = abs(x1 - x2)\n        dy = abs(y1 - y2)\n        if dx == 0 and dy == 0:\n            return False\n\n        return dx &lt;= 1 and dy &lt;= 1\n</code></pre>"},{"location":"reference/location/#location.Point.val","title":"<code>val = val</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.Point.x","title":"<code>x = x</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.Point.y","title":"<code>y = y</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.Point.__eq__","title":"<code>__eq__(p)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __eq__(self, p: Any) -&gt; bool:\n    if not isinstance(p, Point):\n        return False\n    return self.x == p.x and self.y == p.y and self.val == p.val\n</code></pre>"},{"location":"reference/location/#location.Point.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __hash__(self) -&gt; int:\n    return hash((self.x, self.y))\n</code></pre>"},{"location":"reference/location/#location.Point.__init__","title":"<code>__init__(x, y, val)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __init__(self, x: int, y: int, val: int) -&gt; None:\n    self.x = x\n    self.y = y\n    self.val = val\n</code></pre>"},{"location":"reference/location/#location.Point.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"({self.x}, {self.y}): {self.val} '{chr(self.val)}'\"\n</code></pre>"},{"location":"reference/location/#location.Point.from_valloc","title":"<code>from_valloc(t)</code>  <code>staticmethod</code>","text":"<p>Converts a value / location tuple (x, y, value) to a Point.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ValLocTuple[int]</code> <p>The tuple to convert</p> required <p>Returns:</p> Name Type Description <code>Point</code> <code>Point</code> <p>The new point that was created</p> Source code in <code>roc/location.py</code> <pre><code>@staticmethod\ndef from_valloc(t: ValLocTuple[int]) -&gt; Point:\n    \"\"\"Converts a value / location tuple (x, y, value) to a Point.\n\n    Args:\n        t (ValLocTuple[int]): The tuple to convert\n\n    Returns:\n        Point: The new point that was created\n    \"\"\"\n    x, y, v = t\n    return Point(x, y, v)\n</code></pre>"},{"location":"reference/location/#location.Point.isadjacent","title":"<code>isadjacent(*, x1=None, y1=None, x2=None, y2=None, p1=None, p2=None)</code>  <code>staticmethod</code>","text":"Source code in <code>roc/location.py</code> <pre><code>@staticmethod\ndef isadjacent(\n    # o1: int | Point, o2: int | Point, o3: int | None = None, o4: int | None = None\n    *,\n    x1: int | None = None,\n    y1: int | None = None,\n    x2: int | None = None,\n    y2: int | None = None,\n    p1: Point | None = None,\n    p2: Point | None = None,\n) -&gt; bool:\n    if isinstance(p1, Point):\n        x1 = p1.x\n        y1 = p1.y\n    elif not isinstance(x1, int) or not isinstance(y1, int):\n        raise TypeError(\"bad p1 arguments in isadjacent()\")\n\n    if isinstance(p2, Point):\n        x2 = p2.x\n        y2 = p2.y\n    elif not isinstance(x2, int) or not isinstance(y2, int):\n        raise TypeError(\"bad p2 arguments in isadjacent()\")\n\n    dx = abs(x1 - x2)\n    dy = abs(y1 - y2)\n    if dx == 0 and dy == 0:\n        return False\n\n    return dx &lt;= 1 and dy &lt;= 1\n</code></pre>"},{"location":"reference/location/#location.PointCollection","title":"<code>PointCollection</code>","text":"<p>A collection of abitrary points</p> Source code in <code>roc/location.py</code> <pre><code>class PointCollection:\n    \"\"\"A collection of abitrary points\"\"\"\n\n    def __init__(self, point_list: PointList) -&gt; None:\n        self._point_hash: dict[int, Point] = {}\n        for p in point_list:\n            self.add(p)\n\n    def add(self, p: Point) -&gt; None:\n        \"\"\"Adds a new point to the collection\"\"\"\n        hash_val = self.do_hash(p)\n        self._point_hash[hash_val] = p\n\n    def contains(self, p: Point) -&gt; bool:\n        \"\"\"Verifies if a point is already in the collection or not\"\"\"\n        hash_val = self.do_hash(p)\n        return hash_val in self._point_hash\n\n    def do_hash(self, p: Point) -&gt; int:\n        \"\"\"Returns the hash value of a point. Mostly for internal use.\"\"\"\n        return hash((p.x, p.y))\n\n    @property\n    def size(self) -&gt; int:\n        return len(self._point_hash)\n\n    @property\n    def points(self) -&gt; PointList:\n        return list(self._point_hash.values())\n</code></pre>"},{"location":"reference/location/#location.PointCollection.points","title":"<code>points: PointList</code>  <code>property</code>","text":""},{"location":"reference/location/#location.PointCollection.size","title":"<code>size: int</code>  <code>property</code>","text":""},{"location":"reference/location/#location.PointCollection.__init__","title":"<code>__init__(point_list)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __init__(self, point_list: PointList) -&gt; None:\n    self._point_hash: dict[int, Point] = {}\n    for p in point_list:\n        self.add(p)\n</code></pre>"},{"location":"reference/location/#location.PointCollection.add","title":"<code>add(p)</code>","text":"<p>Adds a new point to the collection</p> Source code in <code>roc/location.py</code> <pre><code>def add(self, p: Point) -&gt; None:\n    \"\"\"Adds a new point to the collection\"\"\"\n    hash_val = self.do_hash(p)\n    self._point_hash[hash_val] = p\n</code></pre>"},{"location":"reference/location/#location.PointCollection.contains","title":"<code>contains(p)</code>","text":"<p>Verifies if a point is already in the collection or not</p> Source code in <code>roc/location.py</code> <pre><code>def contains(self, p: Point) -&gt; bool:\n    \"\"\"Verifies if a point is already in the collection or not\"\"\"\n    hash_val = self.do_hash(p)\n    return hash_val in self._point_hash\n</code></pre>"},{"location":"reference/location/#location.PointCollection.do_hash","title":"<code>do_hash(p)</code>","text":"<p>Returns the hash value of a point. Mostly for internal use.</p> Source code in <code>roc/location.py</code> <pre><code>def do_hash(self, p: Point) -&gt; int:\n    \"\"\"Returns the hash value of a point. Mostly for internal use.\"\"\"\n    return hash((p.x, p.y))\n</code></pre>"},{"location":"reference/location/#location.TextGrid","title":"<code>TextGrid</code>","text":"<p>               Bases: <code>IntGrid</code></p> Source code in <code>roc/location.py</code> <pre><code>class TextGrid(IntGrid):\n    def __str__(self) -&gt; str:\n        ret = \"\"\n        last_y = 0\n        for v, x, y in self:\n            if y != last_y:\n                ret += \"\\n\"\n                last_y = y\n\n            ret += chr(v)\n\n        ret += \"\\n\"\n        return ret\n</code></pre>"},{"location":"reference/location/#location.TextGrid.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __str__(self) -&gt; str:\n    ret = \"\"\n    last_y = 0\n    for v, x, y in self:\n        if y != last_y:\n            ret += \"\\n\"\n            last_y = y\n\n        ret += chr(v)\n\n    ret += \"\\n\"\n    return ret\n</code></pre>"},{"location":"reference/location/#location.TypedPointCollection","title":"<code>TypedPointCollection</code>","text":"<p>               Bases: <code>PointCollection</code></p> <p>A collection of points that all have the same type</p> Source code in <code>roc/location.py</code> <pre><code>class TypedPointCollection(PointCollection):\n    \"\"\"A collection of points that all have the same type\"\"\"\n\n    def __init__(self, type: int, point_list: PointList) -&gt; None:\n        self.type = type\n        super().__init__(point_list)\n\n    def __repr__(self) -&gt; str:\n        return f\"{len(self._point_hash)} Points: {self.type} ({chr(self.type)})\"\n\n    def do_hash(self, p: Point) -&gt; int:\n        return hash(p)\n\n    def add(self, p: Point) -&gt; None:\n        \"\"\"Add a new point to the collection and enforce that it is the same\n        type as the collection\n        \"\"\"\n        if p.val != self.type:\n            raise TypeError(\n                f\"Trying to add '{p.val}' to TypedPointCollection with type '{self.type}\"\n            )\n\n        super().add(p)\n</code></pre>"},{"location":"reference/location/#location.TypedPointCollection.type","title":"<code>type = type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/location/#location.TypedPointCollection.__init__","title":"<code>__init__(type, point_list)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __init__(self, type: int, point_list: PointList) -&gt; None:\n    self.type = type\n    super().__init__(point_list)\n</code></pre>"},{"location":"reference/location/#location.TypedPointCollection.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"{len(self._point_hash)} Points: {self.type} ({chr(self.type)})\"\n</code></pre>"},{"location":"reference/location/#location.TypedPointCollection.add","title":"<code>add(p)</code>","text":"<p>Add a new point to the collection and enforce that it is the same type as the collection</p> Source code in <code>roc/location.py</code> <pre><code>def add(self, p: Point) -&gt; None:\n    \"\"\"Add a new point to the collection and enforce that it is the same\n    type as the collection\n    \"\"\"\n    if p.val != self.type:\n        raise TypeError(\n            f\"Trying to add '{p.val}' to TypedPointCollection with type '{self.type}\"\n        )\n\n    super().add(p)\n</code></pre>"},{"location":"reference/location/#location.TypedPointCollection.do_hash","title":"<code>do_hash(p)</code>","text":"Source code in <code>roc/location.py</code> <pre><code>def do_hash(self, p: Point) -&gt; int:\n    return hash(p)\n</code></pre>"},{"location":"reference/logger/","title":"logger","text":"<p>This module defines the logging interface for storing system logs.</p>"},{"location":"reference/logger/#logger.__all__","title":"<code>__all__ = ['logger', 'init', 'default_log_filter']</code>  <code>module-attribute</code>","text":""},{"location":"reference/logger/#logger.default_log_filter","title":"<code>default_log_filter = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/logger/#logger.module_names","title":"<code>module_names = [name for (_, name, _) in pkgutil.iter_modules(['roc'])]</code>  <code>module-attribute</code>","text":""},{"location":"reference/logger/#logger.DebugModuleLevel","title":"<code>DebugModuleLevel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A Pydantic model for storing the logging level. Used primarily for setting per-module logging levels.</p> Source code in <code>roc/logger.py</code> <pre><code>class DebugModuleLevel(BaseModel):\n    \"\"\"A Pydantic model for storing the logging level. Used primarily for\n    setting per-module logging levels.\n    \"\"\"\n\n    module_name: str\n    log_level: str = Field(pattern=r\"TRACE|DEBUG|INFO|SUCCESS|WARNING|ERROR|CRITICAL\")\n\n    @field_validator(\"module_name\", mode=\"before\")\n    @classmethod\n    def validate_module_name(cls, name: str) -&gt; str:\n        assert (\n            name in module_names\n        ), f\"Module name '{name}' not a valid module name. Must be one of {module_names}\"\n\n        return name\n</code></pre>"},{"location":"reference/logger/#logger.DebugModuleLevel.log_level","title":"<code>log_level: str = Field(pattern='TRACE|DEBUG|INFO|SUCCESS|WARNING|ERROR|CRITICAL')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/logger/#logger.DebugModuleLevel.module_name","title":"<code>module_name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/logger/#logger.DebugModuleLevel.validate_module_name","title":"<code>validate_module_name(name)</code>  <code>classmethod</code>","text":"Source code in <code>roc/logger.py</code> <pre><code>@field_validator(\"module_name\", mode=\"before\")\n@classmethod\ndef validate_module_name(cls, name: str) -&gt; str:\n    assert (\n        name in module_names\n    ), f\"Module name '{name}' not a valid module name. Must be one of {module_names}\"\n\n    return name\n</code></pre>"},{"location":"reference/logger/#logger.LogFilter","title":"<code>LogFilter</code>","text":"<p>A Callable filter that determines if the loguru record should be logged or not.</p> Source code in <code>roc/logger.py</code> <pre><code>class LogFilter:\n    \"\"\"A Callable filter that determines if the loguru record should be logged\n    or not.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        level: str | None = None,\n        log_modules: str | None = None,\n        enabled: bool = True,\n        use_module_settings: bool = True,\n    ):\n        settings = Config.get()\n        self.level = level or settings.log_level\n        self.level_num = logger.level(self.level).no\n        if not isinstance(log_modules, str):\n            if use_module_settings:\n                log_modules = settings.log_modules\n            else:\n                log_modules = \"\"\n        mod_list = self.parse_module_str(log_modules)\n        self.module_levels = {mod_lvl.module_name: mod_lvl.log_level for mod_lvl in mod_list}\n\n    def __call__(self, record: Any) -&gt; bool:\n        # TODO: this would be more effecient as a dict rather than a loop (O(1) rather than O(n))\n\n        if record[\"module\"] in self.module_levels:\n            mod_log_level = self.module_levels[record[\"module\"]]\n            mod_level_num = logger.level(mod_log_level).no\n            if record[\"level\"].no &gt;= mod_level_num:\n                return True\n            else:\n                return False\n\n        if record[\"level\"].no &gt;= self.level_num:\n            return True\n\n        return False\n\n    @classmethod\n    def parse_module_str(cls, s: str) -&gt; list[DebugModuleLevel]:\n        s = s.strip()\n\n        mod_list = s.split(\";\")\n        # empty str\n        if mod_list == [\"\"]:\n            return []\n\n        mod_lvl_list: list[dict[str, str]] = []\n        for mod in mod_list:\n            mod_parts = mod.split(\":\")\n            mod_lvl_list.append({\"module_name\": mod_parts[0], \"log_level\": mod_parts[1]})\n\n        debug_module_list = TypeAdapter(list[DebugModuleLevel])\n        return debug_module_list.validate_python(mod_lvl_list)\n</code></pre>"},{"location":"reference/logger/#logger.LogFilter.level","title":"<code>level = level or settings.log_level</code>  <code>instance-attribute</code>","text":""},{"location":"reference/logger/#logger.LogFilter.level_num","title":"<code>level_num = logger.level(self.level).no</code>  <code>instance-attribute</code>","text":""},{"location":"reference/logger/#logger.LogFilter.module_levels","title":"<code>module_levels = {mod_lvl.module_name: mod_lvl.log_levelfor mod_lvl in mod_list}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/logger/#logger.LogFilter.__call__","title":"<code>__call__(record)</code>","text":"Source code in <code>roc/logger.py</code> <pre><code>def __call__(self, record: Any) -&gt; bool:\n    # TODO: this would be more effecient as a dict rather than a loop (O(1) rather than O(n))\n\n    if record[\"module\"] in self.module_levels:\n        mod_log_level = self.module_levels[record[\"module\"]]\n        mod_level_num = logger.level(mod_log_level).no\n        if record[\"level\"].no &gt;= mod_level_num:\n            return True\n        else:\n            return False\n\n    if record[\"level\"].no &gt;= self.level_num:\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/logger/#logger.LogFilter.__init__","title":"<code>__init__(*, level=None, log_modules=None, enabled=True, use_module_settings=True)</code>","text":"Source code in <code>roc/logger.py</code> <pre><code>def __init__(\n    self,\n    *,\n    level: str | None = None,\n    log_modules: str | None = None,\n    enabled: bool = True,\n    use_module_settings: bool = True,\n):\n    settings = Config.get()\n    self.level = level or settings.log_level\n    self.level_num = logger.level(self.level).no\n    if not isinstance(log_modules, str):\n        if use_module_settings:\n            log_modules = settings.log_modules\n        else:\n            log_modules = \"\"\n    mod_list = self.parse_module_str(log_modules)\n    self.module_levels = {mod_lvl.module_name: mod_lvl.log_level for mod_lvl in mod_list}\n</code></pre>"},{"location":"reference/logger/#logger.LogFilter.parse_module_str","title":"<code>parse_module_str(s)</code>  <code>classmethod</code>","text":"Source code in <code>roc/logger.py</code> <pre><code>@classmethod\ndef parse_module_str(cls, s: str) -&gt; list[DebugModuleLevel]:\n    s = s.strip()\n\n    mod_list = s.split(\";\")\n    # empty str\n    if mod_list == [\"\"]:\n        return []\n\n    mod_lvl_list: list[dict[str, str]] = []\n    for mod in mod_list:\n        mod_parts = mod.split(\":\")\n        mod_lvl_list.append({\"module_name\": mod_parts[0], \"log_level\": mod_parts[1]})\n\n    debug_module_list = TypeAdapter(list[DebugModuleLevel])\n    return debug_module_list.validate_python(mod_lvl_list)\n</code></pre>"},{"location":"reference/logger/#logger.init","title":"<code>init()</code>","text":"<p>Initializes the logging module. Installs the filter, fetches the settings, etc.</p> Source code in <code>roc/logger.py</code> <pre><code>def init() -&gt; None:\n    \"\"\"Initializes the logging module. Installs the filter, fetches the\n    settings, etc.\n    \"\"\"\n    global default_log_filter\n    default_log_filter = LogFilter()\n\n    logger.remove()\n    settings = Config.get()\n    if settings.log_enable:\n        logger.add(sys.stderr, level=0, filter=default_log_filter)\n</code></pre>"},{"location":"reference/perception/","title":"perception","text":"<p>The Perception system breaks down the environment into features that can be re-assembled as concepts.</p>"},{"location":"reference/perception/#perception.FeatureTransmogrifier","title":"<code>FeatureTransmogrifier = TypeVar('FeatureTransmogrifier', bound=Transmogrifier)</code>  <code>module-attribute</code>","text":""},{"location":"reference/perception/#perception.FeatureType","title":"<code>FeatureType = TypeVar('FeatureType')</code>  <code>module-attribute</code>","text":""},{"location":"reference/perception/#perception.PerceptionData","title":"<code>PerceptionData = VisionData | Settled | Feature</code>  <code>module-attribute</code>","text":""},{"location":"reference/perception/#perception.PerceptionEvent","title":"<code>PerceptionEvent = Event[PerceptionData]</code>  <code>module-attribute</code>","text":""},{"location":"reference/perception/#perception.fe_list","title":"<code>fe_list: list[FeatureExtractor[Any]] = []</code>  <code>module-attribute</code>","text":""},{"location":"reference/perception/#perception.ComplexFeature","title":"<code>ComplexFeature</code>","text":"<p>               Bases: <code>Feature</code>, <code>Generic[FeatureTransmogrifier]</code></p> <p>Creates a new Feature based off of a Transmogrifier. Constructing the feature requires the Transmogrifier specified by the template. Also adds a convenient str method for debugging the Feature.</p> Source code in <code>roc/perception.py</code> <pre><code>class ComplexFeature(Feature, Generic[FeatureTransmogrifier]):\n    \"\"\"Creates a new Feature based off of a Transmogrifier. Constructing the\n    feature requires the Transmogrifier specified by the template. Also adds a\n    convenient __str__ method for debugging the Feature.\n    \"\"\"\n\n    def __init__(self, name: str, origin: Component, trans: FeatureTransmogrifier) -&gt; None:\n        super().__init__(origin, name)\n        self._transmogrifier = trans\n        self._transmogrifier.add_to_feature(self)\n\n    def __str__(self) -&gt; str:\n        f = self._transmogrifier.__class__.from_feature(self)\n        return str(f)\n</code></pre>"},{"location":"reference/perception/#perception.ComplexFeature.__init__","title":"<code>__init__(name, origin, trans)</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __init__(self, name: str, origin: Component, trans: FeatureTransmogrifier) -&gt; None:\n    super().__init__(origin, name)\n    self._transmogrifier = trans\n    self._transmogrifier.add_to_feature(self)\n</code></pre>"},{"location":"reference/perception/#perception.ComplexFeature.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __str__(self) -&gt; str:\n    f = self._transmogrifier.__class__.from_feature(self)\n    return str(f)\n</code></pre>"},{"location":"reference/perception/#perception.Direction","title":"<code>Direction</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>roc/perception.py</code> <pre><code>class Direction(str, Enum):\n    up = \"UP\"\n    down = \"DOWN\"\n    left = \"LEFT\"\n    right = \"RIGHT\"\n    up_right = \"UP_RIGHT\"\n    up_left = \"UP_LEFT\"\n    down_right = \"DOWN_RIGHT\"\n    down_left = \"DOWN_LEFT\"\n</code></pre>"},{"location":"reference/perception/#perception.Direction.down","title":"<code>down = 'DOWN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction.down_left","title":"<code>down_left = 'DOWN_LEFT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction.down_right","title":"<code>down_right = 'DOWN_RIGHT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction.left","title":"<code>left = 'LEFT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction.right","title":"<code>right = 'RIGHT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction.up","title":"<code>up = 'UP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction.up_left","title":"<code>up_left = 'UP_LEFT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Direction.up_right","title":"<code>up_right = 'UP_RIGHT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.ElementOrientation","title":"<code>ElementOrientation</code>","text":"<p>               Bases: <code>Node</code></p> Source code in <code>roc/perception.py</code> <pre><code>class ElementOrientation(Node, extra=\"forbid\"):\n    # _no_save = True\n    orientation: Direction\n</code></pre>"},{"location":"reference/perception/#perception.ElementOrientation.orientation","title":"<code>orientation: Direction</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.ElementPoint","title":"<code>ElementPoint</code>","text":"<p>               Bases: <code>Node</code></p> Source code in <code>roc/perception.py</code> <pre><code>class ElementPoint(Node, extra=\"forbid\"):\n    # _no_save = True\n    x: int\n    y: int\n</code></pre>"},{"location":"reference/perception/#perception.ElementPoint.x","title":"<code>x: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.ElementPoint.y","title":"<code>y: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.ElementSize","title":"<code>ElementSize</code>","text":"<p>               Bases: <code>Node</code></p> Source code in <code>roc/perception.py</code> <pre><code>class ElementSize(Node, extra=\"forbid\"):\n    # _no_save = True\n    size: int\n</code></pre>"},{"location":"reference/perception/#perception.ElementSize.size","title":"<code>size: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.ElementType","title":"<code>ElementType</code>","text":"<p>               Bases: <code>Node</code></p> Source code in <code>roc/perception.py</code> <pre><code>class ElementType(Node, extra=\"forbid\"):\n    # _no_save = True\n    type: int\n</code></pre>"},{"location":"reference/perception/#perception.ElementType.type","title":"<code>type: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.ElementTypedPoint","title":"<code>ElementTypedPoint</code>","text":"<p>               Bases: <code>Node</code></p> Source code in <code>roc/perception.py</code> <pre><code>class ElementTypedPoint(Node, extra=\"forbid\"):\n    # _no_save = True\n    type: int\n    x: int\n    y: int\n</code></pre>"},{"location":"reference/perception/#perception.ElementTypedPoint.type","title":"<code>type: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.ElementTypedPoint.x","title":"<code>x: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.ElementTypedPoint.y","title":"<code>y: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Feature","title":"<code>Feature</code>","text":"<p>               Bases: <code>Node</code>, <code>ABC</code></p> <p>A detail of the environment that has been created by a feature extractor</p> Source code in <code>roc/perception.py</code> <pre><code>class Feature(Node, ABC):\n    \"\"\"A detail of the environment that has been created by a feature extractor\"\"\"\n\n    # _no_save = True\n    _origin: str\n\n    @property\n    def origin(self) -&gt; str:\n        \"\"\"The name of the Component that created this feature\"\"\"\n        return self._origin\n\n    def __init__(self, origin: Component | str, label: str) -&gt; None:\n        super().__init__(labels={\"Feature\", label})\n        if isinstance(origin, Component):\n            origin = f\"{origin.name}:{origin.type}\"\n        # XXX: don't store a reference to the actual component or you may end up\n        # with circular references and memory leaks\n        self._origin = origin\n\n    def add_type(self, type: int) -&gt; ElementType:\n        \"\"\"Add a type Node to the feature that describes the type of feature\"\"\"\n        f = ElementType(type=type)\n        Node.connect(self, f, \"Type\")\n        return f\n\n    def add_point(self, x: int, y: int) -&gt; ElementPoint:\n        \"\"\"Add a location Node to the feature that describes one or more places\n        where this feature exists.\n        \"\"\"\n        p = ElementPoint(x=x, y=y)\n        Node.connect(self, p, \"Location\")\n        return p\n\n    def add_size(self, size: int) -&gt; ElementSize:\n        \"\"\"Add a size Node to the feature that describes the magnitude of the feature\"\"\"\n        s = ElementSize(size=size)\n        Node.connect(self, s, \"Size\")\n        return s\n\n    def add_orientation(self, orientation: Direction) -&gt; ElementOrientation:\n        \"\"\"Add a direction Node to the feature that describes a direction or\n        orientation of the feature\n        \"\"\"\n        o = ElementOrientation(orientation=orientation)\n        Node.connect(self, o, \"Direction\")\n        return o\n\n    def add_feature(self, type: str, feature: Feature) -&gt; Feature:\n        \"\"\"Add an arbitrary Feature Node\"\"\"\n        Node.connect(self, feature, type)\n        return feature\n\n    def get_feature(self, type: str) -&gt; Node | None:\n        \"\"\"Get an Feature Node of the type described, or None if it doesn't\n        exist. If multiple matching features are found, the first one is returned.\n        \"\"\"\n        nodes = self.get_features(type)\n        if len(nodes) &lt; 1:\n            return None\n\n        return nodes[0]\n\n    def get_features(self, type: str) -&gt; list[Node]:\n        \"\"\"Return all matching Feature Nodes of the type described.\"\"\"\n        edge_iter = self.src_edges.get_edges(type)\n        return list(map(lambda e: e.dst, edge_iter))\n\n    def get_point(self) -&gt; tuple[int, int]:\n        pt = self.get_feature(\"Location\")\n        if not pt:\n            raise Exception(\"no Location in get_point()\")\n\n        assert isinstance(pt, ElementPoint)\n        return (pt.x, pt.y)\n\n    def get_type(self) -&gt; int:\n        t = self.get_feature(\"Type\")\n        if not t:\n            raise Exception(\"no Type in get_type()\")\n\n        assert isinstance(t, ElementType)\n        return t.type\n\n    def get_orientation(self) -&gt; Direction:\n        o = self.get_feature(\"Direction\")\n        if not o:\n            raise Exception(\"no Orientation in get_orientation()\")\n\n        assert isinstance(o, ElementOrientation)\n        return o.orientation\n</code></pre>"},{"location":"reference/perception/#perception.Feature.origin","title":"<code>origin: str</code>  <code>property</code>","text":"<p>The name of the Component that created this feature</p>"},{"location":"reference/perception/#perception.Feature.__init__","title":"<code>__init__(origin, label)</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __init__(self, origin: Component | str, label: str) -&gt; None:\n    super().__init__(labels={\"Feature\", label})\n    if isinstance(origin, Component):\n        origin = f\"{origin.name}:{origin.type}\"\n    # XXX: don't store a reference to the actual component or you may end up\n    # with circular references and memory leaks\n    self._origin = origin\n</code></pre>"},{"location":"reference/perception/#perception.Feature.add_feature","title":"<code>add_feature(type, feature)</code>","text":"<p>Add an arbitrary Feature Node</p> Source code in <code>roc/perception.py</code> <pre><code>def add_feature(self, type: str, feature: Feature) -&gt; Feature:\n    \"\"\"Add an arbitrary Feature Node\"\"\"\n    Node.connect(self, feature, type)\n    return feature\n</code></pre>"},{"location":"reference/perception/#perception.Feature.add_orientation","title":"<code>add_orientation(orientation)</code>","text":"<p>Add a direction Node to the feature that describes a direction or orientation of the feature</p> Source code in <code>roc/perception.py</code> <pre><code>def add_orientation(self, orientation: Direction) -&gt; ElementOrientation:\n    \"\"\"Add a direction Node to the feature that describes a direction or\n    orientation of the feature\n    \"\"\"\n    o = ElementOrientation(orientation=orientation)\n    Node.connect(self, o, \"Direction\")\n    return o\n</code></pre>"},{"location":"reference/perception/#perception.Feature.add_point","title":"<code>add_point(x, y)</code>","text":"<p>Add a location Node to the feature that describes one or more places where this feature exists.</p> Source code in <code>roc/perception.py</code> <pre><code>def add_point(self, x: int, y: int) -&gt; ElementPoint:\n    \"\"\"Add a location Node to the feature that describes one or more places\n    where this feature exists.\n    \"\"\"\n    p = ElementPoint(x=x, y=y)\n    Node.connect(self, p, \"Location\")\n    return p\n</code></pre>"},{"location":"reference/perception/#perception.Feature.add_size","title":"<code>add_size(size)</code>","text":"<p>Add a size Node to the feature that describes the magnitude of the feature</p> Source code in <code>roc/perception.py</code> <pre><code>def add_size(self, size: int) -&gt; ElementSize:\n    \"\"\"Add a size Node to the feature that describes the magnitude of the feature\"\"\"\n    s = ElementSize(size=size)\n    Node.connect(self, s, \"Size\")\n    return s\n</code></pre>"},{"location":"reference/perception/#perception.Feature.add_type","title":"<code>add_type(type)</code>","text":"<p>Add a type Node to the feature that describes the type of feature</p> Source code in <code>roc/perception.py</code> <pre><code>def add_type(self, type: int) -&gt; ElementType:\n    \"\"\"Add a type Node to the feature that describes the type of feature\"\"\"\n    f = ElementType(type=type)\n    Node.connect(self, f, \"Type\")\n    return f\n</code></pre>"},{"location":"reference/perception/#perception.Feature.get_feature","title":"<code>get_feature(type)</code>","text":"<p>Get an Feature Node of the type described, or None if it doesn't exist. If multiple matching features are found, the first one is returned.</p> Source code in <code>roc/perception.py</code> <pre><code>def get_feature(self, type: str) -&gt; Node | None:\n    \"\"\"Get an Feature Node of the type described, or None if it doesn't\n    exist. If multiple matching features are found, the first one is returned.\n    \"\"\"\n    nodes = self.get_features(type)\n    if len(nodes) &lt; 1:\n        return None\n\n    return nodes[0]\n</code></pre>"},{"location":"reference/perception/#perception.Feature.get_features","title":"<code>get_features(type)</code>","text":"<p>Return all matching Feature Nodes of the type described.</p> Source code in <code>roc/perception.py</code> <pre><code>def get_features(self, type: str) -&gt; list[Node]:\n    \"\"\"Return all matching Feature Nodes of the type described.\"\"\"\n    edge_iter = self.src_edges.get_edges(type)\n    return list(map(lambda e: e.dst, edge_iter))\n</code></pre>"},{"location":"reference/perception/#perception.Feature.get_orientation","title":"<code>get_orientation()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def get_orientation(self) -&gt; Direction:\n    o = self.get_feature(\"Direction\")\n    if not o:\n        raise Exception(\"no Orientation in get_orientation()\")\n\n    assert isinstance(o, ElementOrientation)\n    return o.orientation\n</code></pre>"},{"location":"reference/perception/#perception.Feature.get_point","title":"<code>get_point()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def get_point(self) -&gt; tuple[int, int]:\n    pt = self.get_feature(\"Location\")\n    if not pt:\n        raise Exception(\"no Location in get_point()\")\n\n    assert isinstance(pt, ElementPoint)\n    return (pt.x, pt.y)\n</code></pre>"},{"location":"reference/perception/#perception.Feature.get_type","title":"<code>get_type()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def get_type(self) -&gt; int:\n    t = self.get_feature(\"Type\")\n    if not t:\n        raise Exception(\"no Type in get_type()\")\n\n    assert isinstance(t, ElementType)\n    return t.type\n</code></pre>"},{"location":"reference/perception/#perception.FeatureExtractor","title":"<code>FeatureExtractor</code>","text":"<p>               Bases: <code>Perception</code>, <code>Generic[FeatureType]</code>, <code>ABC</code></p> Source code in <code>roc/perception.py</code> <pre><code>class FeatureExtractor(Perception, Generic[FeatureType], ABC):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        fe_list.append(weakref.proxy(self))\n\n    def do_perception(self, e: PerceptionEvent) -&gt; None:\n        f = self.get_feature(e)\n        if f is None:\n            return\n\n        self.pb_conn.send(f)\n\n    def settled(self) -&gt; None:\n        self.pb_conn.send(Settled())\n\n    @abstractmethod\n    def get_feature(self, e: PerceptionEvent) -&gt; Feature | None: ...\n\n    @classmethod\n    def list(cls) -&gt; list[str]:\n        ret: list[str] = []\n        for fe in fe_list:\n            ret.append(f\"{fe.name}:{fe.type}\")\n\n        return ret\n</code></pre>"},{"location":"reference/perception/#perception.FeatureExtractor.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    fe_list.append(weakref.proxy(self))\n</code></pre>"},{"location":"reference/perception/#perception.FeatureExtractor.do_perception","title":"<code>do_perception(e)</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def do_perception(self, e: PerceptionEvent) -&gt; None:\n    f = self.get_feature(e)\n    if f is None:\n        return\n\n    self.pb_conn.send(f)\n</code></pre>"},{"location":"reference/perception/#perception.FeatureExtractor.get_feature","title":"<code>get_feature(e)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@abstractmethod\ndef get_feature(self, e: PerceptionEvent) -&gt; Feature | None: ...\n</code></pre>"},{"location":"reference/perception/#perception.FeatureExtractor.list","title":"<code>list()</code>  <code>classmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@classmethod\ndef list(cls) -&gt; list[str]:\n    ret: list[str] = []\n    for fe in fe_list:\n        ret.append(f\"{fe.name}:{fe.type}\")\n\n    return ret\n</code></pre>"},{"location":"reference/perception/#perception.FeatureExtractor.settled","title":"<code>settled()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def settled(self) -&gt; None:\n    self.pb_conn.send(Settled())\n</code></pre>"},{"location":"reference/perception/#perception.HashingNoneFeature","title":"<code>HashingNoneFeature</code>","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>roc/perception.py</code> <pre><code>class HashingNoneFeature(Exception):\n    pass\n</code></pre>"},{"location":"reference/perception/#perception.OldLocation","title":"<code>OldLocation</code>","text":"<p>               Bases: <code>Feature</code></p> <p>A feature for describing an old location and value</p> Source code in <code>roc/perception.py</code> <pre><code>class OldLocation(Feature):\n    \"\"\"A feature for describing an old location and value\"\"\"\n\n    def __init__(self, origin: str, x: int, y: int, val: int) -&gt; None:\n        super().__init__(origin, \"Old\")\n        self.add_type(val)\n        self.add_point(x, y)\n</code></pre>"},{"location":"reference/perception/#perception.OldLocation.__init__","title":"<code>__init__(origin, x, y, val)</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __init__(self, origin: str, x: int, y: int, val: int) -&gt; None:\n    super().__init__(origin, \"Old\")\n    self.add_type(val)\n    self.add_point(x, y)\n</code></pre>"},{"location":"reference/perception/#perception.Perception","title":"<code>Perception</code>","text":"<p>               Bases: <code>Component</code>, <code>ABC</code></p> <p>The abstract class for Perception components. Handles perception bus connections and corresponding clean-up.</p> Source code in <code>roc/perception.py</code> <pre><code>class Perception(Component, ABC):\n    \"\"\"The abstract class for Perception components. Handles perception bus\n    connections and corresponding clean-up.\n    \"\"\"\n\n    bus = EventBus[PerceptionData](\"perception\")\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.pb_conn = self.connect_bus(Perception.bus)\n        self.pb_conn.listen(self.do_perception)\n\n    @abstractmethod\n    def do_perception(self, e: PerceptionEvent) -&gt; None: ...\n\n    @classmethod\n    def init(cls) -&gt; None:\n        global perception_bus\n        cls.bus = EventBus[PerceptionData](\"perception\")\n</code></pre>"},{"location":"reference/perception/#perception.Perception.bus","title":"<code>bus = EventBus[PerceptionData]('perception')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Perception.pb_conn","title":"<code>pb_conn = self.connect_bus(Perception.bus)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.Perception.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.pb_conn = self.connect_bus(Perception.bus)\n    self.pb_conn.listen(self.do_perception)\n</code></pre>"},{"location":"reference/perception/#perception.Perception.do_perception","title":"<code>do_perception(e)</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@abstractmethod\ndef do_perception(self, e: PerceptionEvent) -&gt; None: ...\n</code></pre>"},{"location":"reference/perception/#perception.Perception.init","title":"<code>init()</code>  <code>classmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@classmethod\ndef init(cls) -&gt; None:\n    global perception_bus\n    cls.bus = EventBus[PerceptionData](\"perception\")\n</code></pre>"},{"location":"reference/perception/#perception.Settled","title":"<code>Settled</code>  <code>dataclass</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@dataclass\nclass Settled:\n    pass\n</code></pre>"},{"location":"reference/perception/#perception.Settled.__init__","title":"<code>__init__()</code>","text":""},{"location":"reference/perception/#perception.Transmogrifier","title":"<code>Transmogrifier</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Features are represented as collections of Nodes; however, that's frequently difficult to work with. Implementations of this abstract class convert Nodes to a dataclass that's easier to work with (and vice versa).</p> Source code in <code>roc/perception.py</code> <pre><code>@dataclass\nclass Transmogrifier(ABC):\n    \"\"\"Features are represented as collections of Nodes; however, that's\n    frequently difficult to work with. Implementations of this abstract class\n    convert Nodes to a dataclass that's easier to work with (and vice versa).\n    \"\"\"\n\n    @abstractmethod\n    def __str__(self) -&gt; str:\n        pass\n\n    @abstractmethod\n    def add_to_feature(self, n: Feature) -&gt; None:\n        \"\"\"Converts the dataclass to Nodes and adds those Nodes as children of\n        the specified Feature.\n        \"\"\"\n        pass\n\n    @classmethod\n    @abstractmethod\n    def from_feature(self, n: Feature) -&gt; Self:\n        \"\"\"Creates an instance of this dataclass from the specified Feature.\n        Raises an exception if the required Nodes aren't present on the\n        specified Feature.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/perception/#perception.Transmogrifier.__init__","title":"<code>__init__()</code>","text":""},{"location":"reference/perception/#perception.Transmogrifier.__str__","title":"<code>__str__()</code>  <code>abstractmethod</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>@abstractmethod\ndef __str__(self) -&gt; str:\n    pass\n</code></pre>"},{"location":"reference/perception/#perception.Transmogrifier.add_to_feature","title":"<code>add_to_feature(n)</code>  <code>abstractmethod</code>","text":"<p>Converts the dataclass to Nodes and adds those Nodes as children of the specified Feature.</p> Source code in <code>roc/perception.py</code> <pre><code>@abstractmethod\ndef add_to_feature(self, n: Feature) -&gt; None:\n    \"\"\"Converts the dataclass to Nodes and adds those Nodes as children of\n    the specified Feature.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/perception/#perception.Transmogrifier.from_feature","title":"<code>from_feature(n)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Creates an instance of this dataclass from the specified Feature. Raises an exception if the required Nodes aren't present on the specified Feature.</p> Source code in <code>roc/perception.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_feature(self, n: Feature) -&gt; Self:\n    \"\"\"Creates an instance of this dataclass from the specified Feature.\n    Raises an exception if the required Nodes aren't present on the\n    specified Feature.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/perception/#perception.VisionData","title":"<code>VisionData</code>","text":"<p>Vision data received from the environment.</p> Source code in <code>roc/perception.py</code> <pre><code>class VisionData:\n    \"\"\"Vision data received from the environment.\"\"\"\n\n    def __init__(\n        self,\n        glyphs: npt.NDArray[Any],\n        chars: npt.NDArray[Any],\n        colors: npt.NDArray[Any],\n    ) -&gt; None:\n        self.glyphs = glyphs\n        self.chars = chars\n        self.colors = colors\n\n    @staticmethod\n    def from_dict(d: dict[str, Any]) -&gt; VisionData:\n        \"\"\"Creates VisionData from an arbitrary dictionary\n\n        Args:\n            d (dict[str, Any]): The dictionary to create VisionData from. Must\n            have 'chars', 'glyphs', and 'colors' members.\n\n        Returns:\n            VisionData: The newly created vision data.\n        \"\"\"\n\n        def to_numpy(d: dict[str, Any], k: str) -&gt; np.ndarray[Any, Any]:\n            if not k in d:\n                raise Exception(f\"Expected '{k}' to exist in dict for VisionData.from_dict()\")\n\n            v = d[k]\n            if not isinstance(v, np.ndarray):\n                return np.array(v)\n            return v\n\n        glyphs = to_numpy(d, \"glyphs\")\n        chars = to_numpy(d, \"chars\")\n        colors = to_numpy(d, \"colors\")\n        return VisionData(glyphs, chars, colors)\n\n    @staticmethod\n    def for_test(test_data: list[list[int]]) -&gt; VisionData:\n        \"\"\"Creates VisionData for a test case, using a static 2D list of values\n        to create all aspects of the VisionData\n\n        Args:\n            test_data (list[list[int]]): The test data to convert into VisionData\n\n        Returns:\n            VisionData: The created VisionData\n        \"\"\"\n        a = np.array(test_data)\n        return VisionData(a.copy(), a.copy(), a.copy())\n</code></pre>"},{"location":"reference/perception/#perception.VisionData.chars","title":"<code>chars = chars</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.VisionData.colors","title":"<code>colors = colors</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.VisionData.glyphs","title":"<code>glyphs = glyphs</code>  <code>instance-attribute</code>","text":""},{"location":"reference/perception/#perception.VisionData.__init__","title":"<code>__init__(glyphs, chars, colors)</code>","text":"Source code in <code>roc/perception.py</code> <pre><code>def __init__(\n    self,\n    glyphs: npt.NDArray[Any],\n    chars: npt.NDArray[Any],\n    colors: npt.NDArray[Any],\n) -&gt; None:\n    self.glyphs = glyphs\n    self.chars = chars\n    self.colors = colors\n</code></pre>"},{"location":"reference/perception/#perception.VisionData.for_test","title":"<code>for_test(test_data)</code>  <code>staticmethod</code>","text":"<p>Creates VisionData for a test case, using a static 2D list of values to create all aspects of the VisionData</p> <p>Parameters:</p> Name Type Description Default <code>test_data</code> <code>list[list[int]]</code> <p>The test data to convert into VisionData</p> required <p>Returns:</p> Name Type Description <code>VisionData</code> <code>VisionData</code> <p>The created VisionData</p> Source code in <code>roc/perception.py</code> <pre><code>@staticmethod\ndef for_test(test_data: list[list[int]]) -&gt; VisionData:\n    \"\"\"Creates VisionData for a test case, using a static 2D list of values\n    to create all aspects of the VisionData\n\n    Args:\n        test_data (list[list[int]]): The test data to convert into VisionData\n\n    Returns:\n        VisionData: The created VisionData\n    \"\"\"\n    a = np.array(test_data)\n    return VisionData(a.copy(), a.copy(), a.copy())\n</code></pre>"},{"location":"reference/perception/#perception.VisionData.from_dict","title":"<code>from_dict(d)</code>  <code>staticmethod</code>","text":"<p>Creates VisionData from an arbitrary dictionary</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict[str, Any]</code> <p>The dictionary to create VisionData from. Must</p> required <p>Returns:</p> Name Type Description <code>VisionData</code> <code>VisionData</code> <p>The newly created vision data.</p> Source code in <code>roc/perception.py</code> <pre><code>@staticmethod\ndef from_dict(d: dict[str, Any]) -&gt; VisionData:\n    \"\"\"Creates VisionData from an arbitrary dictionary\n\n    Args:\n        d (dict[str, Any]): The dictionary to create VisionData from. Must\n        have 'chars', 'glyphs', and 'colors' members.\n\n    Returns:\n        VisionData: The newly created vision data.\n    \"\"\"\n\n    def to_numpy(d: dict[str, Any], k: str) -&gt; np.ndarray[Any, Any]:\n        if not k in d:\n            raise Exception(f\"Expected '{k}' to exist in dict for VisionData.from_dict()\")\n\n        v = d[k]\n        if not isinstance(v, np.ndarray):\n            return np.array(v)\n        return v\n\n    glyphs = to_numpy(d, \"glyphs\")\n    chars = to_numpy(d, \"chars\")\n    colors = to_numpy(d, \"colors\")\n    return VisionData(glyphs, chars, colors)\n</code></pre>"},{"location":"reference/script/","title":"script","text":"<p>This is a Python script that runs the Gym and agent, typically from the command-line. See the Makefile for how to run this script.</p>"},{"location":"reference/script/#script.pp","title":"<code>pp = pprint.PrettyPrinter(width=41, compact=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/script/#script.ascii_list","title":"<code>ascii_list(al)</code>","text":"Source code in <code>roc/script.py</code> <pre><code>def ascii_list(al: list[int]) -&gt; str:\n    result_string = \"\"\n\n    for ascii_value in al:\n        result_string += chr(ascii_value)\n\n    return result_string\n</code></pre>"},{"location":"reference/script/#script.cli","title":"<code>cli(arg)</code>","text":"Source code in <code>roc/script.py</code> <pre><code>@click.command\n@click.option(\"--arg\", default=1)\ndef cli(arg: Any) -&gt; None:\n    roc.init()\n    roc.start()\n</code></pre>"},{"location":"reference/script/#script.int_list","title":"<code>int_list(al)</code>","text":"Source code in <code>roc/script.py</code> <pre><code>def int_list(al: list[int]) -&gt; str:\n    result_string = \"\"\n\n    for ascii_value in al:\n        result_string += str(ascii_value) + \" \"\n\n    return result_string\n</code></pre>"},{"location":"reference/script/#script.print_screen","title":"<code>print_screen(screen, *, as_int=False)</code>","text":"Source code in <code>roc/script.py</code> <pre><code>def print_screen(screen: list[list[int]], *, as_int: bool = False) -&gt; None:\n    for row in screen:\n        if not as_int:\n            print(ascii_list(row))  # noqa: T201\n        else:\n            print(int_list(row))  # noqa: T201\n</code></pre>"},{"location":"reference/feature_extractors/delta/","title":"delta","text":"<p>A component for generating Features that represent differences in vision</p>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Delta","title":"<code>Delta</code>","text":"<p>               Bases: <code>FeatureExtractor[DeltaFeature]</code></p> <p>A component for detecting changes in vision.</p> Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>@register_component(\"delta\", \"perception\")\nclass Delta(FeatureExtractor[DeltaFeature]):\n    \"\"\"A component for detecting changes in vision.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.prev_viz: IntGrid | None = None\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        return isinstance(e.data, VisionData)\n\n    def get_feature(self, e: PerceptionEvent) -&gt; None:\n        data = e.data\n        assert isinstance(data, VisionData)\n\n        prev = self.prev_viz\n        self.prev_viz = curr = IntGrid(data.chars)  # TODO: glyphs\n\n        if prev is None:\n            # can't get difference when there was nothing before this\n            self.settled()\n            return None\n\n        # roughly make sure that things are the same size\n        assert prev.height == curr.height\n        assert prev.width == curr.width\n\n        for new_point in curr.points():\n            old_point = prev.get_point(new_point.x, new_point.y)\n            if old_point.val != new_point.val:\n                self.pb_conn.send(\n                    DeltaFeature(\n                        self,\n                        Diff(\n                            x=new_point.x,\n                            y=new_point.y,\n                            old_val=old_point.val,\n                            new_val=new_point.val,\n                        ),\n                    )\n                )\n\n        self.settled()\n        return None\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Delta.prev_viz","title":"<code>prev_viz: IntGrid | None = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Delta.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.prev_viz: IntGrid | None = None\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Delta.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    return isinstance(e.data, VisionData)\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Delta.get_feature","title":"<code>get_feature(e)</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def get_feature(self, e: PerceptionEvent) -&gt; None:\n    data = e.data\n    assert isinstance(data, VisionData)\n\n    prev = self.prev_viz\n    self.prev_viz = curr = IntGrid(data.chars)  # TODO: glyphs\n\n    if prev is None:\n        # can't get difference when there was nothing before this\n        self.settled()\n        return None\n\n    # roughly make sure that things are the same size\n    assert prev.height == curr.height\n    assert prev.width == curr.width\n\n    for new_point in curr.points():\n        old_point = prev.get_point(new_point.x, new_point.y)\n        if old_point.val != new_point.val:\n            self.pb_conn.send(\n                DeltaFeature(\n                    self,\n                    Diff(\n                        x=new_point.x,\n                        y=new_point.y,\n                        old_val=old_point.val,\n                        new_val=new_point.val,\n                    ),\n                )\n            )\n\n    self.settled()\n    return None\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaFeature","title":"<code>DeltaFeature</code>","text":"<p>               Bases: <code>ComplexFeature[Diff]</code></p> <p>A Feature that describes changes in vision</p> Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>class DeltaFeature(ComplexFeature[Diff]):\n    \"\"\"A Feature that describes changes in vision\"\"\"\n\n    def __init__(self, origin: Component, d: Diff) -&gt; None:\n        super().__init__(\"Delta\", origin, d)\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.DeltaFeature.__init__","title":"<code>__init__(origin, d)</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def __init__(self, origin: Component, d: Diff) -&gt; None:\n    super().__init__(\"Delta\", origin, d)\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Diff","title":"<code>Diff</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Transmogrifier</code></p> <p>A dataclass for representing a changes in vision.</p> Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>@dataclass\nclass Diff(Transmogrifier):\n    \"\"\"A dataclass for representing a changes in vision.\"\"\"\n\n    x: int\n    y: int\n    old_val: int\n    new_val: int\n\n    def __str__(self) -&gt; str:\n        return f\"({self.x}, {self.y}): {self.old_val} '{chr(self.old_val)}' -&gt; {self.new_val} '{chr(self.new_val)}'\\n\"\n\n    def add_to_feature(self, n: Feature) -&gt; None:\n        \"\"\"Adds a set of Diff nodes to a Feature\"\"\"\n        n.add_type(self.new_val)\n        n.add_point(self.x, self.y)\n        ol = OldLocation(n.origin, self.x, self.y, self.old_val)\n        n.add_feature(\"Past\", ol)\n\n    @classmethod\n    def from_feature(self, n: Feature) -&gt; Diff:\n        \"\"\"Creates a Diff from a Feature that has all the right Nodes\"\"\"\n        x, y = n.get_point()\n        new_val = n.get_type()\n        old = n.get_feature(\"Past\")\n        assert isinstance(old, Feature)\n        old_val = old.get_type()\n        return Diff(x=x, y=y, old_val=old_val, new_val=new_val)\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Diff.new_val","title":"<code>new_val: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Diff.old_val","title":"<code>old_val: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Diff.x","title":"<code>x: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Diff.y","title":"<code>y: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Diff.__init__","title":"<code>__init__(x, y, old_val, new_val)</code>","text":""},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Diff.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"({self.x}, {self.y}): {self.old_val} '{chr(self.old_val)}' -&gt; {self.new_val} '{chr(self.new_val)}'\\n\"\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Diff.add_to_feature","title":"<code>add_to_feature(n)</code>","text":"<p>Adds a set of Diff nodes to a Feature</p> Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>def add_to_feature(self, n: Feature) -&gt; None:\n    \"\"\"Adds a set of Diff nodes to a Feature\"\"\"\n    n.add_type(self.new_val)\n    n.add_point(self.x, self.y)\n    ol = OldLocation(n.origin, self.x, self.y, self.old_val)\n    n.add_feature(\"Past\", ol)\n</code></pre>"},{"location":"reference/feature_extractors/delta/#feature_extractors.delta.Diff.from_feature","title":"<code>from_feature(n)</code>  <code>classmethod</code>","text":"<p>Creates a Diff from a Feature that has all the right Nodes</p> Source code in <code>roc/feature_extractors/delta.py</code> <pre><code>@classmethod\ndef from_feature(self, n: Feature) -&gt; Diff:\n    \"\"\"Creates a Diff from a Feature that has all the right Nodes\"\"\"\n    x, y = n.get_point()\n    new_val = n.get_type()\n    old = n.get_feature(\"Past\")\n    assert isinstance(old, Feature)\n    old_val = old.get_type()\n    return Diff(x=x, y=y, old_val=old_val, new_val=new_val)\n</code></pre>"},{"location":"reference/feature_extractors/distance/","title":"distance","text":"<p>Calculates distance between Singles. Note: this is probably post-attention in humans, only calculated for a subset of features, and based on the saccades of the eyes.</p>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.Distance","title":"<code>Distance</code>","text":"<p>               Bases: <code>FeatureExtractor[DistanceFeature]</code></p> Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>@register_component(\"distance\", \"perception\")\nclass Distance(FeatureExtractor[DistanceFeature]):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.prev_features: list[SingleFeature] = []\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        # only listen to single:perception events\n        if e.src.name == \"single\" and e.src.type == \"perception\":\n            return True\n        return False\n\n    def get_feature(self, e: PerceptionEvent) -&gt; Feature | None:\n        data = e.data\n\n        if isinstance(data, Settled):\n            self.prev_features.clear()\n            self.settled()\n            return None\n\n        # calculate distance between all previous elements and emit event for each\n        assert isinstance(data, SingleFeature)\n        curr_pt = data.get_point()\n        for f in self.prev_features:\n            prev_pt = f.get_point()\n            dist = chebyshev_distance(curr_pt, prev_pt)\n            self.pb_conn.send(DistanceFeature(self, curr_pt, prev_pt, dist))\n\n        # add to previous elements\n        self.prev_features.append(data)\n\n        return None\n</code></pre>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.Distance.prev_features","title":"<code>prev_features: list[SingleFeature] = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.Distance.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.prev_features: list[SingleFeature] = []\n</code></pre>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.Distance.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    # only listen to single:perception events\n    if e.src.name == \"single\" and e.src.type == \"perception\":\n        return True\n    return False\n</code></pre>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.Distance.get_feature","title":"<code>get_feature(e)</code>","text":"Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>def get_feature(self, e: PerceptionEvent) -&gt; Feature | None:\n    data = e.data\n\n    if isinstance(data, Settled):\n        self.prev_features.clear()\n        self.settled()\n        return None\n\n    # calculate distance between all previous elements and emit event for each\n    assert isinstance(data, SingleFeature)\n    curr_pt = data.get_point()\n    for f in self.prev_features:\n        prev_pt = f.get_point()\n        dist = chebyshev_distance(curr_pt, prev_pt)\n        self.pb_conn.send(DistanceFeature(self, curr_pt, prev_pt, dist))\n\n    # add to previous elements\n    self.prev_features.append(data)\n\n    return None\n</code></pre>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.DistanceFeature","title":"<code>DistanceFeature</code>","text":"<p>               Bases: <code>Feature</code></p> <p>The distance between two features</p> Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>class DistanceFeature(Feature):\n    \"\"\"The distance between two features\"\"\"\n\n    def __init__(\n        self, origin: Component, start: tuple[int, int], end: tuple[int, int], sz: int\n    ) -&gt; None:\n        super().__init__(origin, \"Distance\")\n        self.add_size(sz)\n        self.add_point(start[0], start[1])\n        self.add_point(end[0], end[1])\n\n    def __hash__(self) -&gt; int:\n        raise NotImplementedError(\"DistanceFeature hash not implemented\")\n</code></pre>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.DistanceFeature.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>def __hash__(self) -&gt; int:\n    raise NotImplementedError(\"DistanceFeature hash not implemented\")\n</code></pre>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.DistanceFeature.__init__","title":"<code>__init__(origin, start, end, sz)</code>","text":"Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>def __init__(\n    self, origin: Component, start: tuple[int, int], end: tuple[int, int], sz: int\n) -&gt; None:\n    super().__init__(origin, \"Distance\")\n    self.add_size(sz)\n    self.add_point(start[0], start[1])\n    self.add_point(end[0], end[1])\n</code></pre>"},{"location":"reference/feature_extractors/distance/#feature_extractors.distance.chebyshev_distance","title":"<code>chebyshev_distance(p1, p2)</code>","text":"Source code in <code>roc/feature_extractors/distance.py</code> <pre><code>def chebyshev_distance(p1: tuple[int, int], p2: tuple[int, int]) -&gt; int:\n    x1 = p1[0]\n    x2 = p2[0]\n    y1 = p1[1]\n    y2 = p2[1]\n    dx = abs(x1 - x2)\n    dy = abs(y1 - y2)\n    return max(dx, dy)\n</code></pre>"},{"location":"reference/feature_extractors/flood/","title":"flood","text":""},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.MIN_FLOOD_SIZE","title":"<code>MIN_FLOOD_SIZE = 5</code>  <code>module-attribute</code>","text":""},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.CheckMap","title":"<code>CheckMap</code>","text":"<p>Internal utility class for tracking which points in a flood have already been checked</p> Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>class CheckMap:\n    \"\"\"Internal utility class for tracking which points in a flood have already been checked\"\"\"\n\n    def __init__(self, width: int, height: int) -&gt; None:\n        a = np.zeros((height, width))\n        self.grid = a.view(IntGrid)\n\n    def find_first_unused_point(self) -&gt; Point | None:\n        for p in self.grid.points():\n            if p.val == 0:\n                return p\n\n        return None\n\n    def set(self, x: int, y: int) -&gt; None:\n        self.grid.set_val(x, y, 1)\n\n    def checked(self, x: int, y: int) -&gt; bool:\n        return self.grid.get_val(x, y) == 1\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.CheckMap.grid","title":"<code>grid = a.view(IntGrid)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.CheckMap.__init__","title":"<code>__init__(width, height)</code>","text":"Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>def __init__(self, width: int, height: int) -&gt; None:\n    a = np.zeros((height, width))\n    self.grid = a.view(IntGrid)\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.CheckMap.checked","title":"<code>checked(x, y)</code>","text":"Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>def checked(self, x: int, y: int) -&gt; bool:\n    return self.grid.get_val(x, y) == 1\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.CheckMap.find_first_unused_point","title":"<code>find_first_unused_point()</code>","text":"Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>def find_first_unused_point(self) -&gt; Point | None:\n    for p in self.grid.points():\n        if p.val == 0:\n            return p\n\n    return None\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.CheckMap.set","title":"<code>set(x, y)</code>","text":"Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>def set(self, x: int, y: int) -&gt; None:\n    self.grid.set_val(x, y, 1)\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.Flood","title":"<code>Flood</code>","text":"<p>               Bases: <code>FeatureExtractor[TypedPointCollection]</code></p> <p>A component for creating Flood features -- collections of adjacent points that all have the same value</p> Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>@register_component(\"flood\", \"perception\")\nclass Flood(FeatureExtractor[TypedPointCollection]):\n    \"\"\"A component for creating Flood features -- collections of adjacent points\n    that all have the same value\n    \"\"\"\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        return isinstance(e.data, VisionData)\n\n    def get_feature(self, e: PerceptionEvent) -&gt; Feature | None:\n        assert isinstance(e.data, VisionData)\n        data = IntGrid(e.data.chars)\n\n        check_map = CheckMap(data.width, data.height)\n\n        def recursive_flood_check(val: int, x: int, y: int, point_list: PointList) -&gt; PointList:\n            if x &lt; 0 or y &lt; 0 or x &gt;= data.width or y &gt;= data.height:\n                # out of bounds... move on\n                return point_list\n\n            if check_map.checked(x, y):\n                # we already checked this point... move on\n                return point_list\n\n            if data.get_val(x, y) != val:\n                # not the right value, for this flood... move on\n                return point_list\n\n            check_map.set(x, y)\n            point_list.append(Point(x, y, val))\n\n            # explanation:\n            # (0, 0) is top left, algorithm is iterating from left to right and\n            # top to bottom\n            # check left: already done\n            # check up *: already done\n\n            # check right\n            recursive_flood_check(val, x + 1, y, point_list)\n            # check left down\n            recursive_flood_check(val, x - 1, y + 1, point_list)\n            # check down\n            recursive_flood_check(val, x, y + 1, point_list)\n            # check right down\n            recursive_flood_check(val, x + 1, y + 1, point_list)\n\n            return point_list\n\n        while p := check_map.find_first_unused_point():\n            val = data.get_val(p.x, p.y)\n            point_list = recursive_flood_check(val, p.x, p.y, [])\n            if len(point_list) &gt;= MIN_FLOOD_SIZE:\n                self.pb_conn.send(FloodFeature(self, point_list, val))\n            check_map.set(p.x, p.y)\n\n        self.settled()\n        return None\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.Flood.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    return isinstance(e.data, VisionData)\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.Flood.get_feature","title":"<code>get_feature(e)</code>","text":"Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>def get_feature(self, e: PerceptionEvent) -&gt; Feature | None:\n    assert isinstance(e.data, VisionData)\n    data = IntGrid(e.data.chars)\n\n    check_map = CheckMap(data.width, data.height)\n\n    def recursive_flood_check(val: int, x: int, y: int, point_list: PointList) -&gt; PointList:\n        if x &lt; 0 or y &lt; 0 or x &gt;= data.width or y &gt;= data.height:\n            # out of bounds... move on\n            return point_list\n\n        if check_map.checked(x, y):\n            # we already checked this point... move on\n            return point_list\n\n        if data.get_val(x, y) != val:\n            # not the right value, for this flood... move on\n            return point_list\n\n        check_map.set(x, y)\n        point_list.append(Point(x, y, val))\n\n        # explanation:\n        # (0, 0) is top left, algorithm is iterating from left to right and\n        # top to bottom\n        # check left: already done\n        # check up *: already done\n\n        # check right\n        recursive_flood_check(val, x + 1, y, point_list)\n        # check left down\n        recursive_flood_check(val, x - 1, y + 1, point_list)\n        # check down\n        recursive_flood_check(val, x, y + 1, point_list)\n        # check right down\n        recursive_flood_check(val, x + 1, y + 1, point_list)\n\n        return point_list\n\n    while p := check_map.find_first_unused_point():\n        val = data.get_val(p.x, p.y)\n        point_list = recursive_flood_check(val, p.x, p.y, [])\n        if len(point_list) &gt;= MIN_FLOOD_SIZE:\n            self.pb_conn.send(FloodFeature(self, point_list, val))\n        check_map.set(p.x, p.y)\n\n    self.settled()\n    return None\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.FloodFeature","title":"<code>FloodFeature</code>","text":"<p>               Bases: <code>Feature</code></p> <p>A collection of points representing similar values that are all adjacent to each other</p> Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>class FloodFeature(Feature):\n    \"\"\"A collection of points representing similar values that are all adjacent to each other\"\"\"\n\n    def __init__(self, origin: Component, point_list: PointList, type: int) -&gt; None:\n        super().__init__(origin, \"Flood\")\n        self.add_type(type)\n        self.add_size(len(point_list))\n        for point in point_list:\n            self.add_point(point.x, point.y)\n\n    def __hash__(self) -&gt; int:\n        raise NotImplementedError(\"FloodFeature hash not implemented\")\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.FloodFeature.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>def __hash__(self) -&gt; int:\n    raise NotImplementedError(\"FloodFeature hash not implemented\")\n</code></pre>"},{"location":"reference/feature_extractors/flood/#feature_extractors.flood.FloodFeature.__init__","title":"<code>__init__(origin, point_list, type)</code>","text":"Source code in <code>roc/feature_extractors/flood.py</code> <pre><code>def __init__(self, origin: Component, point_list: PointList, type: int) -&gt; None:\n    super().__init__(origin, \"Flood\")\n    self.add_type(type)\n    self.add_size(len(point_list))\n    for point in point_list:\n        self.add_point(point.x, point.y)\n</code></pre>"},{"location":"reference/feature_extractors/line/","title":"line","text":""},{"location":"reference/feature_extractors/line/#feature_extractors.line.MIN_LINE_COUNT","title":"<code>MIN_LINE_COUNT = 4</code>  <code>module-attribute</code>","text":""},{"location":"reference/feature_extractors/line/#feature_extractors.line.Line","title":"<code>Line</code>","text":"<p>               Bases: <code>FeatureExtractor[TypedPointCollection]</code></p> <p>A component for identifying similar values located along a vertical or horizontal line</p> Source code in <code>roc/feature_extractors/line.py</code> <pre><code>@register_component(\"line\", \"perception\")\nclass Line(FeatureExtractor[TypedPointCollection]):\n    \"\"\"A component for identifying similar values located along a vertical or\n    horizontal line\n    \"\"\"\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        return isinstance(e.data, VisionData)\n\n    def get_feature(self, e: PerceptionEvent) -&gt; Feature | None:\n        assert isinstance(e.data, VisionData)\n        data = IntGrid(e.data.chars)\n\n        points: PointList = []\n\n        def try_emit(ln: Line) -&gt; None:\n            nonlocal points\n\n            if len(points) &gt;= MIN_LINE_COUNT:\n                ln.pb_conn.send(LineFeature(self, points, points[0].val))\n            points = []\n\n        ## iterate points by 'x' to identify horizontal lines\n        for y in range(data.height):\n            for x in range(data.width):\n                val = data.get_val(x, y)\n                points.append(Point(x, y, val))\n                if val != points[0].val:\n                    p = points.pop()\n                    try_emit(self)\n                    points = [p]\n            try_emit(self)\n\n        ## iterate points by 'y' to identify vertical lines\n        for x in range(data.width):\n            for y in range(data.height):\n                val = data.get_val(x, y)\n                points.append(Point(x, y, val))\n                if val != points[0].val:\n                    p = points.pop()\n                    try_emit(self)\n                    points = [p]\n            try_emit(self)\n\n        self.settled()\n        return None\n</code></pre>"},{"location":"reference/feature_extractors/line/#feature_extractors.line.Line.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/feature_extractors/line.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    return isinstance(e.data, VisionData)\n</code></pre>"},{"location":"reference/feature_extractors/line/#feature_extractors.line.Line.get_feature","title":"<code>get_feature(e)</code>","text":"Source code in <code>roc/feature_extractors/line.py</code> <pre><code>def get_feature(self, e: PerceptionEvent) -&gt; Feature | None:\n    assert isinstance(e.data, VisionData)\n    data = IntGrid(e.data.chars)\n\n    points: PointList = []\n\n    def try_emit(ln: Line) -&gt; None:\n        nonlocal points\n\n        if len(points) &gt;= MIN_LINE_COUNT:\n            ln.pb_conn.send(LineFeature(self, points, points[0].val))\n        points = []\n\n    ## iterate points by 'x' to identify horizontal lines\n    for y in range(data.height):\n        for x in range(data.width):\n            val = data.get_val(x, y)\n            points.append(Point(x, y, val))\n            if val != points[0].val:\n                p = points.pop()\n                try_emit(self)\n                points = [p]\n        try_emit(self)\n\n    ## iterate points by 'y' to identify vertical lines\n    for x in range(data.width):\n        for y in range(data.height):\n            val = data.get_val(x, y)\n            points.append(Point(x, y, val))\n            if val != points[0].val:\n                p = points.pop()\n                try_emit(self)\n                points = [p]\n        try_emit(self)\n\n    self.settled()\n    return None\n</code></pre>"},{"location":"reference/feature_extractors/line/#feature_extractors.line.LineFeature","title":"<code>LineFeature</code>","text":"<p>               Bases: <code>Feature</code></p> <p>A collection of points representing a line</p> Source code in <code>roc/feature_extractors/line.py</code> <pre><code>class LineFeature(Feature):\n    \"\"\"A collection of points representing a line\"\"\"\n\n    def __init__(self, origin: Component, point_list: PointList, type: int) -&gt; None:\n        super().__init__(origin, \"Line\")\n        self.add_type(type)\n        self.add_size(len(point_list))\n        for point in point_list:\n            self.add_point(point.x, point.y)\n\n    def __hash__(self) -&gt; int:\n        raise NotImplementedError(\"LineFeature hash not implemented\")\n</code></pre>"},{"location":"reference/feature_extractors/line/#feature_extractors.line.LineFeature.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>roc/feature_extractors/line.py</code> <pre><code>def __hash__(self) -&gt; int:\n    raise NotImplementedError(\"LineFeature hash not implemented\")\n</code></pre>"},{"location":"reference/feature_extractors/line/#feature_extractors.line.LineFeature.__init__","title":"<code>__init__(origin, point_list, type)</code>","text":"Source code in <code>roc/feature_extractors/line.py</code> <pre><code>def __init__(self, origin: Component, point_list: PointList, type: int) -&gt; None:\n    super().__init__(origin, \"Line\")\n    self.add_type(type)\n    self.add_size(len(point_list))\n    for point in point_list:\n        self.add_point(point.x, point.y)\n</code></pre>"},{"location":"reference/feature_extractors/motion/","title":"motion","text":"<p>Converts Delta events into Motion events that signify an object moving in a direction</p>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.DiffList","title":"<code>DiffList = list[Diff]</code>  <code>module-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.Motion","title":"<code>Motion</code>","text":"<p>               Bases: <code>FeatureExtractor[MotionFeature]</code></p> <p>Component that consumes Delta events and produces Motion events</p> Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>@register_component(\"motion\", \"perception\")\nclass Motion(FeatureExtractor[MotionFeature]):\n    \"\"\"Component that consumes Delta events and produces Motion events\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.diff_list: DiffList = []\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        # only listen to delta:perception events\n        if e.src.name == \"delta\" and e.src.type == \"perception\":\n            return True\n        return False\n\n    def get_feature(self, e: PerceptionEvent) -&gt; None:\n        if isinstance(e.data, Settled):\n            self.diff_list.clear()\n            self.settled()\n            return None\n\n        assert isinstance(e.data, DeltaFeature)\n        d1 = Diff.from_feature(e.data)\n\n        for d2 in self.diff_list:\n            if Point.isadjacent(x1=d1.x, y1=d1.y, x2=d2.x, y2=d2.y):\n                if d2.old_val == d1.new_val:\n                    emit_motion(self, d2, d1)\n                if d1.old_val == d2.new_val:\n                    emit_motion(self, d1, d2)\n\n        self.diff_list.append(d1)\n\n        return None\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.Motion.diff_list","title":"<code>diff_list: DiffList = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.Motion.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.diff_list: DiffList = []\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.Motion.event_filter","title":"<code>event_filter(e)</code>","text":"Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    # only listen to delta:perception events\n    if e.src.name == \"delta\" and e.src.type == \"perception\":\n        return True\n    return False\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.Motion.get_feature","title":"<code>get_feature(e)</code>","text":"Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def get_feature(self, e: PerceptionEvent) -&gt; None:\n    if isinstance(e.data, Settled):\n        self.diff_list.clear()\n        self.settled()\n        return None\n\n    assert isinstance(e.data, DeltaFeature)\n    d1 = Diff.from_feature(e.data)\n\n    for d2 in self.diff_list:\n        if Point.isadjacent(x1=d1.x, y1=d1.y, x2=d2.x, y2=d2.y):\n            if d2.old_val == d1.new_val:\n                emit_motion(self, d2, d1)\n            if d1.old_val == d2.new_val:\n                emit_motion(self, d1, d2)\n\n    self.diff_list.append(d1)\n\n    return None\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionFeature","title":"<code>MotionFeature</code>","text":"<p>               Bases: <code>ComplexFeature[MotionVector]</code></p> <p>A vector describing a motion, including the start point, end point, direction and value of the thing moving</p> Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>class MotionFeature(ComplexFeature[MotionVector]):\n    \"\"\"A vector describing a motion, including the start point, end point,\n    direction and value of the thing moving\n    \"\"\"\n\n    def __init__(self, origin: Component, mv: MotionVector):\n        super().__init__(\"Motion\", origin, mv)\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionFeature.__init__","title":"<code>__init__(origin, mv)</code>","text":"Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def __init__(self, origin: Component, mv: MotionVector):\n    super().__init__(\"Motion\", origin, mv)\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionVector","title":"<code>MotionVector</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Transmogrifier</code></p> <p>A Transmogrifier that converts nodes to a motion dataclass and vice versa</p> Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>@dataclass\nclass MotionVector(Transmogrifier):\n    \"\"\"A Transmogrifier that converts nodes to a motion dataclass and vice versa\"\"\"\n\n    direction: Direction\n    start_x: int\n    start_y: int\n    end_x: int\n    end_y: int\n    val: int\n\n    class Config:\n        \"\"\"Pydantic config\"\"\"\n\n        use_enum_values = True\n\n    def __str__(self) -&gt; str:\n        return f\"{self.val} '{chr(self.val)}' {self.direction}: ({self.start_x}, {self.start_y}) -&gt; ({self.end_x}, {self.end_y})\"\n\n    def add_to_feature(self, n: Feature) -&gt; None:\n        \"\"\"Adds nodes and edges to describe the motion\"\"\"\n        n.add_type(self.val)\n        n.add_point(self.end_x, self.end_y)\n        n.add_orientation(self.direction)\n        ol = OldLocation(n.origin, self.start_x, self.start_y, self.val)\n        n.add_feature(\"Origin\", ol)\n\n    @classmethod\n    def from_feature(self, n: Feature) -&gt; MotionVector:\n        \"\"\"Converts nodes and edges back into a dataclass that describes the motion\"\"\"\n        orig = n.get_feature(\"Origin\")\n        assert isinstance(orig, Feature)\n        start_loc = orig.get_feature(\"Location\")\n        assert isinstance(start_loc, ElementPoint)\n        val = n.get_feature(\"Type\")\n        assert isinstance(val, ElementType)\n        end_loc = n.get_feature(\"Location\")\n        assert isinstance(end_loc, ElementPoint)\n        dir = n.get_feature(\"Direction\")\n        assert isinstance(dir, ElementOrientation)\n        return MotionVector(\n            direction=dir.orientation,\n            start_x=start_loc.x,\n            start_y=start_loc.y,\n            end_x=end_loc.x,\n            end_y=end_loc.y,\n            val=val.type,\n        )\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionVector.direction","title":"<code>direction: Direction</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionVector.end_x","title":"<code>end_x: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionVector.end_y","title":"<code>end_y: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionVector.start_x","title":"<code>start_x: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionVector.start_y","title":"<code>start_y: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionVector.val","title":"<code>val: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionVector.Config","title":"<code>Config</code>","text":"<p>Pydantic config</p> Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>class Config:\n    \"\"\"Pydantic config\"\"\"\n\n    use_enum_values = True\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionVector.Config.use_enum_values","title":"<code>use_enum_values = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionVector.__init__","title":"<code>__init__(direction, start_x, start_y, end_x, end_y, val)</code>","text":""},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionVector.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"{self.val} '{chr(self.val)}' {self.direction}: ({self.start_x}, {self.start_y}) -&gt; ({self.end_x}, {self.end_y})\"\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionVector.add_to_feature","title":"<code>add_to_feature(n)</code>","text":"<p>Adds nodes and edges to describe the motion</p> Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def add_to_feature(self, n: Feature) -&gt; None:\n    \"\"\"Adds nodes and edges to describe the motion\"\"\"\n    n.add_type(self.val)\n    n.add_point(self.end_x, self.end_y)\n    n.add_orientation(self.direction)\n    ol = OldLocation(n.origin, self.start_x, self.start_y, self.val)\n    n.add_feature(\"Origin\", ol)\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.MotionVector.from_feature","title":"<code>from_feature(n)</code>  <code>classmethod</code>","text":"<p>Converts nodes and edges back into a dataclass that describes the motion</p> Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>@classmethod\ndef from_feature(self, n: Feature) -&gt; MotionVector:\n    \"\"\"Converts nodes and edges back into a dataclass that describes the motion\"\"\"\n    orig = n.get_feature(\"Origin\")\n    assert isinstance(orig, Feature)\n    start_loc = orig.get_feature(\"Location\")\n    assert isinstance(start_loc, ElementPoint)\n    val = n.get_feature(\"Type\")\n    assert isinstance(val, ElementType)\n    end_loc = n.get_feature(\"Location\")\n    assert isinstance(end_loc, ElementPoint)\n    dir = n.get_feature(\"Direction\")\n    assert isinstance(dir, ElementOrientation)\n    return MotionVector(\n        direction=dir.orientation,\n        start_x=start_loc.x,\n        start_y=start_loc.y,\n        end_x=end_loc.x,\n        end_y=end_loc.y,\n        val=val.type,\n    )\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.adjacent_direction","title":"<code>adjacent_direction(d1, d2)</code>","text":"<p>Helper function to convert two positions into a direction such as 'UP' or 'DOWN_LEFT'</p> Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def adjacent_direction(d1: Diff, d2: Diff) -&gt; Direction:\n    \"\"\"Helper function to convert two positions into a direction such as 'UP' or\n    'DOWN_LEFT'\n    \"\"\"\n    lr_str = \"\"\n    if d1.x &lt; d2.x:\n        lr_str = \"RIGHT\"\n    elif d1.x &gt; d2.x:\n        lr_str = \"LEFT\"\n\n    ud_str = \"\"\n    # XXX: top left is 0,0\n    if d1.y &gt; d2.y:\n        ud_str = \"UP\"\n    if d1.y &lt; d2.y:\n        ud_str = \"DOWN\"\n\n    join_str = \"\"\n    if len(lr_str) and len(ud_str):\n        join_str = \"_\"\n\n    return Direction(f\"{ud_str}{join_str}{lr_str}\")\n</code></pre>"},{"location":"reference/feature_extractors/motion/#feature_extractors.motion.emit_motion","title":"<code>emit_motion(mc, old_diff, new_diff)</code>","text":"Source code in <code>roc/feature_extractors/motion.py</code> <pre><code>def emit_motion(mc: Motion, old_diff: Diff, new_diff: Diff) -&gt; None:\n    mc.pb_conn.send(\n        MotionFeature(\n            mc,\n            MotionVector(\n                start_x=old_diff.x,\n                start_y=old_diff.y,\n                end_x=new_diff.x,\n                end_y=new_diff.y,\n                val=new_diff.new_val,\n                direction=adjacent_direction(old_diff, new_diff),\n            ),\n        )\n    )\n</code></pre>"},{"location":"reference/feature_extractors/single/","title":"single","text":"<p>Generates Features for things that aren't like their neighbors</p>"},{"location":"reference/feature_extractors/single/#feature_extractors.single.Single","title":"<code>Single</code>","text":"<p>               Bases: <code>FeatureExtractor[Point]</code></p> <p>A component for identifying single, isolated visual features</p> Source code in <code>roc/feature_extractors/single.py</code> <pre><code>@register_component(\"single\", \"perception\")\nclass Single(FeatureExtractor[Point]):\n    \"\"\"A component for identifying single, isolated visual features\"\"\"\n\n    def event_filter(self, e: PerceptionEvent) -&gt; bool:\n        \"\"\"Filters out non-VisionData\n\n        Args:\n            e (PerceptionEvent): Any event on the perception bus\n\n        Returns:\n            bool: Returns True if the event is VisionData to keep processing it,\n            False otherwise.\n        \"\"\"\n        return isinstance(e.data, VisionData)\n\n    def get_feature(self, e: PerceptionEvent) -&gt; Feature | None:\n        vd = e.data\n        assert isinstance(vd, VisionData)\n        # assert isinstance(vd.chars, npt.ArrayLike)\n        data = IntGrid(vd.chars)\n\n        ## iterate points\n        for v, x, y in data:\n            point = Point(x, y, v)\n            if is_unique_from_neighbors(data, point):\n                self.pb_conn.send(SingleFeature(self, point))\n        self.settled()\n        return None\n</code></pre>"},{"location":"reference/feature_extractors/single/#feature_extractors.single.Single.event_filter","title":"<code>event_filter(e)</code>","text":"<p>Filters out non-VisionData</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>PerceptionEvent</code> <p>Any event on the perception bus</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns True if the event is VisionData to keep processing it,</p> <code>bool</code> <p>False otherwise.</p> Source code in <code>roc/feature_extractors/single.py</code> <pre><code>def event_filter(self, e: PerceptionEvent) -&gt; bool:\n    \"\"\"Filters out non-VisionData\n\n    Args:\n        e (PerceptionEvent): Any event on the perception bus\n\n    Returns:\n        bool: Returns True if the event is VisionData to keep processing it,\n        False otherwise.\n    \"\"\"\n    return isinstance(e.data, VisionData)\n</code></pre>"},{"location":"reference/feature_extractors/single/#feature_extractors.single.Single.get_feature","title":"<code>get_feature(e)</code>","text":"Source code in <code>roc/feature_extractors/single.py</code> <pre><code>def get_feature(self, e: PerceptionEvent) -&gt; Feature | None:\n    vd = e.data\n    assert isinstance(vd, VisionData)\n    # assert isinstance(vd.chars, npt.ArrayLike)\n    data = IntGrid(vd.chars)\n\n    ## iterate points\n    for v, x, y in data:\n        point = Point(x, y, v)\n        if is_unique_from_neighbors(data, point):\n            self.pb_conn.send(SingleFeature(self, point))\n    self.settled()\n    return None\n</code></pre>"},{"location":"reference/feature_extractors/single/#feature_extractors.single.SingleFeature","title":"<code>SingleFeature</code>","text":"<p>               Bases: <code>Feature</code></p> <p>A collection of points representing similar values that are all adjacent to each other</p> Source code in <code>roc/feature_extractors/single.py</code> <pre><code>class SingleFeature(Feature):\n    \"\"\"A collection of points representing similar values that are all adjacent to each other\"\"\"\n\n    def __init__(self, origin: Component, point: Point) -&gt; None:\n        super().__init__(origin, \"Single\")\n        self.add_point(point.x, point.y)\n        self.add_type(point.val)\n\n    def __hash__(self) -&gt; int:\n        raise NotImplementedError(\"SingleFeature hash not implemented\")\n</code></pre>"},{"location":"reference/feature_extractors/single/#feature_extractors.single.SingleFeature.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>roc/feature_extractors/single.py</code> <pre><code>def __hash__(self) -&gt; int:\n    raise NotImplementedError(\"SingleFeature hash not implemented\")\n</code></pre>"},{"location":"reference/feature_extractors/single/#feature_extractors.single.SingleFeature.__init__","title":"<code>__init__(origin, point)</code>","text":"Source code in <code>roc/feature_extractors/single.py</code> <pre><code>def __init__(self, origin: Component, point: Point) -&gt; None:\n    super().__init__(origin, \"Single\")\n    self.add_point(point.x, point.y)\n    self.add_type(point.val)\n</code></pre>"},{"location":"reference/feature_extractors/single/#feature_extractors.single.is_unique_from_neighbors","title":"<code>is_unique_from_neighbors(data, point)</code>","text":"<p>Helper function to determine if a point in a matrix has the same value as any points around it.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>VisionData</code> <p>The matrix / Grid to evaluate</p> required <code>point</code> <code>Point</code> <p>The point to see if any of its neighbors have the same value</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns True if the point is different from all surrounding</p> <code>bool</code> <p>points, False otherwise.</p> Source code in <code>roc/feature_extractors/single.py</code> <pre><code>def is_unique_from_neighbors(data: IntGrid, point: Point) -&gt; bool:\n    \"\"\"Helper function to determine if a point in a matrix has the same value as\n    any points around it.\n\n    Args:\n        data (VisionData): The matrix / Grid to evaluate\n        point (Point): The point to see if any of its neighbors have the same value\n\n    Returns:\n        bool: Returns True if the point is different from all surrounding\n        points, False otherwise.\n    \"\"\"\n    max_width = data.width - 1\n    max_height = data.height - 1\n    # up left\n    if point.x &gt; 0 and point.y &gt; 0 and data.get_val(point.x - 1, point.y - 1) == point.val:\n        return False\n    # up\n    if point.y &gt; 0 and data.get_val(point.x, point.y - 1) == point.val:\n        return False\n    # up right\n    if point.x &lt; max_width and point.y &gt; 0 and data.get_val(point.x + 1, point.y - 1) == point.val:\n        return False\n    # left\n    if point.x &gt; 0 and data.get_val(point.x - 1, point.y) == point.val:\n        return False\n    # right\n    if point.x &lt; max_width and data.get_val(point.x + 1, point.y) == point.val:\n        return False\n    # down left\n    if point.x &gt; 0 and point.y &lt; max_height and data.get_val(point.x - 1, point.y + 1) == point.val:\n        return False\n    # down\n    if point.y &lt; max_height and data.get_val(point.x, point.y + 1) == point.val:\n        return False\n    # down right\n    if (\n        point.x &lt; max_width\n        and point.y &lt; max_height\n        and data.get_val(point.x + 1, point.y + 1) == point.val\n    ):\n        return False\n    return True\n</code></pre>"},{"location":"reference/jupyter/brk/","title":"brk","text":""},{"location":"reference/jupyter/brk/#jupyter.brk.add","title":"<code>add(function)</code>","text":"<p>Add a breakpoints by name or function</p> Source code in <code>roc/jupyter/brk.py</code> <pre><code>@brk_cli.command()\n@click.argument(\"function\")\ndef add(function: str) -&gt; None:\n    \"\"\"Add a breakpoints by name or function\"\"\"\n    sym = get_symbol(function)\n\n    breakpoints.add(sym, name=function, src=\"&lt;iPython&gt;\")\n    print(f\"Added breakpoint: '{function}'\")  # noqa: T201\n</code></pre>"},{"location":"reference/jupyter/brk/#jupyter.brk.brk_cli","title":"<code>brk_cli(ctx)</code>","text":"<p>Controls breakpoints for ROC</p> Source code in <code>roc/jupyter/brk.py</code> <pre><code>@click.group(invoke_without_command=True)\n@click.pass_context\ndef brk_cli(ctx: click.Context) -&gt; None:\n    \"\"\"Controls breakpoints for ROC\"\"\"\n    if ctx.invoked_subcommand is None:\n        breakpoints.do_break()\n</code></pre>"},{"location":"reference/jupyter/brk/#jupyter.brk.clear","title":"<code>clear()</code>","text":"<p>Remove all breakpoints</p> Source code in <code>roc/jupyter/brk.py</code> <pre><code>@brk_cli.command()\ndef clear() -&gt; None:\n    \"\"\"Remove all breakpoints\"\"\"\n    breakpoints.clear()\n</code></pre>"},{"location":"reference/jupyter/brk/#jupyter.brk.list","title":"<code>list()</code>","text":"<p>List all breakpoints</p> Source code in <code>roc/jupyter/brk.py</code> <pre><code>@brk_cli.command()\ndef list() -&gt; None:\n    \"\"\"List all breakpoints\"\"\"\n    breakpoints.list()\n</code></pre>"},{"location":"reference/jupyter/brk/#jupyter.brk.remove","title":"<code>remove(name)</code>","text":"<p>Remove a breakpoint</p> Source code in <code>roc/jupyter/brk.py</code> <pre><code>@brk_cli.command()\n@click.argument(\"name\")\ndef remove(name: str) -&gt; None:\n    \"\"\"Remove a breakpoint\"\"\"\n    breakpoints.remove(name)\n</code></pre>"},{"location":"reference/jupyter/cont/","title":"cont","text":""},{"location":"reference/jupyter/cont/#jupyter.cont.cont_cli","title":"<code>cont_cli()</code>","text":"Source code in <code>roc/jupyter/cont.py</code> <pre><code>@click.command()\ndef cont_cli() -&gt; None:\n    breakpoints.resume()\n</code></pre>"},{"location":"reference/jupyter/roc/","title":"roc","text":""},{"location":"reference/jupyter/roc/#jupyter.roc.roc_cli","title":"<code>roc_cli(num_steps)</code>","text":"<p>Starts running ROC. Assumes that roc.init() has already been called (otherwise how are magics available?)</p> Source code in <code>roc/jupyter/roc.py</code> <pre><code>@click.command()\n@click.argument(\"num_steps\", type=int, default=-1)\ndef roc_cli(num_steps: int) -&gt; None:\n    \"\"\"Starts running ROC. Assumes that roc.init() has already been called\n    (otherwise how are magics available?)\n    \"\"\"\n    roc.start()\n    if num_steps &gt;= 0:\n        add_step(num_steps)\n</code></pre>"},{"location":"reference/jupyter/save/","title":"save","text":""},{"location":"reference/jupyter/save/#jupyter.save.save_cli","title":"<code>save_cli(format, filename, timestamp)</code>","text":"Source code in <code>roc/jupyter/save.py</code> <pre><code>@click.command()\n@click.option(\n    \"-f\",\n    \"--format\",\n    default=\"gexf\",\n    type=click.Choice(\n        [\n            \"gexf\",\n            \"gml\",\n            \"dot\",\n            \"graphml\",\n            \"json-node-link\",\n            \"json-adj\",\n            \"cytoscape\",\n            \"pajek\",\n            \"matrix-market\",\n            \"adj-list\",\n            \"multi-adj-list\",\n            \"edge-list\",\n        ],\n        case_sensitive=False,\n    ),\n)\n@click.option(\"--timestamp/--no-timestamp\", is_flag=True, default=True)\n@click.argument(\"filename\", nargs=1, type=click.Path(), default=\"graph\", required=False)\ndef save_cli(format: str, filename: str, timestamp: bool) -&gt; None:\n    ids = Node.all_ids()\n    print(f\"Saving {len(ids)} nodes...\")  # noqa: T201\n    start_time = time.time()\n\n    # tqdm options: https://github.com/tqdm/tqdm?tab=readme-ov-file#parameters\n    with tqdm(total=len(ids), desc=\"Nodes\", unit=\"node\", ncols=80, colour=\"blue\") as pbar:\n\n        def progress_update(n: Node) -&gt; bool:\n            pbar.update(1)\n            return True\n\n        G = GraphDB.to_networkx(node_ids=ids, filter=progress_update)\n\n    # format timestamp\n    if timestamp:\n        # time format: https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior\n        timestr = datetime.now().strftime(\"%Y.%m.%d-%H.%M.%S\")\n        filename = f\"{filename}-{timestr}\"\n\n    print(f\"Writing graph to '{filename}'...\")  # noqa: T201\n    match format:\n        case \"gexf\":\n            nx.write_gexf(G, f\"{filename}.gexf\")\n        case \"gml\":\n            nx.write_gml(G, f\"{filename}.gml\")\n        case \"dot\":\n            # XXX: pydot uses the 'name' attribute internally, so rename ours if it exists\n            for n in G.nodes(data=True):\n                if \"name\" in n[1]:\n                    n[1][\"nme\"] = n[1][\"name\"]\n                    del n[1][\"name\"]\n            write_dot(G, f\"{filename}.dot\")\n        case \"graphml\":\n            nx.write_graphml(G, f\"{filename}.graphml\")\n        # case \"json-tree\":\n        #     with open(f\"{filename}.tree.json\", \"w\", encoding=\"utf8\") as f:\n        #         json.dump(nx.tree_data(G), f)\n        case \"json-node-link\":\n            with open(f\"{filename}.node-link.json\", \"w\", encoding=\"utf8\") as f:\n                json.dump(nx.node_link_data(G), f)\n        case \"json-adj\":\n            with open(f\"{filename}.adj.json\", \"w\", encoding=\"utf8\") as f:\n                json.dump(nx.adjacency_data(G), f)\n        case \"cytoscape\":\n            with open(f\"{filename}.cytoscape.json\", \"w\", encoding=\"utf8\") as f:\n                json.dump(nx.cytoscape_data(G), f)\n        case \"pajek\":\n            nx.write_pajek(G, f\"{filename}.pajek\")\n        case \"matrix-market\":\n            np_graph = nx.to_numpy_array(G)\n            sp.io.mmwrite(f\"{filename}.mm\", np_graph)\n        case \"adj-list\":\n            nx.write_adjlist(G, f\"{filename}.adjlist\")\n        case \"multi-adj-list\":\n            nx.write_multiline_adjlist(G, f\"{filename}.madjlist\")\n        case \"edge-list\":\n            nx.write_edgelist(G, f\"{filename}.edges\")\n\n    end_time = time.time()\n\n    nc = Node.get_cache()\n    ec = Edge.get_cache()\n    assert len(nc) == len(ids)\n    print(  # noqa: T201\n        f\"Saved {len(ids)} nodes and {len(ec)} edges. Elapsed time: {timedelta(seconds=(end_time-start_time))}\"\n    )\n</code></pre>"},{"location":"reference/jupyter/state/","title":"state","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateType","title":"<code>StateType = TypeVar('StateType')</code>  <code>module-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.states","title":"<code>states = StateList()</code>  <code>module-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.AvailableMemoryState","title":"<code>AvailableMemoryState</code>","text":"<p>               Bases: <code>State[int]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class AvailableMemoryState(State[int]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"sysmem\")\n        self.val = self.get()\n\n    def __str__(self) -&gt; str:\n        vm = self.get()\n        return f\"Available System Memory: {bytes2human(vm)}\"\n\n    def get(self) -&gt; int:\n        vm = psutil.virtual_memory()\n        return cast(int, vm.available)\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.AvailableMemoryState.val","title":"<code>val = self.get()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.AvailableMemoryState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"sysmem\")\n    self.val = self.get()\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.AvailableMemoryState.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    vm = self.get()\n    return f\"Available System Memory: {bytes2human(vm)}\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.AvailableMemoryState.get","title":"<code>get()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def get(self) -&gt; int:\n    vm = psutil.virtual_memory()\n    return cast(int, vm.available)\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CpuLoadState","title":"<code>CpuLoadState</code>","text":"<p>               Bases: <code>State[list[float]]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class CpuLoadState(State[list[float]]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"cpuload\")\n        self.val = self.get()\n\n    def __str__(self) -&gt; str:\n        load = self.get()\n        return f\"CPU Load: {load[0]:1.1f}% / {load[1]:1.1f}% / {load[2]:1.1f}% (1m / 5m / 15m)\"\n\n    def get(self) -&gt; list[float]:\n        return [x / psutil.cpu_count() * 100 for x in psutil.getloadavg()]\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CpuLoadState.val","title":"<code>val = self.get()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.CpuLoadState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"cpuload\")\n    self.val = self.get()\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CpuLoadState.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    load = self.get()\n    return f\"CPU Load: {load[0]:1.1f}% / {load[1]:1.1f}% / {load[2]:1.1f}% (1m / 5m / 15m)\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.CpuLoadState.get","title":"<code>get()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def get(self) -&gt; list[float]:\n    return [x / psutil.cpu_count() * 100 for x in psutil.getloadavg()]\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState","title":"<code>DiskIoState</code>","text":"<p>               Bases: <code>State[dict[str, float]]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class DiskIoState(State[dict[str, float]]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"diskio\")\n        self.last_time = time.time_ns()\n        ioc = psutil.disk_io_counters()\n        self.last_read_io = ioc.read_count\n        self.last_write_io = ioc.write_count\n        self.last_read_bytes = ioc.read_bytes\n        self.last_write_bytes = ioc.write_bytes\n\n    def __str__(self) -&gt; str:\n        disk_io = self.get()\n        read_io = disk_io[\"read_io\"]\n        write_io = disk_io[\"write_io\"]\n        read_bytes = int(disk_io[\"read_bytes\"])\n        write_bytes = int(disk_io[\"write_bytes\"])\n        return f\"Disk Read I/O: {read_io:1.1f}/s ({bytes2human(read_bytes)}/s), Write I/O {write_io:1.1f}/s ({bytes2human(write_bytes)}/s)\"\n\n    def get(self) -&gt; dict[str, float]:\n        ioc = psutil.disk_io_counters()\n        now = time.time_ns()\n        delta_sec = (now - self.last_time) / 10e8\n        read_io_per_sec = (ioc.read_count - self.last_read_io) / delta_sec\n        write_io_per_sec = (ioc.write_count - self.last_write_io) / delta_sec\n        read_bytes_per_sec = (ioc.read_bytes - self.last_read_bytes) / delta_sec\n        write_bytes_per_sec = (ioc.write_bytes - self.last_write_bytes) / delta_sec\n        self.last_read_io = ioc.read_count\n        self.last_write_io = ioc.write_count\n        self.last_read_bytes = ioc.read_bytes\n        self.last_write_bytes = ioc.write_bytes\n        self.last_time = now\n\n        return {\n            \"read_io\": read_io_per_sec,\n            \"write_io\": write_io_per_sec,\n            \"read_bytes\": read_bytes_per_sec,\n            \"write_bytes\": write_bytes_per_sec,\n        }\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.last_read_bytes","title":"<code>last_read_bytes = ioc.read_bytes</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.last_read_io","title":"<code>last_read_io = ioc.read_count</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.last_time","title":"<code>last_time = time.time_ns()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.last_write_bytes","title":"<code>last_write_bytes = ioc.write_bytes</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.last_write_io","title":"<code>last_write_io = ioc.write_count</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"diskio\")\n    self.last_time = time.time_ns()\n    ioc = psutil.disk_io_counters()\n    self.last_read_io = ioc.read_count\n    self.last_write_io = ioc.write_count\n    self.last_read_bytes = ioc.read_bytes\n    self.last_write_bytes = ioc.write_bytes\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    disk_io = self.get()\n    read_io = disk_io[\"read_io\"]\n    write_io = disk_io[\"write_io\"]\n    read_bytes = int(disk_io[\"read_bytes\"])\n    write_bytes = int(disk_io[\"write_bytes\"])\n    return f\"Disk Read I/O: {read_io:1.1f}/s ({bytes2human(read_bytes)}/s), Write I/O {write_io:1.1f}/s ({bytes2human(write_bytes)}/s)\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.DiskIoState.get","title":"<code>get()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def get(self) -&gt; dict[str, float]:\n    ioc = psutil.disk_io_counters()\n    now = time.time_ns()\n    delta_sec = (now - self.last_time) / 10e8\n    read_io_per_sec = (ioc.read_count - self.last_read_io) / delta_sec\n    write_io_per_sec = (ioc.write_count - self.last_write_io) / delta_sec\n    read_bytes_per_sec = (ioc.read_bytes - self.last_read_bytes) / delta_sec\n    write_bytes_per_sec = (ioc.write_bytes - self.last_write_bytes) / delta_sec\n    self.last_read_io = ioc.read_count\n    self.last_write_io = ioc.write_count\n    self.last_read_bytes = ioc.read_bytes\n    self.last_write_bytes = ioc.write_bytes\n    self.last_time = now\n\n    return {\n        \"read_io\": read_io_per_sec,\n        \"write_io\": write_io_per_sec,\n        \"read_bytes\": read_bytes_per_sec,\n        \"write_bytes\": write_bytes_per_sec,\n    }\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.LoopState","title":"<code>LoopState</code>","text":"<p>               Bases: <code>State[int]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class LoopState(State[int]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"loop\", display_name=\"Loop Number\")\n        self.val = 0\n\n    def incr(self) -&gt; None:\n        self.val = self.get() + 1\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.LoopState.val","title":"<code>val = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.LoopState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"loop\", display_name=\"Loop Number\")\n    self.val = 0\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.LoopState.incr","title":"<code>incr()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def incr(self) -&gt; None:\n    self.val = self.get() + 1\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.ProcessMemoryState","title":"<code>ProcessMemoryState</code>","text":"<p>               Bases: <code>State[int]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class ProcessMemoryState(State[int]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"memory\")\n        self.val = self.get()\n\n    def __str__(self) -&gt; str:\n        mem = self.get()\n        return f\"Process Memory Usage: {bytes2human(mem)}\"\n\n    def get(self) -&gt; int:\n        process = psutil.Process(os.getpid())\n        mem_info = process.memory_info()\n        return cast(int, mem_info.rss)\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.ProcessMemoryState.val","title":"<code>val = self.get()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.ProcessMemoryState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"memory\")\n    self.val = self.get()\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.ProcessMemoryState.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    mem = self.get()\n    return f\"Process Memory Usage: {bytes2human(mem)}\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.ProcessMemoryState.get","title":"<code>get()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def get(self) -&gt; int:\n    process = psutil.Process(os.getpid())\n    mem_info = process.memory_info()\n    return cast(int, mem_info.rss)\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.State","title":"<code>State</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[StateType]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class State(ABC, Generic[StateType]):\n    def __init__(self, name: str, display_name: str | None = None) -&gt; None:\n        self.name = name\n        self.display_name = display_name or name\n        self.val: StateType | None = None\n\n    def __str__(self) -&gt; str:\n        return f\"{self.display_name}: {self.val}\"\n\n    def get(self) -&gt; StateType:\n        if self.val is None:\n            raise Exception(\"Trying to get state value before it is set\")\n\n        return self.val\n\n    def set(self, v: StateType) -&gt; None:\n        self.val = v\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.State.display_name","title":"<code>display_name = display_name or name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.State.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.State.val","title":"<code>val: StateType | None = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.State.__init__","title":"<code>__init__(name, display_name=None)</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self, name: str, display_name: str | None = None) -&gt; None:\n    self.name = name\n    self.display_name = display_name or name\n    self.val: StateType | None = None\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.State.__str__","title":"<code>__str__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"{self.display_name}: {self.val}\"\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.State.get","title":"<code>get()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def get(self) -&gt; StateType:\n    if self.val is None:\n        raise Exception(\"Trying to get state value before it is set\")\n\n    return self.val\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.State.set","title":"<code>set(v)</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def set(self, v: StateType) -&gt; None:\n    self.val = v\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.StateList","title":"<code>StateList</code>  <code>dataclass</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>@dataclass\nclass StateList:\n    memory: ProcessMemoryState = ProcessMemoryState()\n    sysmem: AvailableMemoryState = AvailableMemoryState()\n    loop: LoopState = LoopState()\n    cpuload: CpuLoadState = CpuLoadState()\n    diskio: DiskIoState = DiskIoState()\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.StateList.cpuload","title":"<code>cpuload: CpuLoadState = CpuLoadState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.diskio","title":"<code>diskio: DiskIoState = DiskIoState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.loop","title":"<code>loop: LoopState = LoopState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.memory","title":"<code>memory: ProcessMemoryState = ProcessMemoryState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.sysmem","title":"<code>sysmem: AvailableMemoryState = AvailableMemoryState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.StateList.__init__","title":"<code>__init__(memory=ProcessMemoryState(), sysmem=AvailableMemoryState(), loop=LoopState(), cpuload=CpuLoadState(), diskio=DiskIoState())</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.SystemCpuState","title":"<code>SystemCpuState</code>","text":"<p>               Bases: <code>State[int]</code></p> Source code in <code>roc/jupyter/state.py</code> <pre><code>class SystemCpuState(State[int]):\n    def __init__(self) -&gt; None:\n        super().__init__(\"cpu\", display_name=\"CPU Usage\")\n        self.val = self.get()\n\n    def get(self) -&gt; int:\n        psutil.cpu_times()\n        return 1\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.SystemCpuState.val","title":"<code>val = self.get()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jupyter/state/#jupyter.state.SystemCpuState.__init__","title":"<code>__init__()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"cpu\", display_name=\"CPU Usage\")\n    self.val = self.get()\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.SystemCpuState.get","title":"<code>get()</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>def get(self) -&gt; int:\n    psutil.cpu_times()\n    return 1\n</code></pre>"},{"location":"reference/jupyter/state/#jupyter.state.state_cli","title":"<code>state_cli(var)</code>","text":"Source code in <code>roc/jupyter/state.py</code> <pre><code>@click.command()\n@click.argument(\n    \"var\",\n    type=click.Choice(\n        [field.name for field in dataclasses.fields(StateList)], case_sensitive=False\n    ),\n)\ndef state_cli(var: list[str]) -&gt; None:\n    for v in var:\n        pass\n</code></pre>"},{"location":"reference/jupyter/step/","title":"step","text":""},{"location":"reference/jupyter/step/#jupyter.step.step_cnt","title":"<code>step_cnt = 0</code>  <code>module-attribute</code>","text":""},{"location":"reference/jupyter/step/#jupyter.step.add_step","title":"<code>add_step(num_steps=1)</code>","text":"Source code in <code>roc/jupyter/step.py</code> <pre><code>def add_step(num_steps: int = 1) -&gt; None:\n    global step_cnt\n\n    step_cnt = num_steps\n    logger.info(f\"stepping {step_cnt} times...\")\n\n    breakpoints.add(do_step, name=\"step\")\n    breakpoints.resume(quiet=True)\n</code></pre>"},{"location":"reference/jupyter/step/#jupyter.step.do_step","title":"<code>do_step()</code>","text":"Source code in <code>roc/jupyter/step.py</code> <pre><code>def do_step() -&gt; bool:\n    global step_cnt\n\n    step_cnt -= 1\n    if step_cnt &lt;= 0:\n        breakpoints.remove(\"step\")\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/jupyter/step/#jupyter.step.step_cli","title":"<code>step_cli(num_steps)</code>","text":"Source code in <code>roc/jupyter/step.py</code> <pre><code>@click.command()\n@click.argument(\"num_steps\", type=int, default=1)\ndef step_cli(num_steps: int) -&gt; None:\n    add_step(num_steps)\n</code></pre>"},{"location":"reference/jupyter/utils/","title":"utils","text":""},{"location":"reference/jupyter/utils/#jupyter.utils.bytes2human","title":"<code>bytes2human(n)</code>","text":"Source code in <code>roc/jupyter/utils.py</code> <pre><code>def bytes2human(n: int) -&gt; str:\n    # stolen from: https://psutil.readthedocs.io/en/latest/#recipes\n    symbols = (\"K\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\")\n    prefix = {}\n    for i, s in enumerate(symbols):\n        prefix[s] = 1 &lt;&lt; (i + 1) * 10\n    for s in reversed(symbols):\n        if abs(n) &gt;= prefix[s]:\n            value = float(n) / prefix[s]\n            return \"%.1f%sB\" % (value, s)\n    return \"%sB\" % n\n</code></pre>"},{"location":"reference/jupyter/utils/#jupyter.utils.get_symbol","title":"<code>get_symbol(s)</code>","text":"Source code in <code>roc/jupyter/utils.py</code> <pre><code>def get_symbol(s: str) -&gt; Any:\n    ip = get_ipython()  # type: ignore # noqa: F821\n\n    if s not in ip.user_ns:\n        print(f\"ERROR: symbol '{s}' not found in iPython shell\")  # noqa: T201\n        return\n\n    return ip.user_ns[s]\n</code></pre>"}]}